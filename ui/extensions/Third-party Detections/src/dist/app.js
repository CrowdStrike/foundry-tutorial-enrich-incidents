function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var react = {exports: {}};

var react_production = {};

/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReact_production;

function requireReact_production () {
	if (hasRequiredReact_production) return react_production;
	hasRequiredReact_production = 1;

	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
	  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
	  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
	  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
	  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
	  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
	  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
	  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
	  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
	  REACT_MEMO_TYPE = Symbol.for("react.memo"),
	  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
	  REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
	  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
	  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
	  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
	  return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
	    isMounted: function () {
	      return false;
	    },
	    enqueueForceUpdate: function () {},
	    enqueueReplaceState: function () {},
	    enqueueSetState: function () {}
	  },
	  assign = Object.assign,
	  emptyObject = {};
	function Component(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function (partialState, callback) {
	  if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
	  this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	pureComponentPrototype.constructor = PureComponent;
	assign(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = true;
	var isArrayImpl = Array.isArray;
	function noop() {}
	var ReactSharedInternals = {
	    H: null,
	    A: null,
	    T: null,
	    S: null
	  },
	  hasOwnProperty = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, props) {
	  var refProp = props.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE,
	    type: type,
	    key: key,
	    ref: void 0 !== refProp ? refProp : null,
	    props: props
	  };
	}
	function cloneAndReplaceKey(oldElement, newKey) {
	  return ReactElement(oldElement.type, newKey, oldElement.props);
	}
	function isValidElement(object) {
	  return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function escape(key) {
	  var escaperLookup = {
	    "=": "=0",
	    ":": "=2"
	  };
	  return "$" + key.replace(/[=:]/g, function (match) {
	    return escaperLookup[match];
	  });
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index) {
	  return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
	}
	function resolveThenable(thenable) {
	  switch (thenable.status) {
	    case "fulfilled":
	      return thenable.value;
	    case "rejected":
	      throw thenable.reason;
	    default:
	      switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
	        "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
	      }, function (error) {
	        "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
	      })), thenable.status) {
	        case "fulfilled":
	          return thenable.value;
	        case "rejected":
	          throw thenable.reason;
	      }
	  }
	  throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
	  var type = typeof children;
	  if ("undefined" === type || "boolean" === type) children = null;
	  var invokeCallback = false;
	  if (null === children) invokeCallback = true;else switch (type) {
	    case "bigint":
	    case "string":
	    case "number":
	      invokeCallback = true;
	      break;
	    case "object":
	      switch (children.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	        case REACT_PORTAL_TYPE:
	          invokeCallback = true;
	          break;
	        case REACT_LAZY_TYPE:
	          return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
	      }
	  }
	  if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
	    return c;
	  })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
	  invokeCallback = 0;
	  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
	  if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
	    if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
	    array = String(children);
	    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
	  }
	  return invokeCallback;
	}
	function mapChildren(children, func, context) {
	  if (null == children) return children;
	  var result = [],
	    count = 0;
	  mapIntoArray(children, result, "", "", function (child) {
	    return func.call(context, child, count++);
	  });
	  return result;
	}
	function lazyInitializer(payload) {
	  if (-1 === payload._status) {
	    var ctor = payload._result;
	    ctor = ctor();
	    ctor.then(function (moduleObject) {
	      if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
	    }, function (error) {
	      if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
	    });
	    -1 === payload._status && (payload._status = 0, payload._result = ctor);
	  }
	  if (1 === payload._status) return payload._result.default;
	  throw payload._result;
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
	    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
	      var event = new window.ErrorEvent("error", {
	        bubbles: true,
	        cancelable: true,
	        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
	        error: error
	      });
	      if (!window.dispatchEvent(event)) return;
	    } else if ("object" === typeof process && "function" === typeof process.emit) {
	      process.emit("uncaughtException", error);
	      return;
	    }
	    console.error(error);
	  },
	  Children = {
	    map: mapChildren,
	    forEach: function (children, forEachFunc, forEachContext) {
	      mapChildren(children, function () {
	        forEachFunc.apply(this, arguments);
	      }, forEachContext);
	    },
	    count: function (children) {
	      var n = 0;
	      mapChildren(children, function () {
	        n++;
	      });
	      return n;
	    },
	    toArray: function (children) {
	      return mapChildren(children, function (child) {
	        return child;
	      }) || [];
	    },
	    only: function (children) {
	      if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
	      return children;
	    }
	  };
	react_production.Activity = REACT_ACTIVITY_TYPE;
	react_production.Children = Children;
	react_production.Component = Component;
	react_production.Fragment = REACT_FRAGMENT_TYPE;
	react_production.Profiler = REACT_PROFILER_TYPE;
	react_production.PureComponent = PureComponent;
	react_production.StrictMode = REACT_STRICT_MODE_TYPE;
	react_production.Suspense = REACT_SUSPENSE_TYPE;
	react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
	react_production.__COMPILER_RUNTIME = {
	  __proto__: null,
	  c: function (size) {
	    return ReactSharedInternals.H.useMemoCache(size);
	  }
	};
	react_production.cache = function (fn) {
	  return function () {
	    return fn.apply(null, arguments);
	  };
	};
	react_production.cacheSignal = function () {
	  return null;
	};
	react_production.cloneElement = function (element, config, children) {
	  if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
	  var props = assign({}, element.props),
	    key = element.key;
	  if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
	  var propName = arguments.length - 2;
	  if (1 === propName) props.children = children;else if (1 < propName) {
	    for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  return ReactElement(element.type, key, props);
	};
	react_production.createContext = function (defaultValue) {
	  defaultValue = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    _currentValue: defaultValue,
	    _currentValue2: defaultValue,
	    _threadCount: 0,
	    Provider: null,
	    Consumer: null
	  };
	  defaultValue.Provider = defaultValue;
	  defaultValue.Consumer = {
	    $$typeof: REACT_CONSUMER_TYPE,
	    _context: defaultValue
	  };
	  return defaultValue;
	};
	react_production.createElement = function (type, config, children) {
	  var propName,
	    props = {},
	    key = null;
	  if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
	  var childrenLength = arguments.length - 2;
	  if (1 === childrenLength) props.children = children;else if (1 < childrenLength) {
	    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === props[propName] && (props[propName] = childrenLength[propName]);
	  return ReactElement(type, key, props);
	};
	react_production.createRef = function () {
	  return {
	    current: null
	  };
	};
	react_production.forwardRef = function (render) {
	  return {
	    $$typeof: REACT_FORWARD_REF_TYPE,
	    render: render
	  };
	};
	react_production.isValidElement = isValidElement;
	react_production.lazy = function (ctor) {
	  return {
	    $$typeof: REACT_LAZY_TYPE,
	    _payload: {
	      _status: -1,
	      _result: ctor
	    },
	    _init: lazyInitializer
	  };
	};
	react_production.memo = function (type, compare) {
	  return {
	    $$typeof: REACT_MEMO_TYPE,
	    type: type,
	    compare: void 0 === compare ? null : compare
	  };
	};
	react_production.startTransition = function (scope) {
	  var prevTransition = ReactSharedInternals.T,
	    currentTransition = {};
	  ReactSharedInternals.T = currentTransition;
	  try {
	    var returnValue = scope(),
	      onStartTransitionFinish = ReactSharedInternals.S;
	    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
	    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
	  } catch (error) {
	    reportGlobalError(error);
	  } finally {
	    null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
	  }
	};
	react_production.unstable_useCacheRefresh = function () {
	  return ReactSharedInternals.H.useCacheRefresh();
	};
	react_production.use = function (usable) {
	  return ReactSharedInternals.H.use(usable);
	};
	react_production.useActionState = function (action, initialState, permalink) {
	  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
	};
	react_production.useCallback = function (callback, deps) {
	  return ReactSharedInternals.H.useCallback(callback, deps);
	};
	react_production.useContext = function (Context) {
	  return ReactSharedInternals.H.useContext(Context);
	};
	react_production.useDebugValue = function () {};
	react_production.useDeferredValue = function (value, initialValue) {
	  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
	};
	react_production.useEffect = function (create, deps) {
	  return ReactSharedInternals.H.useEffect(create, deps);
	};
	react_production.useEffectEvent = function (callback) {
	  return ReactSharedInternals.H.useEffectEvent(callback);
	};
	react_production.useId = function () {
	  return ReactSharedInternals.H.useId();
	};
	react_production.useImperativeHandle = function (ref, create, deps) {
	  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
	};
	react_production.useInsertionEffect = function (create, deps) {
	  return ReactSharedInternals.H.useInsertionEffect(create, deps);
	};
	react_production.useLayoutEffect = function (create, deps) {
	  return ReactSharedInternals.H.useLayoutEffect(create, deps);
	};
	react_production.useMemo = function (create, deps) {
	  return ReactSharedInternals.H.useMemo(create, deps);
	};
	react_production.useOptimistic = function (passthrough, reducer) {
	  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
	};
	react_production.useReducer = function (reducer, initialArg, init) {
	  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
	};
	react_production.useRef = function (initialValue) {
	  return ReactSharedInternals.H.useRef(initialValue);
	};
	react_production.useState = function (initialState) {
	  return ReactSharedInternals.H.useState(initialState);
	};
	react_production.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
	  return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	};
	react_production.useTransition = function () {
	  return ReactSharedInternals.H.useTransition();
	};
	react_production.version = "19.2.1";
	return react_production;
}

var hasRequiredReact;

function requireReact () {
	if (hasRequiredReact) return react.exports;
	hasRequiredReact = 1;

	{
	  react.exports = requireReact_production();
	}
	return react.exports;
}

var reactExports = requireReact();
var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

var React$1 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: React
}, [reactExports]);

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;

	Object.defineProperty(dist, "__esModule", {
	  value: true
	});
	dist.parse = parse;
	dist.serialize = serialize;
	/**
	 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
	 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
	 * which has been replaced by the token definition in RFC 7230 appendix B.
	 *
	 * cookie-name       = token
	 * token             = 1*tchar
	 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
	 *                     "*" / "+" / "-" / "." / "^" / "_" /
	 *                     "`" / "|" / "~" / DIGIT / ALPHA
	 *
	 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
	 * Allow same range as cookie value, except `=`, which delimits end of name.
	 */
	const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
	/**
	 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
	 *
	 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	 *                     ; US-ASCII characters excluding CTLs,
	 *                     ; whitespace DQUOTE, comma, semicolon,
	 *                     ; and backslash
	 *
	 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
	 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
	 */
	const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
	/**
	 * RegExp to match domain-value in RFC 6265 sec 4.1.1
	 *
	 * domain-value      = <subdomain>
	 *                     ; defined in [RFC1034], Section 3.5, as
	 *                     ; enhanced by [RFC1123], Section 2.1
	 * <subdomain>       = <label> | <subdomain> "." <label>
	 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
	 *                     Labels must be 63 characters or less.
	 *                     'let-dig' not 'letter' in the first char, per RFC1123
	 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	 * <let-dig-hyp>     = <let-dig> | "-"
	 * <let-dig>         = <letter> | <digit>
	 * <letter>          = any one of the 52 alphabetic characters A through Z in
	 *                     upper case and a through z in lower case
	 * <digit>           = any one of the ten digits 0 through 9
	 *
	 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
	 *
	 * > (Note that a leading %x2E ("."), if present, is ignored even though that
	 * character is not permitted, but a trailing %x2E ("."), if present, will
	 * cause the user agent to ignore the attribute.)
	 */
	const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
	/**
	 * RegExp to match path-value in RFC 6265 sec 4.1.1
	 *
	 * path-value        = <any CHAR except CTLs or ";">
	 * CHAR              = %x01-7F
	 *                     ; defined in RFC 5234 appendix B.1
	 */
	const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
	const __toString = Object.prototype.toString;
	const NullObject = /* @__PURE__ */(() => {
	  const C = function () {};
	  C.prototype = Object.create(null);
	  return C;
	})();
	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 */
	function parse(str, options) {
	  const obj = new NullObject();
	  const len = str.length;
	  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
	  if (len < 2) return obj;
	  const dec = options?.decode || decode;
	  let index = 0;
	  do {
	    const eqIdx = str.indexOf("=", index);
	    if (eqIdx === -1) break; // No more cookie pairs.
	    const colonIdx = str.indexOf(";", index);
	    const endIdx = colonIdx === -1 ? len : colonIdx;
	    if (eqIdx > endIdx) {
	      // backtrack on prior semicolon
	      index = str.lastIndexOf(";", eqIdx - 1) + 1;
	      continue;
	    }
	    const keyStartIdx = startIndex(str, index, eqIdx);
	    const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
	    const key = str.slice(keyStartIdx, keyEndIdx);
	    // only assign once
	    if (obj[key] === undefined) {
	      let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
	      let valEndIdx = endIndex(str, endIdx, valStartIdx);
	      const value = dec(str.slice(valStartIdx, valEndIdx));
	      obj[key] = value;
	    }
	    index = endIdx + 1;
	  } while (index < len);
	  return obj;
	}
	function startIndex(str, index, max) {
	  do {
	    const code = str.charCodeAt(index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
	  } while (++index < max);
	  return max;
	}
	function endIndex(str, index, min) {
	  while (index > min) {
	    const code = str.charCodeAt(--index);
	    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
	  }
	  return min;
	}
	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize a name value pair into a cookie string suitable for
	 * http headers. An optional options object specifies cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 */
	function serialize(name, val, options) {
	  const enc = options?.encode || encodeURIComponent;
	  if (!cookieNameRegExp.test(name)) {
	    throw new TypeError(`argument name is invalid: ${name}`);
	  }
	  const value = enc(val);
	  if (!cookieValueRegExp.test(value)) {
	    throw new TypeError(`argument val is invalid: ${val}`);
	  }
	  let str = name + "=" + value;
	  if (!options) return str;
	  if (options.maxAge !== undefined) {
	    if (!Number.isInteger(options.maxAge)) {
	      throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
	    }
	    str += "; Max-Age=" + options.maxAge;
	  }
	  if (options.domain) {
	    if (!domainValueRegExp.test(options.domain)) {
	      throw new TypeError(`option domain is invalid: ${options.domain}`);
	    }
	    str += "; Domain=" + options.domain;
	  }
	  if (options.path) {
	    if (!pathValueRegExp.test(options.path)) {
	      throw new TypeError(`option path is invalid: ${options.path}`);
	    }
	    str += "; Path=" + options.path;
	  }
	  if (options.expires) {
	    if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
	      throw new TypeError(`option expires is invalid: ${options.expires}`);
	    }
	    str += "; Expires=" + options.expires.toUTCString();
	  }
	  if (options.httpOnly) {
	    str += "; HttpOnly";
	  }
	  if (options.secure) {
	    str += "; Secure";
	  }
	  if (options.partitioned) {
	    str += "; Partitioned";
	  }
	  if (options.priority) {
	    const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
	    switch (priority) {
	      case "low":
	        str += "; Priority=Low";
	        break;
	      case "medium":
	        str += "; Priority=Medium";
	        break;
	      case "high":
	        str += "; Priority=High";
	        break;
	      default:
	        throw new TypeError(`option priority is invalid: ${options.priority}`);
	    }
	  }
	  if (options.sameSite) {
	    const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
	    switch (sameSite) {
	      case true:
	      case "strict":
	        str += "; SameSite=Strict";
	        break;
	      case "lax":
	        str += "; SameSite=Lax";
	        break;
	      case "none":
	        str += "; SameSite=None";
	        break;
	      default:
	        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
	    }
	  }
	  return str;
	}
	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 */
	function decode(str) {
	  if (str.indexOf("%") === -1) return str;
	  try {
	    return decodeURIComponent(str);
	  } catch (e) {
	    return str;
	  }
	}
	/**
	 * Determine if value is a Date.
	 */
	function isDate(val) {
	  return __toString.call(val) === "[object Date]";
	}
	return dist;
}

requireDist();

/**
 * react-router v7.6.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var PopStateEventType = "popstate";
function createHashHistory(options = {}) {
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substring(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base");
    let href2 = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href2 + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...(typeof to === "string" ? parsePath(to) : to),
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = "POP" /* Pop */;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({
      ...globalHistory.state,
      idx: index
    }, "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = "POP" /* Pop */;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = "PUSH" /* Push */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = "REPLACE" /* Replace */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    return createBrowserURLImpl(to);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
function createBrowserURLImpl(to, isAbsolute = false) {
  let base = "http://localhost";
  if (typeof window !== "undefined") {
    base = window.location.origin !== "null" ? window.location.origin : window.location.href;
  }
  invariant(base, "No window.location.(origin|href) available to create URL");
  let href2 = typeof to === "string" ? to : createPath(to);
  href2 = href2.replace(/ $/, "%20");
  if (!isAbsolute && href2.startsWith("//")) {
    href2 = base + href2;
  }
  return new URL(href2, base);
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded, allowPartial);
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path "${path}".`);
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo2, {
    paramName,
    isOptional
  }, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`);
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(path)}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = {
      ...toArg
    };
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

// lib/router/router.ts
var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"];
new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["GET", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
var DataRouterContext = /*#__PURE__*/reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = /*#__PURE__*/reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = /*#__PURE__*/reactExports.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = /*#__PURE__*/reactExports.createContext(/* @__PURE__ */new Map());
FetchersContext.displayName = "Fetchers";
var AwaitContext = /*#__PURE__*/reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = /*#__PURE__*/reactExports.createContext(null);
NavigationContext.displayName = "Navigation";
var LocationContext = /*#__PURE__*/reactExports.createContext(null);
LocationContext.displayName = "Location";
var RouteContext = /*#__PURE__*/reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = /*#__PURE__*/reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, {
  relative
} = {}) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useHref() may be used only in the context of a <Router> component.`);
  let {
    basename,
    navigator
  } = reactExports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useLocation() may be used only in the context of a <Router> component.`);
  return reactExports.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useNavigate() may be used only in the context of a <Router> component.`);
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback((to, options = {}) => {
    warning(activeRef.current, navigateEffectWarning);
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
var OutletContext = /*#__PURE__*/reactExports.createContext(null);
function useOutlet(context) {
  let outlet = reactExports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */reactExports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to, {
  relative
} = {}) {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useRoutes() may be used only in the context of a <Router> component.`);
  let {
    navigator
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`);
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`);
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  {
    warning(parentRoute || matches != null, `No routes matched location "${location.pathname}${location.search}${location.hash}" `);
    warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
  }
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */reactExports.createElement(LocationContext.Provider, {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...location
        },
        navigationType: "POP" /* Pop */
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  {
    console.error("Error handled by React Router default ErrorBoundary:", error);
    devInfo = /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */reactExports.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */reactExports.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " or", " ", /* @__PURE__ */reactExports.createElement("code", {
      style: codeStyles
    }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */reactExports.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function RenderedRoute({
  routeContext,
  match,
  children
}) {
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && errors?.[m.route.id] !== void 0);
    invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(",")}`);
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique "id"`);
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId("useRouteId" /* UseRouteId */);
}
function useRouteError() {
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState("useRouteError" /* UseRouteError */);
  let routeId = useCurrentRouteId("useRouteError" /* UseRouteError */);
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext("useNavigate" /* UseNavigateStable */);
  let id = useCurrentRouteId("useNavigate" /* UseNavigateStable */);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(async (to, options = {}) => {
    warning(activeRef.current, navigateEffectWarning);
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      await router.navigate(to, {
        fromRouteId: id,
        ...options
      });
    }
  }, [router, id]);
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP" /* Pop */,
  navigator,
  static: staticProp = false
}) {
  invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator,
    static: staticProp,
    future: {}
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(locationContext != null, `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    invariant(element.type === Route, `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);
    invariant(!element.props.index || !element.props.children, "An index route cannot have child routes.");
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

// lib/dom/dom.ts
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(document.createElement("form"),
      // @ts-expect-error if FormData supports the submitter parameter, this will throw
      0);
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(false, `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`);
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(`Cannot submit a <button> or <input type="submit"> without a <form>`);
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}

// lib/dom/ssr/invariant.ts
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// lib/dom/ssr/routeModules.ts
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(/* @vite-ignore */
    /* webpackIgnore: true */
    route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(`Error loading route module \`${route.module}\`, reloading page...`);
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode &&
    // @ts-expect-error
    import.meta.hot) {
      throw error;
    }
    window.location.reload();
    return new Promise(() => {});
  }
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(matches.map(async match => {
    let route = manifest.routes[match.route.id];
    if (route) {
      let mod = await loadRouteModule(route, routeModules);
      return mod.links ? mod.links() : [];
    }
    return [];
  }));
  return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === "stylesheet" || link.rel === "preload").map(link => link.rel === "stylesheet" ? {
    ...link,
    rel: "prefetch",
    as: "style"
  } : {
    ...link,
    rel: "prefetch"
  }));
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname ||
      // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter((match, index) => isNew(match, index) || matchPathChanged(match, index));
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, {
  includeHydrateFallback
} = {}) {
  return dedupeHrefs(matches.map(match => {
    let route = manifest.routes[match.route.id];
    if (!route) return [];
    let hrefs = [route.module];
    if (route.clientActionModule) {
      hrefs = hrefs.concat(route.clientActionModule);
    }
    if (route.clientLoaderModule) {
      hrefs = hrefs.concat(route.clientLoaderModule);
    }
    if (includeHydrateFallback && route.hydrateFallbackModule) {
      hrefs = hrefs.concat(route.hydrateFallbackModule);
    }
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({
        key,
        link: descriptor
      });
    }
    return deduped;
  }, []);
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var NO_BODY_STATUS_CODES = /* @__PURE__ */new Set([100, 101, 204, 205]);
function singleFetchUrl(reqUrl, basename) {
  let url = typeof reqUrl === "string" ? new URL(reqUrl,
  // This can be called during the SSR flow via PrefetchPageLinksImpl so
  // don't assume window is available
  typeof window === "undefined" ? "server://singlefetch/" : window.location.origin) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}

// lib/dom/ssr/components.tsx
function useDataRouterContext2() {
  let context = reactExports.useContext(DataRouterContext);
  invariant2(context, "You must render this element inside a <DataRouterContext.Provider> element");
  return context;
}
function useDataRouterStateContext() {
  let context = reactExports.useContext(DataRouterStateContext);
  invariant2(context, "You must render this element inside a <DataRouterStateContext.Provider> element");
  return context;
}
var FrameworkContext = /*#__PURE__*/reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = reactExports.useContext(FrameworkContext);
  invariant2(context, "You must render this element inside a <HydratedRouter> element");
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = reactExports.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  let ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = entries => {
        entries.forEach(entry => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, {
        threshold: 0.5
      });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  reactExports.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [shouldPrefetch, ref, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return event => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let {
    router
  } = useDataRouterContext2();
  let matches = reactExports.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */reactExports.createElement(PrefetchPageLinksImpl, {
    page,
    matches,
    ...dataLinkProps
  });
}
function useKeyedPrefetchLinks(matches) {
  let {
    manifest,
    routeModules
  } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {
      if (!interrupted) {
        setKeyedPrefetchLinks(links);
      }
    });
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let {
    manifest,
    routeModules
  } = useFrameworkContext();
  let {
    basename
  } = useDataRouterContext2();
  let {
    loaderData,
    matches
  } = useDataRouterStateContext();
  let newMatchesForData = reactExports.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]);
  let newMatchesForAssets = reactExports.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]);
  let dataHrefs = reactExports.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach(m => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some(m2 => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set("_routes", nextMatches.filter(m => routesParams.has(m.route.id)).map(m => m.route.id).join(","));
    }
    return [url.pathname + url.search];
  }, [basename, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]);
  let moduleHrefs = reactExports.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, dataHrefs.map(href2 => /* @__PURE__ */reactExports.createElement("link", {
    key: href2,
    rel: "prefetch",
    as: "fetch",
    href: href2,
    ...linkProps
  })), moduleHrefs.map(href2 => /* @__PURE__ */reactExports.createElement("link", {
    key: href2,
    rel: "modulepreload",
    href: href2,
    ...linkProps
  })), keyedPrefetchLinks.map(({
    key,
    link
  }) =>
  // these don't spread `linkProps` because they are full link descriptors
  // already with their own props
  /* @__PURE__ */
  reactExports.createElement("link", {
    key,
    ...link
  })));
}
function mergeRefs(...refs) {
  return value => {
    refs.forEach(ref => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

// lib/dom/lib.tsx
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = "7.6.1";
  }
} catch (e) {}
function HashRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let setState = reactExports.useCallback(newState => {
    reactExports.startTransition(() => setStateImpl(newState));
  }, [setStateImpl]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link$1 = /*#__PURE__*/reactExports.forwardRef(function LinkWithRef({
  onClick,
  discover = "render",
  prefetch = "none",
  relative,
  reloadDocument,
  replace: replace2,
  state,
  target,
  to,
  preventScrollReset,
  viewTransition,
  ...rest
}, forwardedRef) {
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && isAbsolute) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
        warning(false, `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);
      }
    }
  }
  let href2 = useHref(to, {
    relative
  });
  let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  let link =
  // eslint-disable-next-line jsx-a11y/anchor-has-content
  /* @__PURE__ */
  reactExports.createElement("a", {
    ...rest,
    ...prefetchHandlers,
    href: absoluteHref || href2,
    onClick: isExternal || reloadDocument ? onClick : handleClick,
    ref: mergeRefs(forwardedRef, prefetchRef),
    target,
    "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
  });
  return shouldPrefetch && !isAbsolute ? /* @__PURE__ */reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */reactExports.createElement(PrefetchPageLinks, {
    page: href2
  })) : link;
});
Link$1.displayName = "Link";
var NavLink = /*#__PURE__*/reactExports.forwardRef(function NavLinkWithRef({
  "aria-current": ariaCurrentProp = "page",
  caseSensitive = false,
  className: classNameProp = "",
  end = false,
  style: styleProp,
  to,
  viewTransition,
  children,
  ...rest
}, ref) {
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let {
    navigator,
    basename
  } = reactExports.useContext(NavigationContext);
  let isTransitioning = routerState != null &&
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && viewTransition === true;
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /* @__PURE__ */reactExports.createElement(Link$1, {
    ...rest,
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to,
    viewTransition
  }, typeof children === "function" ? children(renderProps) : children);
});
NavLink.displayName = "NavLink";
var Form = /*#__PURE__*/reactExports.forwardRef(({
  discover = "render",
  fetcherKey,
  navigate,
  reloadDocument,
  replace: replace2,
  state,
  method = defaultMethod,
  action,
  onSubmit,
  relative,
  preventScrollReset,
  viewTransition,
  ...props
}, forwardedRef) => {
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = submitter?.getAttribute("formmethod") || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace: replace2,
      state,
      relative,
      preventScrollReset,
      viewTransition
    });
  };
  return /* @__PURE__ */reactExports.createElement("form", {
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler,
    ...props,
    "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
  });
});
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let {
    router
  } = useDataRouterContext3("useSubmit" /* UseSubmit */);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return reactExports.useCallback(async (target, options = {}) => {
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === false) {
      let key = options.fetcherKey || getUniqueFetcherId();
      await router.fetch(key, currentRouteId, options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        flushSync: options.flushSync
      });
    } else {
      await router.navigate(options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        flushSync: options.flushSync,
        viewTransition: options.viewTransition
      });
    }
  }, [router, basename, currentRouteId]);
}
function useFormAction(action, {
  relative
} = {}) {
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = {
    ...useResolvedPath(action ? action : ".", {
      relative
    })
  };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some(v => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter(v => v).forEach(v => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = reactExports.useContext(ViewTransitionContext);
  invariant(vtContext != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
  let {
    basename
  } = useDataRouterContext3("useViewTransitionState" /* useViewTransitionState */);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// lib/server-runtime/single-fetch.ts
/* @__PURE__ */new Set([...NO_BODY_STATUS_CODES, 304]);

var reactDom = {exports: {}};

var reactDom_production = {};

/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactDom_production;

function requireReactDom_production () {
	if (hasRequiredReactDom_production) return reactDom_production;
	hasRequiredReactDom_production = 1;

	var React = requireReact();
	function formatProdErrorMessage(code) {
	  var url = "https://react.dev/errors/" + code;
	  if (1 < arguments.length) {
	    url += "?args[]=" + encodeURIComponent(arguments[1]);
	    for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
	  }
	  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function noop() {}
	var Internals = {
	    d: {
	      f: noop,
	      r: function () {
	        throw Error(formatProdErrorMessage(522));
	      },
	      D: noop,
	      C: noop,
	      L: noop,
	      m: noop,
	      X: noop,
	      S: noop,
	      M: noop
	    },
	    p: 0,
	    findDOMNode: null
	  },
	  REACT_PORTAL_TYPE = Symbol.for("react.portal");
	function createPortal$1(children, containerInfo, implementation) {
	  var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
	  return {
	    $$typeof: REACT_PORTAL_TYPE,
	    key: null == key ? null : "" + key,
	    children: children,
	    containerInfo: containerInfo,
	    implementation: implementation
	  };
	}
	var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	function getCrossOriginStringAs(as, input) {
	  if ("font" === as) return "";
	  if ("string" === typeof input) return "use-credentials" === input ? input : "";
	}
	reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
	reactDom_production.createPortal = function (children, container) {
	  var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
	  if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error(formatProdErrorMessage(299));
	  return createPortal$1(children, container, null, key);
	};
	reactDom_production.flushSync = function (fn) {
	  var previousTransition = ReactSharedInternals.T,
	    previousUpdatePriority = Internals.p;
	  try {
	    if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
	  } finally {
	    ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
	  }
	};
	reactDom_production.preconnect = function (href, options) {
	  "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
	};
	reactDom_production.prefetchDNS = function (href) {
	  "string" === typeof href && Internals.d.D(href);
	};
	reactDom_production.preinit = function (href, options) {
	  if ("string" === typeof href && options && "string" === typeof options.as) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
	      integrity = "string" === typeof options.integrity ? options.integrity : void 0,
	      fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
	    "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
	      crossOrigin: crossOrigin,
	      integrity: integrity,
	      fetchPriority: fetchPriority
	    }) : "script" === as && Internals.d.X(href, {
	      crossOrigin: crossOrigin,
	      integrity: integrity,
	      fetchPriority: fetchPriority,
	      nonce: "string" === typeof options.nonce ? options.nonce : void 0
	    });
	  }
	};
	reactDom_production.preinitModule = function (href, options) {
	  if ("string" === typeof href) if ("object" === typeof options && null !== options) {
	    if (null == options.as || "script" === options.as) {
	      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
	      Internals.d.M(href, {
	        crossOrigin: crossOrigin,
	        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
	        nonce: "string" === typeof options.nonce ? options.nonce : void 0
	      });
	    }
	  } else null == options && Internals.d.M(href);
	};
	reactDom_production.preload = function (href, options) {
	  if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
	    Internals.d.L(href, as, {
	      crossOrigin: crossOrigin,
	      integrity: "string" === typeof options.integrity ? options.integrity : void 0,
	      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
	      type: "string" === typeof options.type ? options.type : void 0,
	      fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
	      referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
	      imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
	      imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
	      media: "string" === typeof options.media ? options.media : void 0
	    });
	  }
	};
	reactDom_production.preloadModule = function (href, options) {
	  if ("string" === typeof href) if (options) {
	    var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
	    Internals.d.m(href, {
	      as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
	      crossOrigin: crossOrigin,
	      integrity: "string" === typeof options.integrity ? options.integrity : void 0
	    });
	  } else Internals.d.m(href);
	};
	reactDom_production.requestFormReset = function (form) {
	  Internals.d.r(form);
	};
	reactDom_production.unstable_batchedUpdates = function (fn, a) {
	  return fn(a);
	};
	reactDom_production.useFormState = function (action, initialState, permalink) {
	  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
	};
	reactDom_production.useFormStatus = function () {
	  return ReactSharedInternals.H.useHostTransitionStatus();
	};
	reactDom_production.version = "19.2.1";
	return reactDom_production;
}

var hasRequiredReactDom;

function requireReactDom () {
	if (hasRequiredReactDom) return reactDom.exports;
	hasRequiredReactDom = 1;

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}
	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  reactDom.exports = requireReactDom_production();
	}
	return reactDom.exports;
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  return unsafeStringify(rnds);
}
const VERSION = 'current';
function assertConnection(falcon) {
  if (!falcon.isConnected) {
    throw new Error('You cannot call this API before having established a connection to the host!');
  }
}
function isValidResponse(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
event) {
  return !!event?.data?.meta?.messageId;
}
const CONNECTION_TIMEOUT = 5_000;
const API_TIMEOUT = 30_000;
const NAVIGATION_TIMEOUT = 5_000;
function timeoutForMessage(message) {
  const timeout = message.type === 'connect' ? CONNECTION_TIMEOUT : message.type === 'api' ? API_TIMEOUT : message.type === 'navigateTo' ? NAVIGATION_TIMEOUT :
  // Requests not explicitly covered above will not have a timeout. This includes 'fileUpload', which is a user interaction that can take any amount of time.
  null;
  // In tests we have mocked responses which do not require long timeouts
  return timeout;
}
class Bridge {
  onDataUpdate;
  onBroadcast;
  onLivereload;
  pendingMessages = new Map();
  targetOrigin = '*';
  constructor({
    onDataUpdate,
    onBroadcast,
    onLivereload
  } = {}) {
    this.onDataUpdate = onDataUpdate;
    this.onBroadcast = onBroadcast;
    this.onLivereload = onLivereload;
    window.addEventListener('message', this.handleMessageWrapper);
  }
  destroy() {
    window.removeEventListener('message', this.handleMessageWrapper);
  }
  setOrigin(origin) {
    this.targetOrigin = origin;
  }
  sendUnidirectionalMessage(message) {
    const messageId = v4();
    const eventData = {
      message,
      meta: {
        messageId,
        version: VERSION
      }
    };
    window.parent.postMessage(eventData, this.targetOrigin);
  }
  async postMessage(message) {
    return new Promise((resolve, reject) => {
      const messageId = v4();
      let timeoutTimer;
      const timeoutValue = timeoutForMessage(message);
      if (timeoutValue !== null) {
        timeoutTimer = setTimeout(() => {
          reject(new Error(`Waiting for response from foundry host for "${message.type}" message (ID: ${messageId}) timed out after ${timeoutValue}ms`));
        }, timeoutValue);
      }
      this.pendingMessages.set(messageId, result => {
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        resolve(result);
      });
      const eventData = {
        message,
        meta: {
          messageId,
          version: VERSION
        }
      };
      window.parent.postMessage(eventData, this.targetOrigin);
    });
  }
  handleMessageWrapper = event => {
    return this.handleMessage(event);
  };
  handleMessage = event => {
    if (!isValidResponse(event)) {
      return;
    }
    const {
      message
    } = event.data;
    if (message.type === 'data') {
      this.onDataUpdate?.(message);
      // data update events are unidirectional and originated from the host, so there cannot be a callback waiting for this message
      return;
    }
    if (message.type === 'broadcast') {
      this.onBroadcast?.(message);
      // data update events are unidirectional and are proxied via the host, so there cannot be a callback waiting for this message
      return;
    }
    if (message.type === 'livereload') {
      this.onLivereload?.(message);
      // livereload events are unidirectional and are proxied via the host, so there cannot be a callback waiting for this message
      return;
    }
    const {
      messageId
    } = event.data.meta;
    const callback = this.pendingMessages.get(messageId);
    if (!callback) {
      this.throwError(`Received unexpected message`);
      return;
    }
    this.pendingMessages.delete(messageId);
    callback(message.payload);
  };
  throwError(message) {
    throw new Error(message);
  }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
const anyMap = new WeakMap();
const eventsMap = new WeakMap();
const producersMap = new WeakMap();
const anyProducer = Symbol('anyProducer');
const resolvedPromise = Promise.resolve();

// Define symbols for "meta" events.
const listenerAdded = Symbol('listenerAdded');
const listenerRemoved = Symbol('listenerRemoved');
let canEmitMetaEvents = false;
let isGlobalDebugEnabled = false;
const isEventKeyType = key => typeof key === 'string' || typeof key === 'symbol' || typeof key === 'number';
function assertEventName(eventName) {
  if (!isEventKeyType(eventName)) {
    throw new TypeError('`eventName` must be a string, symbol, or number');
  }
}
function assertListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('listener must be a function');
  }
}
function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);
  if (!events.has(eventName)) {
    return;
  }
  return events.get(eventName);
}
function getEventProducers(instance, eventName) {
  const key = isEventKeyType(eventName) ? eventName : anyProducer;
  const producers = producersMap.get(instance);
  if (!producers.has(key)) {
    return;
  }
  return producers.get(key);
}
function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);
  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }
  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);
    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}
function iterator(instance, eventNames) {
  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
  let isFinished = false;
  let flush = () => {};
  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },
    finish() {
      isFinished = true;
      flush();
    }
  };
  for (const eventName of eventNames) {
    let set = getEventProducers(instance, eventName);
    if (!set) {
      set = new Set();
      const producers = producersMap.get(instance);
      producers.set(eventName, set);
    }
    set.add(producer);
  }
  return {
    async next() {
      if (!queue) {
        return {
          done: true
        };
      }
      if (queue.length === 0) {
        if (isFinished) {
          queue = undefined;
          return this.next();
        }
        await new Promise(resolve => {
          flush = resolve;
        });
        return this.next();
      }
      return {
        done: false,
        value: await queue.shift()
      };
    },
    async return(value) {
      queue = undefined;
      for (const eventName of eventNames) {
        const set = getEventProducers(instance, eventName);
        if (set) {
          set.delete(producer);
          if (set.size === 0) {
            const producers = producersMap.get(instance);
            producers.delete(eventName);
          }
        }
      }
      flush();
      return arguments.length > 0 ? {
        done: true,
        value: await value
      } : {
        done: true
      };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === undefined) {
    return allEmitteryMethods;
  }
  if (!Array.isArray(methodNames)) {
    throw new TypeError('`methodNames` must be an array of strings');
  }
  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== 'string') {
        throw new TypeError('`methodNames` element must be a string');
      }
      throw new Error(`${methodName} is not Emittery method`);
    }
  }
  return methodNames;
}
const isMetaEvent = eventName => eventName === listenerAdded || eventName === listenerRemoved;
function emitMetaEvent(emitter, eventName, eventData) {
  if (isMetaEvent(eventName)) {
    try {
      canEmitMetaEvents = true;
      emitter.emit(eventName, eventData);
    } finally {
      canEmitMetaEvents = false;
    }
  }
}
class Emittery {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return target => {
      if (typeof target !== 'function') {
        throw new TypeError('`target` must be function');
      }
      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== undefined) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }
      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new Emittery()
        });
        return this[emitteryPropertyName];
      }
      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });
      const emitteryMethodCaller = methodName => function (...args) {
        return this[emitteryPropertyName][methodName](...args);
      };
      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }
      return target;
    };
  }
  static get isDebugEnabled() {
    // In a browser environment, `globalThis.process` can potentially reference a DOM Element with a `#process` ID,
    // so instead of just type checking `globalThis.process`, we need to make sure that `globalThis.process.env` exists.
    // eslint-disable-next-line n/prefer-global/process
    if (typeof globalThis.process?.env !== 'object') {
      return isGlobalDebugEnabled;
    }

    // eslint-disable-next-line n/prefer-global/process
    const {
      env
    } = globalThis.process ?? {
      env: {}
    };
    return env.DEBUG === 'emittery' || env.DEBUG === '*' || isGlobalDebugEnabled;
  }
  static set isDebugEnabled(newValue) {
    isGlobalDebugEnabled = newValue;
  }
  constructor(options = {}) {
    anyMap.set(this, new Set());
    eventsMap.set(this, new Map());
    producersMap.set(this, new Map());
    producersMap.get(this).set(anyProducer, new Set());
    this.debug = options.debug ?? {};
    if (this.debug.enabled === undefined) {
      this.debug.enabled = false;
    }
    if (!this.debug.logger) {
      this.debug.logger = (type, debugName, eventName, eventData) => {
        try {
          // TODO: Use https://github.com/sindresorhus/safe-stringify when the package is more mature. Just copy-paste the code.
          eventData = JSON.stringify(eventData);
        } catch {
          eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(',')}`;
        }
        if (typeof eventName === 'symbol' || typeof eventName === 'number') {
          eventName = eventName.toString();
        }
        const currentTime = new Date();
        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
        console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}\n\tdata: ${eventData}`);
      };
    }
  }
  logIfDebugEnabled(type, eventName, eventData) {
    if (Emittery.isDebugEnabled || this.debug.enabled) {
      this.debug.logger(type, this.debug.name, eventName, eventData);
    }
  }
  on(eventNames, listener) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      let set = getListeners(this, eventName);
      if (!set) {
        set = new Set();
        const events = eventsMap.get(this);
        events.set(eventName, set);
      }
      set.add(listener);
      this.logIfDebugEnabled('subscribe', eventName, undefined);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerAdded, {
          eventName,
          listener
        });
      }
    }
    return this.off.bind(this, eventNames, listener);
  }
  off(eventNames, listener) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      const set = getListeners(this, eventName);
      if (set) {
        set.delete(listener);
        if (set.size === 0) {
          const events = eventsMap.get(this);
          events.delete(eventName);
        }
      }
      this.logIfDebugEnabled('unsubscribe', eventName, undefined);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerRemoved, {
          eventName,
          listener
        });
      }
    }
  }
  once(eventNames) {
    let off_;
    const promise = new Promise(resolve => {
      off_ = this.on(eventNames, data => {
        off_();
        resolve(data);
      });
    });
    promise.off = off_;
    return promise;
  }
  events(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
    }
    return iterator(this, eventNames);
  }
  async emit(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError('`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`');
    }
    this.logIfDebugEnabled('emit', eventName, eventData);
    enqueueProducers(this, eventName, eventData);
    const listeners = getListeners(this, eventName) ?? new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    await Promise.all([...staticListeners.map(async listener => {
      if (listeners.has(listener)) {
        return listener(eventData);
      }
    }), ...staticAnyListeners.map(async listener => {
      if (anyListeners.has(listener)) {
        return listener(eventName, eventData);
      }
    })]);
  }
  async emitSerial(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError('`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`');
    }
    this.logIfDebugEnabled('emitSerial', eventName, eventData);
    const listeners = getListeners(this, eventName) ?? new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    /* eslint-disable no-await-in-loop */
    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }
    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
    /* eslint-enable no-await-in-loop */
  }
  onAny(listener) {
    assertListener(listener);
    this.logIfDebugEnabled('subscribeAny', undefined, undefined);
    anyMap.get(this).add(listener);
    emitMetaEvent(this, listenerAdded, {
      listener
    });
    return this.offAny.bind(this, listener);
  }
  anyEvent() {
    return iterator(this);
  }
  offAny(listener) {
    assertListener(listener);
    this.logIfDebugEnabled('unsubscribeAny', undefined, undefined);
    emitMetaEvent(this, listenerRemoved, {
      listener
    });
    anyMap.get(this).delete(listener);
  }
  clearListeners(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      this.logIfDebugEnabled('clear', eventName, undefined);
      if (isEventKeyType(eventName)) {
        const set = getListeners(this, eventName);
        if (set) {
          set.clear();
        }
        const producers = getEventProducers(this, eventName);
        if (producers) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      } else {
        anyMap.get(this).clear();
        for (const [eventName, listeners] of eventsMap.get(this).entries()) {
          listeners.clear();
          eventsMap.get(this).delete(eventName);
        }
        for (const [eventName, producers] of producersMap.get(this).entries()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
          producersMap.get(this).delete(eventName);
        }
      }
    }
  }
  listenerCount(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let count = 0;
    for (const eventName of eventNames) {
      if (isEventKeyType(eventName)) {
        count += anyMap.get(this).size + (getListeners(this, eventName)?.size ?? 0) + (getEventProducers(this, eventName)?.size ?? 0) + (getEventProducers(this)?.size ?? 0);
        continue;
      }
      if (eventName !== undefined) {
        assertEventName(eventName);
      }
      count += anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count += value.size;
      }
    }
    return count;
  }
  bindMethods(target, methodNames) {
    if (typeof target !== 'object' || target === null) {
      throw new TypeError('`target` must be an object');
    }
    methodNames = defaultMethodNamesOrAssert(methodNames);
    for (const methodName of methodNames) {
      if (target[methodName] !== undefined) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }
      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }
}
const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');
Object.defineProperty(Emittery, 'listenerAdded', {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, 'listenerRemoved', {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});
function Memoize(args) {
  let hashFunction;
  let duration;
  let tags;
  {
    hashFunction = args;
  }
  return (target, propertyKey, descriptor) => {
    if (descriptor.value != null) {
      descriptor.value = getNewFunction(descriptor.value, hashFunction, duration, tags);
    } else if (descriptor.get != null) {
      descriptor.get = getNewFunction(descriptor.get, hashFunction, duration, tags);
    } else {
      throw 'Only put a Memoize() decorator on a method or get accessor.';
    }
  };
}
const clearCacheTagsMap = new Map();
function getNewFunction(originalMethod, hashFunction, duration = 0, tags) {
  const propMapName = Symbol(`__memoized_map__`);
  return function (...args) {
    let returnedValue;
    if (!this.hasOwnProperty(propMapName)) {
      Object.defineProperty(this, propMapName, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: new Map()
      });
    }
    let myMap = this[propMapName];
    if (Array.isArray(tags)) {
      for (const tag of tags) {
        if (clearCacheTagsMap.has(tag)) {
          clearCacheTagsMap.get(tag).push(myMap);
        } else {
          clearCacheTagsMap.set(tag, [myMap]);
        }
      }
    }
    if (hashFunction || args.length > 0 || duration > 0) {
      let hashKey;
      if (hashFunction === true) {
        hashKey = args.map(a => a.toString()).join('!');
      } else if (hashFunction) {
        hashKey = hashFunction.apply(this, args);
      } else {
        hashKey = args[0];
      }
      const timestampKey = `${hashKey}__timestamp`;
      let isExpired = false;
      if (duration > 0) {
        if (!myMap.has(timestampKey)) {
          isExpired = true;
        } else {
          let timestamp = myMap.get(timestampKey);
          isExpired = Date.now() - timestamp > duration;
        }
      }
      if (myMap.has(hashKey) && !isExpired) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
        if (duration > 0) {
          myMap.set(timestampKey, Date.now());
        }
      }
    } else {
      const hashKey = this;
      if (myMap.has(hashKey)) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(this, args);
        myMap.set(hashKey, returnedValue);
      }
    }
    return returnedValue;
  };
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class AlertsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async deleteEntitiesSuppressedDevicesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'deleteEntitiesSuppressedDevicesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  /**
   * @deprecated This method is deprecated. Use getQueriesAlertsV2 instead.
   */
  async getQueriesAlertsV1(urlParams = {}) {
    console.warn('This method is deprecated. Use getQueriesAlertsV2 instead.');
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'getQueriesAlertsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesAlertsV2(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'getQueriesAlertsV2',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  /**
   * @deprecated This method is deprecated. Use patchCombinedAlertsV3 instead.
   */
  async patchCombinedAlertsV2(postBody, urlParams = {}) {
    console.warn('This method is deprecated. Use patchCombinedAlertsV3 instead.');
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'patchCombinedAlertsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchCombinedAlertsV3(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'patchCombinedAlertsV3',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  /**
   * @deprecated This method is deprecated. Use patchEntitiesAlertsV3 instead.
   */
  async patchEntitiesAlertsV2(postBody, urlParams = {}) {
    console.warn('This method is deprecated. Use patchEntitiesAlertsV3 instead.');
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'patchEntitiesAlertsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesAlertsV3(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'patchEntitiesAlertsV3',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesSuppressedDevicesV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'patchEntitiesSuppressedDevicesV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  /**
   * @deprecated This method is deprecated. Use postAggregatesAlertsV2 instead.
   */
  async postAggregatesAlertsV1(postBody, urlParams = {}) {
    console.warn('This method is deprecated. Use postAggregatesAlertsV2 instead.');
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'postAggregatesAlertsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesAlertsV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'postAggregatesAlertsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  /**
   * @deprecated This method is deprecated. Use postEntitiesAlertsV2 instead.
   */
  async postEntitiesAlertsV1(postBody, urlParams = {}) {
    console.warn('This method is deprecated. Use postEntitiesAlertsV2 instead.');
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'postEntitiesAlertsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesAlertsV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'postEntitiesAlertsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesSuppressedDevicesV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'alerts',
      method: 'postEntitiesSuppressedDevicesV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class CustomobjectsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async deleteV1CollectionsCollectionNameObjectsObjectKey(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'deleteV1CollectionsCollectionNameObjectsObjectKey',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getV1Collections(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'getV1Collections',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getV1CollectionsCollectionNameObjects(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'getV1CollectionsCollectionNameObjects',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getV1CollectionsCollectionNameObjectsObjectKey(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'getV1CollectionsCollectionNameObjectsObjectKey',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getV1CollectionsCollectionNameObjectsObjectKeyMetadata(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'getV1CollectionsCollectionNameObjectsObjectKeyMetadata',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postV1CollectionsCollectionNameObjects(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'postV1CollectionsCollectionNameObjects',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async putV1CollectionsCollectionNameObjectsObjectKey(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'customobjects',
      method: 'putV1CollectionsCollectionNameObjectsObjectKey',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class DetectsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getEntitiesSuppressedDevicesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'getEntitiesSuppressedDevicesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesDetectsV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'patchEntitiesDetectsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchQueriesDetectsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'patchQueriesDetectsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchQueriesDetectsV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'patchQueriesDetectsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesDetectsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'postAggregatesDetectsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesSummariesGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'postEntitiesSummariesGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesSuppressedDevicesV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'detects',
      method: 'postEntitiesSuppressedDevicesV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class DevicesApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async deleteEntitiesGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'deleteEntitiesGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getAggregatesBucketsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getAggregatesBucketsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getAggregatesFgaTagPrefixCountsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getAggregatesFgaTagPrefixCountsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getAggregatesTagPrefixCountsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getAggregatesTagPrefixCountsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesFgaGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getEntitiesFgaGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getEntitiesGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesAvailableGroupsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesAvailableGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesDevicesHiddenV2(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesDevicesHiddenV2',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesDevicesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesDevicesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesDevicesV2(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesDevicesV2',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesFgaGroupsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesFgaGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesGroupsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'getQueriesGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesDevicesTagsV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'patchEntitiesDevicesTagsV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesGroupsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'patchEntitiesGroupsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesDevicesGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postAggregatesDevicesGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesFgaHostsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postAggregatesFgaHostsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postCombinedDevicesLoginHistoryV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postCombinedDevicesLoginHistoryV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postCombinedFgaHostsLoginHistoryV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postCombinedFgaHostsLoginHistoryV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesDevicesActionsV4(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesDevicesActionsV4',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesDevicesHiddenActionsV4(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesDevicesHiddenActionsV4',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesDevicesReportsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesDevicesReportsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesDevicesV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesDevicesV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesFgaHostsReportsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesFgaHostsReportsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesFgaHostsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesFgaHostsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesGroupActionsV1(postBody, urlParams) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesGroupActionsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesGroupsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'devices',
      method: 'postEntitiesGroupsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class FaasGatewayApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getEntitiesExecutionV1(urlParams) {
    const message = {
      type: 'api',
      api: 'faasGateway',
      method: 'getEntitiesExecutionV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesExecutionV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'faasGateway',
      method: 'postEntitiesExecutionV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class FwmgrApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async deleteEntitiesNetworkLocationsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'deleteEntitiesNetworkLocationsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async deleteEntitiesPoliciesV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'deleteEntitiesPoliciesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async deleteEntitiesRuleGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'deleteEntitiesRuleGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesEventsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesEventsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesFirewallFieldsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesFirewallFieldsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesNetworkLocationsDetailsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesNetworkLocationsDetailsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesNetworkLocationsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesNetworkLocationsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesPlatformsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesPlatformsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesPoliciesV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesPoliciesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesRuleGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesRuleGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesRulesV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getEntitiesRulesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getLibraryEntitiesRuleGroupsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getLibraryEntitiesRuleGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getLibraryQueriesRuleGroupsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getLibraryQueriesRuleGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesEventsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesEventsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesFirewallFieldsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesFirewallFieldsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesNetworkLocationsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesNetworkLocationsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesPlatformsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesPlatformsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesPolicyRulesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesPolicyRulesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesRuleGroupsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesRuleGroupsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesRulesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'getQueriesRulesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesNetworkLocationsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'patchEntitiesNetworkLocationsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async patchEntitiesRuleGroupsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'patchEntitiesRuleGroupsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesEventsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postAggregatesEventsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesPolicyRulesGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postAggregatesPolicyRulesGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesRuleGroupsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postAggregatesRuleGroupsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesRulesGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postAggregatesRulesGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesNetworkLocationsMetadataV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesNetworkLocationsMetadataV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesNetworkLocationsPrecedenceV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesNetworkLocationsPrecedenceV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesNetworkLocationsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesNetworkLocationsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesOntologyV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesOntologyV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesRuleGroupsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesRuleGroupsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesRulesValidateFilepathV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'postEntitiesRulesValidateFilepathV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async putEntitiesNetworkLocationsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'putEntitiesNetworkLocationsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async putEntitiesPoliciesV2(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'fwmgr',
      method: 'putEntitiesPoliciesV2',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class IncidentsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getCombinedCrowdscoresV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'getCombinedCrowdscoresV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesBehaviorsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'getQueriesBehaviorsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesIncidentsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'getQueriesIncidentsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesBehaviorsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'postAggregatesBehaviorsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postAggregatesIncidentsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'postAggregatesIncidentsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesBehaviorsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'postEntitiesBehaviorsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesIncidentActionsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'postEntitiesIncidentActionsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesIncidentsGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'incidents',
      method: 'postEntitiesIncidentsGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class LoggingapiApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getEntitiesSavedSearchesExecuteV1(urlParams) {
    const message = {
      type: 'api',
      api: 'loggingapi',
      method: 'getEntitiesSavedSearchesExecuteV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesSavedSearchesV1(urlParams) {
    const message = {
      type: 'api',
      api: 'loggingapi',
      method: 'getEntitiesSavedSearchesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesSavedSearchesExecuteV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'loggingapi',
      method: 'postEntitiesSavedSearchesExecuteV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class MitreApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getIntelMitreEntitiesMatrixV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'mitre',
      method: 'getIntelMitreEntitiesMatrixV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class PluginsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getEntitiesConfigsV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'plugins',
      method: 'getEntitiesConfigsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesDefinitionsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'plugins',
      method: 'getEntitiesDefinitionsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesExecuteDraftV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'plugins',
      method: 'postEntitiesExecuteDraftV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesExecuteV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'plugins',
      method: 'postEntitiesExecuteV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class RemoteResponseApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async deleteEntitiesPutFilesV1(urlParams) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'deleteEntitiesPutFilesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesAppCommandV1(urlParams) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'getEntitiesAppCommandV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getEntitiesPutFilesV2(urlParams) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'getEntitiesPutFilesV2',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async getQueriesPutFilesV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'getQueriesPutFilesV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesAppCommandV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'postEntitiesAppCommandV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesAppSessionsV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'remoteResponse',
      method: 'postEntitiesAppSessionsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class UserManagementApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getQueriesUsersV1(urlParams = {}) {
    const message = {
      type: 'api',
      api: 'userManagement',
      method: 'getQueriesUsersV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesUsersGetV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'userManagement',
      method: 'postEntitiesUsersGetV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class WorkflowsApiBridge {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  getBridge() {
    return this.bridge;
  }
  async getEntitiesExecutionResultsV1(urlParams) {
    const message = {
      type: 'api',
      api: 'workflows',
      method: 'getEntitiesExecutionResultsV1',
      payload: {
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesExecuteV1(postBody, urlParams = {}) {
    const message = {
      type: 'api',
      api: 'workflows',
      method: 'postEntitiesExecuteV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
  async postEntitiesExecutionActionsV1(postBody, urlParams) {
    const message = {
      type: 'api',
      api: 'workflows',
      method: 'postEntitiesExecutionActionsV1',
      payload: {
        body: postBody,
        params: urlParams
      }
    };
    return this.bridge.postMessage(message);
  }
}

/**
 *
 * This file is autogenerated.
 *
 * DO NOT EDIT DIRECTLY
 *
 **/
class FalconPublicApis {
  api;
  constructor(api) {
    this.api = api;
  }
  get alerts() {
    assertConnection(this.api);
    return new AlertsApiBridge(this.api.bridge);
  }
  get detects() {
    assertConnection(this.api);
    return new DetectsApiBridge(this.api.bridge);
  }
  get devices() {
    assertConnection(this.api);
    return new DevicesApiBridge(this.api.bridge);
  }
  get fwmgr() {
    assertConnection(this.api);
    return new FwmgrApiBridge(this.api.bridge);
  }
  get incidents() {
    assertConnection(this.api);
    return new IncidentsApiBridge(this.api.bridge);
  }
  get mitre() {
    assertConnection(this.api);
    return new MitreApiBridge(this.api.bridge);
  }
  /**
   * @internal
   */
  get plugins() {
    assertConnection(this.api);
    return new PluginsApiBridge(this.api.bridge);
  }
  get remoteResponse() {
    assertConnection(this.api);
    return new RemoteResponseApiBridge(this.api.bridge);
  }
  get userManagement() {
    assertConnection(this.api);
    return new UserManagementApiBridge(this.api.bridge);
  }
  get workflows() {
    assertConnection(this.api);
    return new WorkflowsApiBridge(this.api.bridge);
  }
  /**
   * @internal
   */
  get customobjects() {
    assertConnection(this.api);
    return new CustomobjectsApiBridge(this.api.bridge);
  }
  /**
   * @internal
   */
  get faasGateway() {
    assertConnection(this.api);
    return new FaasGatewayApiBridge(this.api.bridge);
  }
  /**
   * @internal
   */
  get loggingapi() {
    assertConnection(this.api);
    return new LoggingapiApiBridge(this.api.bridge);
  }
}
__decorate([Memoize()], FalconPublicApis.prototype, "alerts", null);
__decorate([Memoize()], FalconPublicApis.prototype, "detects", null);
__decorate([Memoize()], FalconPublicApis.prototype, "devices", null);
__decorate([Memoize()], FalconPublicApis.prototype, "fwmgr", null);
__decorate([Memoize()], FalconPublicApis.prototype, "incidents", null);
__decorate([Memoize()], FalconPublicApis.prototype, "mitre", null);
__decorate([Memoize()], FalconPublicApis.prototype, "plugins", null);
__decorate([Memoize()], FalconPublicApis.prototype, "remoteResponse", null);
__decorate([Memoize()], FalconPublicApis.prototype, "userManagement", null);
__decorate([Memoize()], FalconPublicApis.prototype, "workflows", null);
__decorate([Memoize()], FalconPublicApis.prototype, "customobjects", null);
__decorate([Memoize()], FalconPublicApis.prototype, "faasGateway", null);
__decorate([Memoize()], FalconPublicApis.prototype, "loggingapi", null);
class ApiIntegration {
  falcon;
  definition;
  constructor(falcon, definition) {
    this.falcon = falcon;
    this.definition = definition;
  }
  async execute({
    request
  } = {}) {
    return this.falcon.api.plugins.postEntitiesExecuteV1({
      resources: [{
        definition_id: this.definition.definitionId,
        operation_id: this.definition.operationId,
        request
      }]
    });
  }
}
class CloudFunction {
  falcon;
  definition;
  static GET = 'GET';
  static POST = 'POST';
  static PATCH = 'PATCH';
  static PUT = 'PUT';
  static DELETE = 'DELETE';
  /**
   * @internal
   */
  pollTimeout = 500;
  /**
   * @internal
   */
  intervalId;
  /**
   * @internal
   */
  constructor(falcon, definition) {
    this.falcon = falcon;
    this.definition = definition;
  }
  async execute({
    path,
    method,
    body,
    params
  }) {
    const functionDefinition = 'id' in this.definition ? {
      function_id: this.definition.id,
      function_version: this.definition.version
    } : {
      function_name: this.definition.name,
      function_version: this.definition.version
    };
    const result = await this.falcon.api.faasGateway.postEntitiesExecutionV1({
      ...functionDefinition,
      payload: {
        path,
        method,
        body,
        params
      }
    });
    return new Promise((resolve, reject) => {
      const execution = result?.resources?.[0];
      if (!execution?.execution_id) {
        reject(result?.errors);
      } else {
        this.pollForResult({
          resolve,
          reject,
          executionId: execution?.execution_id
        });
      }
    });
  }
  async getExecutionResult(executionId) {
    const resultResponse = await this.falcon.api.faasGateway.getEntitiesExecutionV1({
      id: executionId
    });
    const executionResult = resultResponse?.resources?.[0];
    return executionResult?.payload;
  }
  pollForResult({
    resolve,
    reject,
    executionId
  }) {
    let exceptionRetries = 2;
    this.intervalId = window.setInterval(async () => {
      try {
        const payload = await this.getExecutionResult(executionId);
        if (payload) {
          window.clearInterval(this.intervalId);
          resolve(payload);
        }
      } catch (e) {
        if (exceptionRetries <= 0) {
          window.clearInterval(this.intervalId);
          reject(e);
        }
        exceptionRetries--;
      }
    }, this.pollTimeout);
  }
  path(pathEntry) {
    const urlPath = new URL(pathEntry, 'http://localhost');
    const path = urlPath.pathname;
    const searchParams = [...urlPath.searchParams.entries()].reduce((acc, [key, value]) => ({
      ...acc,
      [key]: [value]
    }), {});
    return {
      path,
      queryParams: searchParams,
      get: async (params = {}) => {
        return this.get({
          path,
          params: {
            query: params?.query ?? searchParams ?? {},
            header: params?.header ?? {}
          }
        });
      },
      post: async (body, params = {}) => {
        return this.post({
          path,
          params: {
            query: params?.query ?? searchParams ?? {},
            header: params?.header ?? {}
          },
          body
        });
      },
      patch: async (body, params = {}) => {
        return this.patch({
          path,
          params: {
            query: params?.query ?? searchParams ?? {},
            header: params?.header ?? {}
          },
          body
        });
      },
      put: async (body, params = {}) => {
        return this.put({
          path,
          params: {
            query: params?.query ?? searchParams ?? {},
            header: params?.header ?? {}
          },
          body
        });
      },
      delete: async (body, params = {}) => {
        return this.delete({
          path,
          params: {
            query: params?.query ?? searchParams ?? {},
            header: params?.header ?? {}
          },
          body
        });
      }
    };
  }
  async get({
    path,
    params
  }) {
    return this.execute({
      path,
      method: CloudFunction.GET,
      params
    });
  }
  async post({
    path,
    params,
    body
  }) {
    return this.execute({
      path,
      method: CloudFunction.POST,
      body,
      params
    });
  }
  async patch({
    path,
    params,
    body
  }) {
    return this.execute({
      path,
      method: CloudFunction.PATCH,
      body,
      params
    });
  }
  async put({
    path,
    params,
    body
  }) {
    return this.execute({
      path,
      method: CloudFunction.PUT,
      body,
      params
    });
  }
  async delete({
    path,
    params,
    body
  }) {
    return this.execute({
      path,
      method: CloudFunction.DELETE,
      body,
      params
    });
  }
  destroy() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
  }
}
class Collection {
  falcon;
  definition;
  constructor(falcon, definition) {
    this.falcon = falcon;
    this.definition = definition;
  }
  /**
   * Write data to the collection
   *
   * @param key
   * @param data
   * @returns
   */
  async write(key, data) {
    return this.falcon.bridge.postMessage({
      type: 'collection',
      payload: {
        type: 'write',
        key,
        collection: this.definition.collection,
        data
      }
    });
  }
  /**
   * Read the data for the given `key`
   *
   * @param key
   * @returns
   */
  async read(key) {
    return this.falcon.bridge.postMessage({
      type: 'collection',
      payload: {
        type: 'read',
        key,
        collection: this.definition.collection
      }
    });
  }
  /**
   * Delete the data for the given `key`
   *
   * @param key
   * @returns
   */
  async delete(key) {
    return this.falcon.bridge.postMessage({
      type: 'collection',
      payload: {
        type: 'delete',
        key,
        collection: this.definition.collection
      }
    });
  }
  /**
   * Search for data
   *
   * @param searchDefinition
   * @returns
   */
  async search({
    filter,
    offset,
    sort,
    limit
  }) {
    return this.falcon.bridge.postMessage({
      type: 'collection',
      payload: {
        type: 'search',
        filter,
        limit,
        offset,
        sort,
        collection: this.definition.collection
      }
    });
  }
  /**
   * lists the object keys in the specified collection
   *
   * @param searchDefinition
   * @returns
   */
  async list(options) {
    return this.falcon.bridge.postMessage({
      type: 'collection',
      payload: {
        type: 'list',
        collection: this.definition.collection,
        start: options?.start,
        end: options?.end,
        limit: options?.limit
      }
    });
  }
}
class Logscale {
  falcon;
  constructor(falcon) {
    this.falcon = falcon;
  }
  /**
   * Write data to LogScale
   *
   * @param data
   * @param properties
   * @returns
   */
  async write(
  // @todo the proper type here is unclear  - we need to make clear how the user needs to call this
  data, properties) {
    return this.falcon.bridge.postMessage({
      type: 'loggingapi',
      payload: {
        type: 'ingest',
        data,
        tag: properties?.tag,
        tagSource: properties?.tagSource,
        testData: properties?.testData
      }
    });
  }
  /**
   * Execute a dynamic query
   *
   * @param query
   * @returns Promise that resolves with the data
   */
  async query(
  // @todo the proper type here is unclear  - we need to make clear how the user needs to call this
  query) {
    return this.falcon.bridge.postMessage({
      type: 'loggingapi',
      payload: {
        type: 'dynamic-execute',
        data: query
      }
    });
  }
  /**
   * Execute a saved query
   *
   * @param savedQuery
   * @returns
   */
  async savedQuery(
  // @todo the proper type here is unclear  - we need to make clear how the user needs to call this
  savedQuery) {
    return this.falcon.bridge.postMessage({
      type: 'loggingapi',
      payload: {
        type: 'saved-query-execute',
        data: savedQuery
      }
    });
  }
}
const ALLOWED_TARGETS = ['_self', '_blank'];
class Navigation {
  falcon;
  constructor(falcon) {
    this.falcon = falcon;
  }
  async navigateTo({
    path,
    type,
    target,
    metaKey,
    ctrlKey,
    shiftKey
  }) {
    await this.falcon.bridge.postMessage({
      type: 'navigateTo',
      payload: {
        path,
        type: type ?? 'falcon',
        target: target ?? '_self',
        metaKey: metaKey ?? false,
        ctrlKey: ctrlKey ?? false,
        shiftKey: shiftKey ?? false
      }
    });
  }
  async onClick(event, defaultTarget = '_self', defaultType = 'falcon') {
    if (!(event instanceof Event)) {
      throw Error('"event" property should be subclass of Event');
    }
    if (!('preventDefault' in event)) {
      return;
    }
    if (!(event.target instanceof HTMLAnchorElement)) {
      return;
    }
    event.preventDefault();
    const path = event.target.getAttribute('href');
    defaultTarget = event.target.getAttribute('target') ?? defaultTarget;
    const type = event.target.dataset?.type ?? defaultType;
    if (defaultTarget === null || !ALLOWED_TARGETS.includes(defaultTarget)) {
      throw new Error('Target should be _self or _blank');
    }
    const target = defaultTarget;
    if (path === undefined || path === null) {
      throw new Error('Navigation path is missing. Make sure you have added navigation.onClick on the `a` tag and `href` is present.');
    }
    const {
      metaKey,
      ctrlKey,
      shiftKey
    } = event;
    await this.navigateTo({
      path,
      type,
      target,
      metaKey,
      ctrlKey,
      shiftKey
    });
  }
}

/**
 * @internal
 */
class ResizeTracker {
  bridge;
  observer;
  constructor(bridge) {
    this.bridge = bridge;
    this.observer = new ResizeObserver(entries => this.handleResizeEvent(entries));
    this.observer.observe(document.body);
  }
  handleResizeEvent(entries) {
    const {
      height
    } = entries[0].contentRect;
    this.bridge.sendUnidirectionalMessage({
      type: 'resize',
      payload: {
        height
      }
    });
  }
  destroy() {
    this.observer.disconnect();
  }
}

/**
 * Invoke UI features within the main Falcon Console.
 */
class UI {
  bridge;
  constructor(bridge) {
    this.bridge = bridge;
  }
  /**
   * Open a modal within the Falcon Console, rendering an UI extension of your choice.
   *
   * ```js
   * const result = await api.ui.openModal({ id: '<extension ID as defined in the manifest>', type: 'extension' }, 'Modal title', {
      path: '/foo',
      data: { foo: 'bar' },
      size: 'lg',
      align: 'top',
    });
    ```
   *
   * @param extension The identifier of the extension, consisting of {@link ExtensionIdentifier.id} and {@link ExtensionIdentifier.type}
   * @param title The title to render in the header of the modal
   * @param options
   * @returns a Promise that resolves with the data passed to {@link closeModal}, or `undefined` if the user dismisses it
   */
  async openModal(extension, title, options = {}) {
    const result = await this.bridge.postMessage({
      type: 'openModal',
      payload: {
        extension,
        title,
        options
      }
    });
    if (result instanceof Error) {
      throw result;
    }
    return result;
  }
  /**
   * Close a modal already opened via {@link openModal}. This can be called both by the extension that is rendered inside the modal or by the extension that opened the modal.
   *
   * @param payload the data to return to the caller that opened the modal as the value of the resolved promise
   */
  closeModal(payload) {
    this.bridge.sendUnidirectionalMessage({
      type: 'closeModal',
      payload
    });
  }
  /**
   * This opens a file upload modal inside the Falcon Console, to support file uploads, even large binary files.
   *
   * @param fileUploadType the type of file upload
   * @param initialData data that you want to pre-populate the form with
   */
  async uploadFile(fileUploadType, initialData) {
    return this.bridge.postMessage({
      type: 'fileUpload',
      fileUploadType,
      payload: initialData
    });
  }
}

/**
 * This is the main class and only entrypoint for engaging with the Falcon APIs from an Foundry UI extension or page.
 *
 * At the very minimum, you would have to instantiate the class and connect to the Falcon Console:
 *
 * ```js
 * import FalconApi from '@crowdstrike/foundry-js';
 *
 * const api = new FalconApi();
 *
 * await api.connect();
 * ```
 *
 */
class FalconApi {
  /**
   * @internal
   */
  isConnected = false;
  /**
   * An event emitter that allows you to subscribe to events issued by the Falcon Console.
   *
   * Currently supported event types:
   * * `data`: fires when {@link data} is updated.
   * * `broadcast`: this event is received when another extension of the same app has send a `broadcast` event via {@link sendBroadcast}.
   *
   * ```js
   * api.events.on('data', (newData) => console.log('new data received:', newData));
   * ```
   */
  events = new Emittery();
  /**
   * The "local data" that your extension receives from the Falcon Console. This can vary depending on the state of the Falcon Console and the socket of the extension.
   *
   * At the very least it will contain the data specified by the {@link LocalData} interface.
   */
  data;
  /**
   * @internal
   */
  bridge = new Bridge({
    onDataUpdate: data => this.handleDataUpdate(data),
    onBroadcast: msg => this.handleBroadcastMessage(msg),
    onLivereload: () => this.handleLivereloadMessage()
  });
  /**
   * Namespace for all the {@link FalconPublicApis | Falcon Cloud APIs} you have access to with this SDK.
   */
  api = new FalconPublicApis(this);
  /**
   * The {@link UI} class contains methods to invoke UI features within the main Falcon Console.
   */
  ui = new UI(this.bridge);
  resizeTracker;
  cloudFunctions = [];
  apiIntegrations = [];
  collections = [];
  /**
   * Connect to the main Falcon Console from within your UI extension.
   *
   * This establishes a connection to send messages between the extension and the Falcon Console. Only when established you will be able to call other APIs.
   */
  async connect() {
    const response = await this.bridge.postMessage({
      type: 'connect'
    });
    if (response !== undefined) {
      const {
        data,
        origin
      } = response;
      this.bridge.setOrigin(origin);
      this.data = data;
      this.updateTheme(data?.theme);
      this.isConnected = true;
    }
    this.resizeTracker = new ResizeTracker(this.bridge);
    return response;
  }
  /**
   * The ID of the Foundry app this UI extension belongs to.
   */
  get appId() {
    return this.data?.app.id;
  }
  /**
   * Sending broadcast messages is a mechanism for allowing communication between different UI extensions, when they are displayed at the same time.
   * When sending a broadcast message, other extensions need to listen for the `broadcast` event on the {@link events} event emitter.
   *
   * Note that broadcast messages are only dispatched between UI extensions of the same app!
   *
   * @param payload the data you want to send to other UI extensions
   */
  sendBroadcast(payload) {
    this.bridge.sendUnidirectionalMessage({
      type: 'broadcast',
      payload
    });
  }
  handleDataUpdate(dataMessage) {
    this.data = dataMessage.payload;
    this.updateTheme(this.data.theme);
    this.events.emit('data', this.data);
  }
  handleBroadcastMessage(message) {
    this.events.emit('broadcast', message.payload);
  }
  handleLivereloadMessage() {
    document.location.reload();
  }
  updateTheme(activeTheme) {
    if (!activeTheme) {
      return;
    }
    const inactiveTheme = activeTheme === 'theme-dark' ? 'theme-light' : 'theme-dark';
    document.documentElement.classList.add(activeTheme);
    document.documentElement.classList.remove(inactiveTheme);
  }
  /**
   * Create a {@link CloudFunction} to integrate with Falcon's "Function as a Service" platform.
   *
   * @param definition
   * @returns
   */
  cloudFunction(definition) {
    assertConnection(this);
    const cf = new CloudFunction(this, definition);
    this.cloudFunctions.push(cf);
    return cf;
  }
  /**
   * Create an {@link ApiIntegration} to call external APIs.
   *
   * @param defintition
   * @returns
   */
  apiIntegration({
    definitionId,
    operationId
  }) {
    assertConnection(this);
    if (!this.data) {
      throw Error('Data from console is missing');
    }
    const apiIntegration = new ApiIntegration(this, {
      operationId,
      definitionId: definitionId
    });
    this.apiIntegrations.push(apiIntegration);
    return apiIntegration;
  }
  /**
   * Create a {@link Collection} to write to and query Falcon's custom storage service.
   *
   * @param definition
   * @returns
   */
  collection({
    collection
  }) {
    assertConnection(this);
    const co = new Collection(this, {
      collection
    });
    this.collections.push(co);
    return co;
  }
  /**
   * The {@link Navigation} class provides functionality to navigate to other pages.
   */
  get navigation() {
    assertConnection(this);
    return new Navigation(this);
  }
  /**
   * The {@link Logscale} class allows you to read and write to your custom LogScale repository.
   */
  get logscale() {
    assertConnection(this);
    return new Logscale(this);
  }
  destroy() {
    this.cloudFunctions.forEach(cf => cf.destroy());
    this.resizeTracker?.destroy();
    this.bridge.destroy();
  }
}
__decorate([Memoize()], FalconApi.prototype, "navigation", null);
__decorate([Memoize()], FalconApi.prototype, "logscale", null);

const FalconApiContext = /*#__PURE__*/reactExports.createContext(null);
function useFalconApiContext() {
  const [isInitialized, setIsInitialized] = reactExports.useState(false);
  const falcon = reactExports.useMemo(() => new FalconApi(), []);
  const navigation = reactExports.useMemo(() => falcon.isConnected ? falcon.navigation : undefined, [falcon.isConnected]);
  reactExports.useEffect(() => {
    (async () => {
      await falcon.connect();
      setIsInitialized(true);
    })();
  }, []);
  return {
    falcon,
    navigation,
    isInitialized
  };
}

function Link({
  children,
  useFalconNavigation = false,
  to
}) {
  const {
    navigation
  } = reactExports.useContext(FalconApiContext);
  if (useFalconNavigation) {
    return /*#__PURE__*/React.createElement("a", {
      onClick: navigation.onClick,
      href: to
    }, children);
  }
  return /*#__PURE__*/React.createElement(Link$1, {
    to: to
  }, children);
}

function Home() {
  const {
    falcon
  } = reactExports.useContext(FalconApiContext);
  const [data, setData] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    async function fetchData() {
      try {
        const apiIntegration = falcon.apiIntegration({
          definitionId: 'JSONPlaceholder',
          operationId: 'GET__posts'
        });
        const response = await apiIntegration.execute();
        setData(response.resources[0].response_body);
        console.log('data', data);
        setLoading(false);
      } catch (error) {
        setError(error);
        setLoading(false);
      }
    }
    fetchData();
  }, []);
  if (loading) {
    return /*#__PURE__*/React.createElement("div", null, "Loading...");
  }
  if (error) {
    return /*#__PURE__*/React.createElement("div", null, "Error: ", error.message);
  }
  return /*#__PURE__*/React.createElement("div", {
    className: "mt-4 space-y-8"
  }, /*#__PURE__*/React.createElement("p", {
    class: "text-neutral"
  }, " \uD83D\uDC4B Hi ", falcon.data.user.username), /*#__PURE__*/React.createElement(Link, {
    useFalconNavigation: true,
    to: "/crowdscore"
  }, "CrowdScore"), /*#__PURE__*/React.createElement("p", null, "Results from JSON Placeholder API:"), /*#__PURE__*/React.createElement("ul", null, data.map(item => /*#__PURE__*/React.createElement("li", {
    key: item.id
  }, item.id, ": ", item.title))));
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4 = globalThis,
  e$b = t$4.ShadowRoot && (void 0 === t$4.ShadyCSS || t$4.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
  s$2 = Symbol(),
  o$c = new WeakMap();
let n$9 = class n {
  constructor(t, e, o) {
    if (this._$cssResult$ = true, o !== s$2) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const s = this.t;
    if (e$b && void 0 === t) {
      const e = void 0 !== s && 1 === s.length;
      e && (t = o$c.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), e && o$c.set(s, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const r$8 = t => new n$9("string" == typeof t ? t : t + "", void 0, s$2),
  i$7 = (t, ...e) => {
    const o = 1 === t.length ? t[0] : e.reduce((e, s, o) => e + (t => {
      if (true === t._$cssResult$) return t.cssText;
      if ("number" == typeof t) return t;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s) + t[o + 1], t[0]);
    return new n$9(o, t, s$2);
  },
  S$1 = (s, o) => {
    if (e$b) s.adoptedStyleSheets = o.map(t => t instanceof CSSStyleSheet ? t : t.styleSheet);else for (const e of o) {
      const o = document.createElement("style"),
        n = t$4.litNonce;
      void 0 !== n && o.setAttribute("nonce", n), o.textContent = e.cssText, s.appendChild(o);
    }
  },
  c$3 = e$b ? t => t : t => t instanceof CSSStyleSheet ? (t => {
    let e = "";
    for (const s of t.cssRules) e += s.cssText;
    return r$8(e);
  })(t) : t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const {
    is: i$6,
    defineProperty: e$a,
    getOwnPropertyDescriptor: r$7,
    getOwnPropertyNames: h$3,
    getOwnPropertySymbols: o$b,
    getPrototypeOf: n$8
  } = Object,
  a$2 = globalThis,
  c$2 = a$2.trustedTypes,
  l$3 = c$2 ? c$2.emptyScript : "",
  p$1 = a$2.reactiveElementPolyfillSupport,
  d$1 = (t, s) => t,
  u$3 = {
    toAttribute(t, s) {
      switch (s) {
        case Boolean:
          t = t ? l$3 : null;
          break;
        case Object:
        case Array:
          t = null == t ? t : JSON.stringify(t);
      }
      return t;
    },
    fromAttribute(t, s) {
      let i = t;
      switch (s) {
        case Boolean:
          i = null !== t;
          break;
        case Number:
          i = null === t ? null : Number(t);
          break;
        case Object:
        case Array:
          try {
            i = JSON.parse(t);
          } catch (t) {
            i = null;
          }
      }
      return i;
    }
  },
  f$3 = (t, s) => !i$6(t, s),
  y$1 = {
    attribute: true,
    type: String,
    converter: u$3,
    reflect: false,
    hasChanged: f$3
  };
Symbol.metadata ??= Symbol("metadata"), a$2.litPropertyMetadata ??= new WeakMap();
class b extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ??= []).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, s = y$1) {
    if (s.state && (s.attribute = false), this._$Ei(), this.elementProperties.set(t, s), !s.noAccessor) {
      const i = Symbol(),
        r = this.getPropertyDescriptor(t, i, s);
      void 0 !== r && e$a(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, s, i) {
    const {
      get: e,
      set: h
    } = r$7(this.prototype, t) ?? {
      get() {
        return this[s];
      },
      set(t) {
        this[s] = t;
      }
    };
    return {
      get() {
        return e?.call(this);
      },
      set(s) {
        const r = e?.call(this);
        h.call(this, s), this.requestUpdate(t, r, i);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? y$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties"))) return;
    const t = n$8(this);
    t.finalize(), void 0 !== t.l && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t = this.properties,
        s = [...h$3(t), ...o$b(t)];
      for (const i of s) this.createProperty(i, t[i]);
    }
    const t = this[Symbol.metadata];
    if (null !== t) {
      const s = litPropertyMetadata.get(t);
      if (void 0 !== s) for (const [t, i] of s) this.elementProperties.set(t, i);
    }
    this._$Eh = new Map();
    for (const [t, s] of this.elementProperties) {
      const i = this._$Eu(t, s);
      void 0 !== i && this._$Eh.set(i, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s) {
    const i = [];
    if (Array.isArray(s)) {
      const e = new Set(s.flat(1 / 0).reverse());
      for (const s of e) i.unshift(c$3(s));
    } else void 0 !== s && i.push(c$3(s));
    return i;
  }
  static _$Eu(t, s) {
    const i = s.attribute;
    return false === i ? void 0 : "string" == typeof i ? i : "string" == typeof t ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(t => this.enableUpdating = t), this._$AL = new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(t => t(this));
  }
  addController(t) {
    (this._$EO ??= new Set()).add(t), void 0 !== this.renderRoot && this.isConnected && t.hostConnected?.();
  }
  removeController(t) {
    this._$EO?.delete(t);
  }
  _$E_() {
    const t = new Map(),
      s = this.constructor.elementProperties;
    for (const i of s.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach(t => t.hostConnected?.());
  }
  enableUpdating(t) {}
  disconnectedCallback() {
    this._$EO?.forEach(t => t.hostDisconnected?.());
  }
  attributeChangedCallback(t, s, i) {
    this._$AK(t, i);
  }
  _$EC(t, s) {
    const i = this.constructor.elementProperties.get(t),
      e = this.constructor._$Eu(t, i);
    if (void 0 !== e && true === i.reflect) {
      const r = (void 0 !== i.converter?.toAttribute ? i.converter : u$3).toAttribute(s, i.type);
      this._$Em = t, null == r ? this.removeAttribute(e) : this.setAttribute(e, r), this._$Em = null;
    }
  }
  _$AK(t, s) {
    const i = this.constructor,
      e = i._$Eh.get(t);
    if (void 0 !== e && this._$Em !== e) {
      const t = i.getPropertyOptions(e),
        r = "function" == typeof t.converter ? {
          fromAttribute: t.converter
        } : void 0 !== t.converter?.fromAttribute ? t.converter : u$3;
      this._$Em = e, this[e] = r.fromAttribute(s, t.type), this._$Em = null;
    }
  }
  requestUpdate(t, s, i) {
    if (void 0 !== t) {
      if (i ??= this.constructor.getPropertyOptions(t), !(i.hasChanged ?? f$3)(this[t], s)) return;
      this.P(t, s, i);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t, s, i) {
    this._$AL.has(t) || this._$AL.set(t, s), true === i.reflect && this._$Em !== t && (this._$Ej ??= new Set()).add(t);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const t = this.scheduleUpdate();
    return null != t && (await t), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t, s] of this._$Ep) this[t] = s;
        this._$Ep = void 0;
      }
      const t = this.constructor.elementProperties;
      if (t.size > 0) for (const [s, i] of t) true !== i.wrapped || this._$AL.has(s) || void 0 === this[s] || this.P(s, this[s], i);
    }
    let t = false;
    const s = this._$AL;
    try {
      t = this.shouldUpdate(s), t ? (this.willUpdate(s), this._$EO?.forEach(t => t.hostUpdate?.()), this.update(s)) : this._$EU();
    } catch (s) {
      throw t = false, this._$EU(), s;
    }
    t && this._$AE(s);
  }
  willUpdate(t) {}
  _$AE(t) {
    this._$EO?.forEach(t => t.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Ej &&= this._$Ej.forEach(t => this._$EC(t, this[t])), this._$EU();
  }
  updated(t) {}
  firstUpdated(t) {}
}
b.elementStyles = [], b.shadowRootOptions = {
  mode: "open"
}, b[d$1("elementProperties")] = new Map(), b[d$1("finalized")] = new Map(), p$1?.({
  ReactiveElement: b
}), (a$2.reactiveElementVersions ??= []).push("2.0.4");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = globalThis,
  i$5 = t$3.trustedTypes,
  s$1 = i$5 ? i$5.createPolicy("lit-html", {
    createHTML: t => t
  }) : void 0,
  e$9 = "$lit$",
  h$2 = `lit$${Math.random().toFixed(9).slice(2)}$`,
  o$a = "?" + h$2,
  n$7 = `<${o$a}>`,
  r$6 = document,
  l$2 = () => r$6.createComment(""),
  c$1 = t => null === t || "object" != typeof t && "function" != typeof t,
  a$1 = Array.isArray,
  u$2 = t => a$1(t) || "function" == typeof t?.[Symbol.iterator],
  d = "[ \t\n\f\r]",
  f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  v = /-->/g,
  _ = />/g,
  m$1 = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`, "g"),
  p = /'/g,
  g = /"/g,
  $ = /^(?:script|style|textarea|title)$/i,
  y = t => (i, ...s) => ({
    _$litType$: t,
    strings: i,
    values: s
  }),
  x = y(1),
  T = Symbol.for("lit-noChange"),
  E = Symbol.for("lit-nothing"),
  A = new WeakMap(),
  C = r$6.createTreeWalker(r$6, 129);
function P(t, i) {
  if (!a$1(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s$1 ? s$1.createHTML(i) : i;
}
const V = (t, i) => {
  const s = t.length - 1,
    o = [];
  let r,
    l = 2 === i ? "<svg>" : 3 === i ? "<math>" : "",
    c = f$2;
  for (let i = 0; i < s; i++) {
    const s = t[i];
    let a,
      u,
      d = -1,
      y = 0;
    for (; y < s.length && (c.lastIndex = y, u = c.exec(s), null !== u);) y = c.lastIndex, c === f$2 ? "!--" === u[1] ? c = v : void 0 !== u[1] ? c = _ : void 0 !== u[2] ? ($.test(u[2]) && (r = RegExp("</" + u[2], "g")), c = m$1) : void 0 !== u[3] && (c = m$1) : c === m$1 ? ">" === u[0] ? (c = r ?? f$2, d = -1) : void 0 === u[1] ? d = -2 : (d = c.lastIndex - u[2].length, a = u[1], c = void 0 === u[3] ? m$1 : '"' === u[3] ? g : p) : c === g || c === p ? c = m$1 : c === v || c === _ ? c = f$2 : (c = m$1, r = void 0);
    const x = c === m$1 && t[i + 1].startsWith("/>") ? " " : "";
    l += c === f$2 ? s + n$7 : d >= 0 ? (o.push(a), s.slice(0, d) + e$9 + s.slice(d) + h$2 + x) : s + h$2 + (-2 === d ? i : x);
  }
  return [P(t, l + (t[s] || "<?>") + (2 === i ? "</svg>" : 3 === i ? "</math>" : "")), o];
};
class N {
  constructor({
    strings: t,
    _$litType$: s
  }, n) {
    let r;
    this.parts = [];
    let c = 0,
      a = 0;
    const u = t.length - 1,
      d = this.parts,
      [f, v] = V(t, s);
    if (this.el = N.createElement(f, n), C.currentNode = this.el.content, 2 === s || 3 === s) {
      const t = this.el.content.firstChild;
      t.replaceWith(...t.childNodes);
    }
    for (; null !== (r = C.nextNode()) && d.length < u;) {
      if (1 === r.nodeType) {
        if (r.hasAttributes()) for (const t of r.getAttributeNames()) if (t.endsWith(e$9)) {
          const i = v[a++],
            s = r.getAttribute(t).split(h$2),
            e = /([.?@])?(.*)/.exec(i);
          d.push({
            type: 1,
            index: c,
            name: e[2],
            strings: s,
            ctor: "." === e[1] ? H$1 : "?" === e[1] ? I : "@" === e[1] ? L : k
          }), r.removeAttribute(t);
        } else t.startsWith(h$2) && (d.push({
          type: 6,
          index: c
        }), r.removeAttribute(t));
        if ($.test(r.tagName)) {
          const t = r.textContent.split(h$2),
            s = t.length - 1;
          if (s > 0) {
            r.textContent = i$5 ? i$5.emptyScript : "";
            for (let i = 0; i < s; i++) r.append(t[i], l$2()), C.nextNode(), d.push({
              type: 2,
              index: ++c
            });
            r.append(t[s], l$2());
          }
        }
      } else if (8 === r.nodeType) if (r.data === o$a) d.push({
        type: 2,
        index: c
      });else {
        let t = -1;
        for (; -1 !== (t = r.data.indexOf(h$2, t + 1));) d.push({
          type: 7,
          index: c
        }), t += h$2.length - 1;
      }
      c++;
    }
  }
  static createElement(t, i) {
    const s = r$6.createElement("template");
    return s.innerHTML = t, s;
  }
}
function S(t, i, s = t, e) {
  if (i === T) return i;
  let h = void 0 !== e ? s._$Co?.[e] : s._$Cl;
  const o = c$1(i) ? void 0 : i._$litDirective$;
  return h?.constructor !== o && (h?._$AO?.(false), void 0 === o ? h = void 0 : (h = new o(t), h._$AT(t, s, e)), void 0 !== e ? (s._$Co ??= [])[e] = h : s._$Cl = h), void 0 !== h && (i = S(t, h._$AS(t, i.values), h, e)), i;
}
class M {
  constructor(t, i) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const {
        el: {
          content: i
        },
        parts: s
      } = this._$AD,
      e = (t?.creationScope ?? r$6).importNode(i, true);
    C.currentNode = e;
    let h = C.nextNode(),
      o = 0,
      n = 0,
      l = s[0];
    for (; void 0 !== l;) {
      if (o === l.index) {
        let i;
        2 === l.type ? i = new R(h, h.nextSibling, this, t) : 1 === l.type ? i = new l.ctor(h, l.name, l.strings, this, t) : 6 === l.type && (i = new z(h, this, t)), this._$AV.push(i), l = s[++n];
      }
      o !== l?.index && (h = C.nextNode(), o++);
    }
    return C.currentNode = r$6, e;
  }
  p(t) {
    let i = 0;
    for (const s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;
  }
}
class R {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t, i, s, e) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cv = e?.isConnected ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const i = this._$AM;
    return void 0 !== i && 11 === t?.nodeType && (t = i.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, i = this) {
    t = S(this, t, i), c$1(t) ? t === E || null == t || "" === t ? (this._$AH !== E && this._$AR(), this._$AH = E) : t !== this._$AH && t !== T && this._(t) : void 0 !== t._$litType$ ? this.$(t) : void 0 !== t.nodeType ? this.T(t) : u$2(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== E && c$1(this._$AH) ? this._$AA.nextSibling.data = t : this.T(r$6.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    const {
        values: i,
        _$litType$: s
      } = t,
      e = "number" == typeof s ? this._$AC(t) : (void 0 === s.el && (s.el = N.createElement(P(s.h, s.h[0]), this.options)), s);
    if (this._$AH?._$AD === e) this._$AH.p(i);else {
      const t = new M(e, this),
        s = t.u(this.options);
      t.p(i), this.T(s), this._$AH = t;
    }
  }
  _$AC(t) {
    let i = A.get(t.strings);
    return void 0 === i && A.set(t.strings, i = new N(t)), i;
  }
  k(t) {
    a$1(this._$AH) || (this._$AH = [], this._$AR());
    const i = this._$AH;
    let s,
      e = 0;
    for (const h of t) e === i.length ? i.push(s = new R(this.O(l$2()), this.O(l$2()), this, this.options)) : s = i[e], s._$AI(h), e++;
    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);
  }
  _$AR(t = this._$AA.nextSibling, i) {
    for (this._$AP?.(false, true, i); t && t !== this._$AB;) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    void 0 === this._$AM && (this._$Cv = t, this._$AP?.(t));
  }
}
class k {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, i, s, e, h) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = h, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = E;
  }
  _$AI(t, i = this, s, e) {
    const h = this.strings;
    let o = false;
    if (void 0 === h) t = S(this, t, i, 0), o = !c$1(t) || t !== this._$AH && t !== T, o && (this._$AH = t);else {
      const e = t;
      let n, r;
      for (t = h[0], n = 0; n < h.length - 1; n++) r = S(this, e[s + n], i, n), r === T && (r = this._$AH[n]), o ||= !c$1(r) || r !== this._$AH[n], r === E ? t = E : t !== E && (t += (r ?? "") + h[n + 1]), this._$AH[n] = r;
    }
    o && !e && this.j(t);
  }
  j(t) {
    t === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
let H$1 = class H extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === E ? void 0 : t;
  }
};
class I extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== E);
  }
}
class L extends k {
  constructor(t, i, s, e, h) {
    super(t, i, s, e, h), this.type = 5;
  }
  _$AI(t, i = this) {
    if ((t = S(this, t, i, 0) ?? E) === T) return;
    const s = this._$AH,
      e = t === E && s !== E || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive,
      h = t !== E && (s === E || e);
    e && this.element.removeEventListener(this.name, this, s), h && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class z {
  constructor(t, i, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    S(this, t);
  }
}
const j = t$3.litHtmlPolyfillSupport;
j?.(N, R), (t$3.litHtmlVersions ??= []).push("3.2.1");
const B = (t, i, s) => {
  const e = s?.renderBefore ?? i;
  let h = e._$litPart$;
  if (void 0 === h) {
    const t = s?.renderBefore ?? null;
    e._$litPart$ = h = new R(i.insertBefore(l$2(), t), t, void 0, s ?? {});
  }
  return h._$AI(t), h;
};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let r$5 = class r extends b {
  constructor() {
    super(...arguments), this.renderOptions = {
      host: this
    }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t.firstChild, t;
  }
  update(t) {
    const s = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = B(s, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return T;
  }
};
r$5._$litElement$ = true, r$5["finalized"] = true, globalThis.litElementHydrateSupport?.({
  LitElement: r$5
});
const i$4 = globalThis.litElementPolyfillSupport;
i$4?.({
  LitElement: r$5
});
(globalThis.litElementVersions ??= []).push("4.1.1");

// src/components/visually-hidden/visually-hidden.styles.ts
var visually_hidden_styles_default = i$7`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;

// src/styles/component.styles.ts
var component_styles_default = i$7`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = msg => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __await = function (promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = value => {
  var obj = value[__knownSymbol("asyncIterator")],
    isAwait = false,
    method,
    it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = k => it[k] = x => obj[k](x);
  } else {
    obj = obj.call(value);
    method = k => it[k] = v => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise(resolve => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = x => {
    throw x;
  }, "return" in obj && method("return"), it;
};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$9 = {
    attribute: true,
    type: String,
    converter: u$3,
    reflect: false,
    hasChanged: f$3
  },
  r$4 = (t = o$9, e, r) => {
    const {
      kind: n,
      metadata: i
    } = r;
    let s = globalThis.litPropertyMetadata.get(i);
    if (void 0 === s && globalThis.litPropertyMetadata.set(i, s = new Map()), s.set(r.name, t), "accessor" === n) {
      const {
        name: o
      } = r;
      return {
        set(r) {
          const n = e.get.call(this);
          e.set.call(this, r), this.requestUpdate(o, n, t);
        },
        init(e) {
          return void 0 !== e && this.P(o, void 0, t), e;
        }
      };
    }
    if ("setter" === n) {
      const {
        name: o
      } = r;
      return function (r) {
        const n = this[o];
        e.call(this, r), this.requestUpdate(o, n, t);
      };
    }
    throw Error("Unsupported decorator location: " + n);
  };
function n$6(t) {
  return (e, o) => "object" == typeof o ? r$4(t, e, o) : ((t, e, o) => {
    const r = e.hasOwnProperty(o);
    return e.constructor.createProperty(o, r ? {
      ...t,
      wrapped: true
    } : t), r ? Object.getOwnPropertyDescriptor(e, o) : void 0;
  })(t, e, o);
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$3(r) {
  return n$6({
    ...r,
    state: true,
    attribute: false
  });
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function t$2(t) {
  return (n, o) => {
    const c = "function" == typeof n ? n : n[o];
    Object.assign(c, t);
  };
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$8 = (e, t, c) => (c.configurable = true, c.enumerable = true, Reflect.decorate && "object" != typeof t && Object.defineProperty(e, t, c), c);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$7(e, r) {
  return (n, s, i) => {
    const o = t => t.renderRoot?.querySelector(e) ?? null;
    return e$8(n, s, {
      get() {
        return o(this);
      }
    });
  };
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$2(r) {
  return (n, e) => e$8(n, e, {
    async get() {
      return await this.updateComplete, this.renderRoot?.querySelector(r) ?? null;
    }
  });
}

var _hasRecordedInitialProperties;
var ShoelaceElement = class extends r$5 {
  constructor() {
    super();
    __privateAdd(this, _hasRecordedInitialProperties, false);
    // Store the constructor value of all `static properties = {}`
    this.initialReflectedProperties = /* @__PURE__ */new Map();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      try {
        customElements.define(name, elementConstructor, options);
      } catch (_err) {
        customElements.define(name, class extends elementConstructor {}, options);
      }
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(`Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (!__privateGet(this, _hasRecordedInitialProperties)) {
      this.constructor.elementProperties.forEach((obj, prop) => {
        if (obj.reflect && this[prop] != null) {
          this.initialReflectedProperties.set(prop, this[prop]);
        }
      });
      __privateSet(this, _hasRecordedInitialProperties, true);
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  willUpdate(changedProperties) {
    super.willUpdate(changedProperties);
    this.initialReflectedProperties.forEach((value, prop) => {
      if (changedProperties.has(prop) && this[prop] == null) {
        this[prop] = value;
      }
    });
  }
};
_hasRecordedInitialProperties = new WeakMap();
/* eslint-disable */
// @ts-expect-error This is auto-injected at build time.
ShoelaceElement.version = "2.20.1";
ShoelaceElement.dependencies = {};
__decorateClass([n$6()], ShoelaceElement.prototype, "dir", 2);
__decorateClass([n$6()], ShoelaceElement.prototype, "lang", 2);

var SlVisuallyHidden = class extends ShoelaceElement {
  render() {
    return x` <slot></slot> `;
  }
};
SlVisuallyHidden.styles = [component_styles_default, visually_hidden_styles_default];

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$6 = new Set(["children", "localName", "ref", "style", "className"]),
  n$5 = new WeakMap(),
  t$1 = (e, t, o, l, a) => {
    const s = a?.[t];
    void 0 === s ? (e[t] = o, null == o && t in HTMLElement.prototype && e.removeAttribute(t)) : o !== l && ((e, t, o) => {
      let l = n$5.get(e);
      void 0 === l && n$5.set(e, l = new Map());
      let a = l.get(t);
      void 0 !== o ? void 0 === a ? (l.set(t, a = {
        handleEvent: o
      }), e.addEventListener(t, a)) : a.handleEvent = o : void 0 !== a && (l.delete(t), e.removeEventListener(t, a));
    })(e, s, o);
  },
  o$8 = ({
    react: n,
    tagName: o,
    elementClass: l,
    events: a,
    displayName: s
  }) => {
    const c = new Set(Object.keys(a ?? {})),
      r = n.forwardRef((s, r) => {
        const i = n.useRef(new Map()),
          d = n.useRef(null),
          f = {},
          u = {};
        for (const [n, t] of Object.entries(s)) e$6.has(n) ? f["className" === n ? "class" : n] = t : c.has(n) || n in l.prototype ? u[n] = t : f[n] = t;
        return n.useLayoutEffect(() => {
          if (null === d.current) return;
          const e = new Map();
          for (const n in u) t$1(d.current, n, s[n], i.current.get(n), a), i.current.delete(n), e.set(n, s[n]);
          for (const [e, n] of i.current) t$1(d.current, e, void 0, n, a);
          i.current = e;
        }), n.useLayoutEffect(() => {
          d.current?.removeAttribute("defer-hydration");
        }, []), f.suppressHydrationWarning = true, n.createElement(o, {
          ...f,
          ref: n.useCallback(e => {
            d.current = e, "function" == typeof r ? r(e) : null !== r && (r.current = e);
          }, [r])
        });
      });
    return r.displayName = s ?? l.name, r;
  };

var tagName$V = "sl-visually-hidden";
SlVisuallyHidden.define("sl-visually-hidden");
o$8({
  tagName: tagName$V,
  elementClass: SlVisuallyHidden,
  react: React$1,
  events: {},
  displayName: "SlVisuallyHidden"
});

// src/components/tab/tab.styles.ts
var tab_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  :host(:focus) {
    outline: transparent;
  }

  :host(:focus-visible) {
    color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;

// src/components/icon-button/icon-button.styles.ts
var icon_button_styles_default = i$7`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// src/utilities/base-path.ts
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find(script => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find(s => {
        return /shoelace(\.min)?\.js($|\?)/.test(s.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// src/components/icon/library.default.ts
var library = {
  name: "default",
  resolver: name => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// src/components/icon/library.system.ts
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: name => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// src/components/icon/library.ts
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter(el => el !== icon);
}
function getIconLibrary(name) {
  return registry.find(lib => lib.name === name);
}

// src/components/icon/icon.styles.ts
var icon_styles_default = i$7`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// src/internal/watch.ts
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const {
      update
    } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function (changedProps) {
      watchedProperties.forEach(property => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update.call(this, changedProps);
    };
  };
}

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$5 = (o, t) => void 0 !== o?._$litType$ ,
  f$1 = o => void 0 === o.strings,
  u$1 = {},
  m = (o, t = u$1) => o._$AH = t;

var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library) {
    var _a;
    let fileData;
    if (library == null ? void 0 : library.spriteSheet) {
      this.svg = x`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      return this.svg;
    }
    try {
      fileData = await fetch(url, {
        mode: "cors"
      });
      if (!fileData.ok) return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a.toLowerCase()) !== "svg") return CACHEABLE_ERROR;
      if (!parser) parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl) return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library = getIconLibrary(this.library);
    if (this.name && library) {
      return {
        url: library.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a;
    const {
      url,
      fromLibrary
    } = this.getIconSource();
    const library = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (e$5(svg)) {
      this.svg = svg;
      if (library) {
        await this.updateComplete;
        const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
        if (typeof library.mutator === "function" && shadowSVG) {
          library.mutator(shadowSVG);
        }
      }
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a = library == null ? void 0 : library.mutator) == null ? void 0 : _a.call(library, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([r$3()], SlIcon.prototype, "svg", 2);
__decorateClass([n$6({
  reflect: true
})], SlIcon.prototype, "name", 2);
__decorateClass([n$6()], SlIcon.prototype, "src", 2);
__decorateClass([n$6()], SlIcon.prototype, "label", 2);
__decorateClass([n$6({
  reflect: true
})], SlIcon.prototype, "library", 2);
__decorateClass([watch("label")], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([watch(["name", "src", "library"])], SlIcon.prototype, "setIcon", 1);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4},
  e$4 = t => (...e) => ({
    _$litDirective$: t,
    values: e
  });
let i$3 = class i {
  constructor(t) {}
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$3 = e$4(class extends i$3 {
  constructor(t$1) {
    if (super(t$1), t$1.type !== t.ATTRIBUTE || "class" !== t$1.name || t$1.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t) {
    return " " + Object.keys(t).filter(s => t[s]).join(" ") + " ";
  }
  update(s, [i]) {
    if (void 0 === this.st) {
      this.st = new Set(), void 0 !== s.strings && (this.nt = new Set(s.strings.join(" ").split(/\s/).filter(t => "" !== t)));
      for (const t in i) i[t] && !this.nt?.has(t) && this.st.add(t);
      return this.render(i);
    }
    const r = s.element.classList;
    for (const t of this.st) t in i || (r.remove(t), this.st.delete(t));
    for (const t in i) {
      const s = !!i[t];
      s === this.st.has(t) || this.nt?.has(t) || (s ? (r.add(t), this.st.add(t)) : (r.remove(t), this.st.delete(t)));
    }
    return T;
  }
});

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const a = Symbol.for(""),
  o$7 = t => {
    if (t?.r === a) return t?._$litStatic$;
  },
  i$2 = (t, ...r) => ({
    _$litStatic$: r.reduce((r, e, a) => r + (t => {
      if (void 0 !== t._$litStatic$) return t._$litStatic$;
      throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`);
    })(e) + t[a + 1], t[0]),
    r: a
  }),
  l$1 = new Map(),
  n$4 = t => (r, ...e) => {
    const a = e.length;
    let s, i;
    const n = [],
      u = [];
    let c,
      $ = 0,
      f = false;
    for (; $ < a;) {
      for (c = r[$]; $ < a && void 0 !== (i = e[$], s = o$7(i));) c += s + r[++$], f = true;
      $ !== a && u.push(i), n.push(c), $++;
    }
    if ($ === a && n.push(r[a]), f) {
      const t = n.join("$$lit$$");
      void 0 === (r = l$1.get(t)) && (n.raw = n, l$1.set(t, r = n)), e = u;
    }
    return t(r, ...e);
  },
  u = n$4(x);

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$6 = o => o ?? E;

var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? i$2`a` : i$2`button`;
    return u`
      <${tag}
        part="base"
        class=${e$3({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${o$6(isLink ? void 0 : this.disabled)}
        type=${o$6(isLink ? void 0 : "button")}
        href=${o$6(isLink ? this.href : void 0)}
        target=${o$6(isLink ? this.target : void 0)}
        download=${o$6(isLink ? this.download : void 0)}
        rel=${o$6(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o$6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o$6(this.name)}
          library=${o$6(this.library)}
          src=${o$6(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".icon-button")], SlIconButton.prototype, "button", 2);
__decorateClass([r$3()], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlIconButton.prototype, "name", 2);
__decorateClass([n$6()], SlIconButton.prototype, "library", 2);
__decorateClass([n$6()], SlIconButton.prototype, "src", 2);
__decorateClass([n$6()], SlIconButton.prototype, "href", 2);
__decorateClass([n$6()], SlIconButton.prototype, "target", 2);
__decorateClass([n$6()], SlIconButton.prototype, "download", 2);
__decorateClass([n$6()], SlIconButton.prototype, "label", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlIconButton.prototype, "disabled", 2);

const connectedElements = new Set();
const translations = new Map();
let fallback;
let documentDirection = 'ltr';
let documentLanguage = 'en';
const isClient = typeof MutationObserver !== "undefined" && typeof document !== "undefined" && typeof document.documentElement !== "undefined";
if (isClient) {
  const documentElementObserver = new MutationObserver(update);
  documentDirection = document.documentElement.dir || 'ltr';
  documentLanguage = document.documentElement.lang || navigator.language;
  documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['dir', 'lang']
  });
}
function registerTranslation(...translation) {
  translation.map(t => {
    const code = t.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t));
    } else {
      translations.set(code, t);
    }
    if (!fallback) {
      fallback = t;
    }
  });
  update();
}
function update() {
  if (isClient) {
    documentDirection = document.documentElement.dir || 'ltr';
    documentLanguage = document.documentElement.lang || navigator.language;
  }
  [...connectedElements.keys()].map(el => {
    if (typeof el.requestUpdate === 'function') {
      el.requestUpdate();
    }
  });
}
let LocalizeController$1 = class LocalizeController {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, '-'));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : '';
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return {
      locale,
      language,
      region,
      primary,
      secondary
    };
  }
  exists(key, options) {
    var _a;
    const {
      primary,
      secondary
    } = this.getTranslationData((_a = options.lang) !== null && _a !== void 0 ? _a : this.lang());
    options = Object.assign({
      includeFallback: false
    }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const {
      primary,
      secondary
    } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === 'function') {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? '' : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// src/translations/en.ts
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: num => {
    if (num === 0) return "No options selected";
    if (num === 1) return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: slide => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

var LocalizeController = class extends LocalizeController$1 {};
registerTranslation(en_default);

var id$1 = 0;
var SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.attrId = ++id$1;
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
    this.tabIndex = 0;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tab");
  }
  handleCloseClick(event) {
    event.stopPropagation();
    this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    if (this.disabled && !this.active) {
      this.tabIndex = -1;
    } else {
      this.tabIndex = 0;
    }
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return x`
      <div
        part="base"
        class=${e$3({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
      >
        <slot></slot>
        ${this.closable ? x`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([e$7(".tab")], SlTab.prototype, "tab", 2);
__decorateClass([n$6({
  reflect: true
})], SlTab.prototype, "panel", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTab.prototype, "active", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTab.prototype, "closable", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTab.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Number,
  reflect: true
})], SlTab.prototype, "tabIndex", 2);
__decorateClass([watch("active")], SlTab.prototype, "handleActiveChange", 1);
__decorateClass([watch("disabled")], SlTab.prototype, "handleDisabledChange", 1);

var tagName$U = "sl-tab";
SlTab.define("sl-tab");
var reactWrapper$3 = o$8({
  tagName: tagName$U,
  elementClass: SlTab,
  react: React$1,
  events: {
    onSlClose: "sl-close"
  },
  displayName: "SlTab"
});
var tab_default = reactWrapper$3;

// src/components/tab-group/tab-group.styles.ts
var tab_group_styles_default = i$7`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group--has-scroll-controls .tab-group__scroll-button--start--hidden,
  .tab-group--has-scroll-controls .tab-group__scroll-button--end--hidden {
    visibility: hidden;
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

// src/components/resize-observer/resize-observer.styles.ts
var resize_observer_styles_default = i$7`
  :host {
    display: contents;
  }
`;

var SlResizeObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.observedElements = [];
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(entries => {
      this.emit("sl-resize", {
        detail: {
          entries
        }
      });
    });
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  handleSlotChange() {
    if (!this.disabled) {
      this.startObserver();
    }
  }
  startObserver() {
    const slot = this.shadowRoot.querySelector("slot");
    if (slot !== null) {
      const elements = slot.assignedElements({
        flatten: true
      });
      this.observedElements.forEach(el => this.resizeObserver.unobserve(el));
      this.observedElements = [];
      elements.forEach(el => {
        this.resizeObserver.observe(el);
        this.observedElements.push(el);
      });
    }
  }
  stopObserver() {
    this.resizeObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  render() {
    return x` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlResizeObserver.styles = [component_styles_default, resize_observer_styles_default];
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlResizeObserver.prototype, "disabled", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlResizeObserver.prototype, "handleDisabledChange", 1);

// src/internal/offset.ts
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}

// src/internal/scroll.ts
var locks = /* @__PURE__ */new Set();
function getScrollbarWidth() {
  const documentWidth = document.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function getExistingBodyPadding() {
  const padding = Number(getComputedStyle(document.body).paddingRight.replace(/px/, ""));
  if (isNaN(padding) || !padding) {
    return 0;
  }
  return padding;
}
function lockBodyScrolling(lockingEl) {
  locks.add(lockingEl);
  if (!document.documentElement.classList.contains("sl-scroll-lock")) {
    const scrollbarWidth = getScrollbarWidth() + getExistingBodyPadding();
    let scrollbarGutterProperty = getComputedStyle(document.documentElement).scrollbarGutter;
    if (!scrollbarGutterProperty || scrollbarGutterProperty === "auto") {
      scrollbarGutterProperty = "stable";
    }
    if (scrollbarWidth < 2) {
      scrollbarGutterProperty = "";
    }
    document.documentElement.style.setProperty("--sl-scroll-lock-gutter", scrollbarGutterProperty);
    document.documentElement.classList.add("sl-scroll-lock");
    document.documentElement.style.setProperty("--sl-scroll-lock-size", `${scrollbarWidth}px`);
  }
}
function unlockBodyScrolling(lockingEl) {
  locks.delete(lockingEl);
  if (locks.size === 0) {
    document.documentElement.classList.remove("sl-scroll-lock");
    document.documentElement.style.removeProperty("--sl-scroll-lock-size");
  }
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset = getOffset(element, container);
  const offsetTop = offset.top + container.scrollTop;
  const offsetLeft = offset.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({
        left: offsetLeft,
        behavior
      });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({
        left: offsetLeft - container.offsetWidth + element.clientWidth,
        behavior
      });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({
        top: offsetTop,
        behavior
      });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({
        top: offsetTop - container.offsetHeight + element.clientHeight,
        behavior
      });
    }
  }
}

var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.focusableTabs = [];
    this.panels = [];
    this.localize = new LocalizeController(this);
    this.hasScrollControls = false;
    this.shouldHideScrollStartButton = false;
    this.shouldHideScrollEndButton = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
    this.fixedScrollControls = false;
    /**
     * The reality of the browser means that we can't expect the scroll position to be exactly what we want it to be, so
     * we add one pixel of wiggle room to our calculations.
     */
    this.scrollOffset = 1;
  }
  connectedCallback() {
    const whenAllDefined = Promise.all([customElements.whenDefined("sl-tab"), customElements.whenDefined("sl-tab-panel")]);
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver(mutations => {
      const instanceMutations = mutations.filter(({
        target
      }) => {
        if (target === this) return true;
        if (target.closest("sl-tab-group") !== this) return false;
        const tagName = target.tagName.toLowerCase();
        return tagName === "sl-tab" || tagName === "sl-tab-panel";
      });
      if (instanceMutations.length === 0) {
        return;
      }
      if (instanceMutations.some(m => !["aria-labelledby", "aria-controls"].includes(m.attributeName))) {
        setTimeout(() => this.setAriaLabels());
      }
      if (instanceMutations.some(m => m.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      } else if (instanceMutations.some(m => m.attributeName === "active")) {
        const tabs = instanceMutations.filter(m => m.attributeName === "active" && m.target.tagName.toLowerCase() === "sl-tab").map(m => m.target);
        const newActiveTab = tabs.find(tab => tab.active);
        if (newActiveTab) {
          this.setActiveTab(newActiveTab);
        }
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, {
        attributes: true,
        attributeFilter: ["active", "disabled", "name", "panel"],
        childList: true,
        subtree: true
      });
      this.resizeObserver.observe(this.nav);
      whenAllDefined.then(() => {
        const intersectionObserver = new IntersectionObserver((entries, observer) => {
          var _a;
          if (entries[0].intersectionRatio > 0) {
            this.setAriaLabels();
            this.setActiveTab((_a = this.getActiveTab()) != null ? _a : this.tabs[0], {
              emitEvents: false
            });
            observer.unobserve(entries[0].target);
          }
        });
        intersectionObserver.observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    var _a, _b;
    super.disconnectedCallback();
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
    if (this.nav) {
      (_b = this.resizeObserver) == null ? void 0 : _b.unobserve(this.nav);
    }
  }
  getAllTabs() {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return slot.assignedElements();
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter(el => el.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find(el => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, {
        scrollBehavior: "smooth"
      });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, {
          scrollBehavior: "smooth"
        });
        event.preventDefault();
      }
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const activeEl = this.tabs.find(t => t.matches(":focus"));
      const isRtl = this.localize.dir() === "rtl";
      let nextTab = null;
      if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
        if (event.key === "Home") {
          nextTab = this.focusableTabs[0];
        } else if (event.key === "End") {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
          const currentIndex = this.tabs.findIndex(el => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "backward");
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
          const currentIndex = this.tabs.findIndex(el => el === activeEl);
          nextTab = this.findNextFocusableTab(currentIndex, "forward");
        }
        if (!nextTab) {
          return;
        }
        nextTab.tabIndex = 0;
        nextTab.focus({
          preventScroll: true
        });
        if (this.activation === "auto") {
          this.setActiveTab(nextTab, {
            scrollBehavior: "smooth"
          });
        } else {
          this.tabs.forEach(tabEl => {
            tabEl.tabIndex = tabEl === nextTab ? 0 : -1;
          });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(nextTab, this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(tab, options) {
    options = __spreadValues({
      emitEvents: true,
      scrollBehavior: "auto"
    }, options);
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.forEach(el => {
        el.active = el === this.activeTab;
        el.tabIndex = el === this.activeTab ? 0 : -1;
      });
      this.panels.forEach(el => {
        var _a;
        return el.active = el.name === ((_a = this.activeTab) == null ? void 0 : _a.panel);
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
      }
      if (options.emitEvents) {
        if (previousTab) {
          this.emit("sl-tab-hide", {
            detail: {
              name: previousTab.panel
            }
          });
        }
        this.emit("sl-tab-show", {
          detail: {
            name: this.activeTab.panel
          }
        });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach(tab => {
      const panel = this.panels.find(el => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const isRtl = this.localize.dir() === "rtl";
    const allTabs = this.getAllTabs();
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset = precedingTabs.reduce((previous, current) => ({
      left: previous.left + current.clientWidth,
      top: previous.top + current.clientHeight
    }), {
      left: 0,
      top: 0
    });
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.translate = isRtl ? `${ -1 * offset.left}px` : `${offset.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.translate = `0 ${offset.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs();
    this.focusableTabs = this.tabs.filter(el => !el.disabled);
    this.panels = this.getAllPanels();
    this.syncIndicator();
    this.updateComplete.then(() => this.updateScrollControls());
  }
  findNextFocusableTab(currentIndex, direction) {
    let nextTab = null;
    const iterator = direction === "forward" ? 1 : -1;
    let nextIndex = currentIndex + iterator;
    while (currentIndex < this.tabs.length) {
      nextTab = this.tabs[nextIndex] || null;
      if (nextTab === null) {
        if (direction === "forward") {
          nextTab = this.focusableTabs[0];
        } else {
          nextTab = this.focusableTabs[this.focusableTabs.length - 1];
        }
        break;
      }
      if (!nextTab.disabled) {
        break;
      }
      nextIndex += iterator;
    }
    return nextTab;
  }
  updateScrollButtons() {
    if (this.hasScrollControls && !this.fixedScrollControls) {
      this.shouldHideScrollStartButton = this.scrollFromStart() <= this.scrollOffset;
      this.shouldHideScrollEndButton = this.isScrolledToEnd();
    }
  }
  isScrolledToEnd() {
    return this.scrollFromStart() + this.nav.clientWidth >= this.nav.scrollWidth - this.scrollOffset;
  }
  scrollFromStart() {
    return this.localize.dir() === "rtl" ? -this.nav.scrollLeft : this.nav.scrollLeft;
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
    }
    this.updateScrollButtons();
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  /** Shows the specified tab panel. */
  show(panel) {
    const tab = this.tabs.find(el => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, {
        scrollBehavior: "smooth"
      });
    }
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x`
      <div
        part="base"
        class=${e$3({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class=${e$3({
      "tab-group__scroll-button": true,
      "tab-group__scroll-button--start": true,
      "tab-group__scroll-button--start--hidden": this.shouldHideScrollStartButton
    })}
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav" @scrollend=${this.updateScrollButtons}>
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <sl-resize-observer @sl-resize=${this.syncIndicator}>
                <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
              </sl-resize-observer>
            </div>
          </div>

          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class=${e$3({
      "tab-group__scroll-button": true,
      "tab-group__scroll-button--end": true,
      "tab-group__scroll-button--end--hidden": this.shouldHideScrollEndButton
    })}
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  tabindex="-1"
                  aria-hidden="true"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = {
  "sl-icon-button": SlIconButton,
  "sl-resize-observer": SlResizeObserver
};
__decorateClass([e$7(".tab-group")], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([e$7(".tab-group__body")], SlTabGroup.prototype, "body", 2);
__decorateClass([e$7(".tab-group__nav")], SlTabGroup.prototype, "nav", 2);
__decorateClass([e$7(".tab-group__indicator")], SlTabGroup.prototype, "indicator", 2);
__decorateClass([r$3()], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass([r$3()], SlTabGroup.prototype, "shouldHideScrollStartButton", 2);
__decorateClass([r$3()], SlTabGroup.prototype, "shouldHideScrollEndButton", 2);
__decorateClass([n$6()], SlTabGroup.prototype, "placement", 2);
__decorateClass([n$6()], SlTabGroup.prototype, "activation", 2);
__decorateClass([n$6({
  attribute: "no-scroll-controls",
  type: Boolean
})], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass([n$6({
  attribute: "fixed-scroll-controls",
  type: Boolean
})], SlTabGroup.prototype, "fixedScrollControls", 2);
__decorateClass([t$2({
  passive: true
})], SlTabGroup.prototype, "updateScrollButtons", 1);
__decorateClass([watch("noScrollControls", {
  waitUntilFirstUpdate: true
})], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass([watch("placement", {
  waitUntilFirstUpdate: true
})], SlTabGroup.prototype, "syncIndicator", 1);

var tagName$T = "sl-tab-group";
SlTabGroup.define("sl-tab-group");
var reactWrapper$2 = o$8({
  tagName: tagName$T,
  elementClass: SlTabGroup,
  react: React$1,
  events: {
    onSlTabShow: "sl-tab-show",
    onSlTabHide: "sl-tab-hide"
  },
  displayName: "SlTabGroup"
});
var tab_group_default = reactWrapper$2;

// src/components/tab-panel/tab-panel.styles.ts
var tab_panel_styles_default = i$7`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;

var id = 0;
var SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrId = ++id;
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
    this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return x`
      <slot
        part="base"
        class=${e$3({
      "tab-panel": true,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass([n$6({
  reflect: true
})], SlTabPanel.prototype, "name", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTabPanel.prototype, "active", 2);
__decorateClass([watch("active")], SlTabPanel.prototype, "handleActiveChange", 1);

var tagName$S = "sl-tab-panel";
SlTabPanel.define("sl-tab-panel");
var reactWrapper$1 = o$8({
  tagName: tagName$S,
  elementClass: SlTabPanel,
  react: React$1,
  events: {},
  displayName: "SlTabPanel"
});
var tab_panel_default = reactWrapper$1;

// src/components/tag/tag.styles.ts
var tag_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$3({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? x`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([n$6({
  reflect: true
})], SlTag.prototype, "variant", 2);
__decorateClass([n$6({
  reflect: true
})], SlTag.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTag.prototype, "pill", 2);
__decorateClass([n$6({
  type: Boolean
})], SlTag.prototype, "removable", 2);

var tagName$R = "sl-tag";
SlTag.define("sl-tag");
o$8({
  tagName: tagName$R,
  elementClass: SlTag,
  react: React$1,
  events: {
    onSlRemove: "sl-remove"
  },
  displayName: "SlTag"
});

// src/components/textarea/textarea.styles.ts
var textarea_styles_default = i$7`
  :host {
    display: block;
  }

  .textarea {
    display: grid;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control,
  .textarea__size-adjuster {
    grid-area: 1 / 1 / 2 / 2;
  }

  .textarea__size-adjuster {
    visibility: hidden;
    pointer-events: none;
    opacity: 0;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`;

// src/internal/default-value.ts
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function (name, old, value) {
    var _a;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u$3;
      const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : u$3.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// src/styles/form-control.styles.ts
var form_control_styles_default = i$7`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// src/internal/form.ts
var formCollections = /* @__PURE__ */new WeakMap();
var reportValidityOverloads = /* @__PURE__ */new WeakMap();
var checkValidityOverloads = /* @__PURE__ */new WeakMap();
var userInteractedControls = /* @__PURE__ */new WeakSet();
var interactions = /* @__PURE__ */new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = event => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach(val => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = event => {
      var _a;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach(control => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = event => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: input => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: input => input.name,
      value: input => input.value,
      defaultValue: input => input.defaultValue,
      disabled: input => {
        var _a;
        return (_a = input.disabled) != null ? _a : false;
      },
      reportValidity: input => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: input => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach(event => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach(event => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form) return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach(attr => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a;
    return (_a = this.form) != null ? _a : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// src/internal/slot.ts
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = event => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some(node => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({
    flatten: true
  });
  let text = "";
  [...nodes].forEach(node => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const l = e$4(class extends i$3 {
  constructor(r) {
    if (super(r), r.type !== t.PROPERTY && r.type !== t.ATTRIBUTE && r.type !== t.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f$1(r)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r) {
    return r;
  }
  update(i, [t$1]) {
    if (t$1 === T || t$1 === E) return t$1;
    const o = i.element,
      l = i.name;
    if (i.type === t.PROPERTY) {
      if (t$1 === o[l]) return T;
    } else if (i.type === t.BOOLEAN_ATTRIBUTE) {
      if (!!t$1 === o.hasAttribute(l)) return T;
    } else if (i.type === t.ATTRIBUTE && o.getAttribute(l) === t$1 + "") return T;
    return m(i), t$1;
  }
});

var SlTextarea = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.value = "";
    this.size = "medium";
    this.filled = false;
    this.label = "";
    this.helpText = "";
    this.placeholder = "";
    this.rows = 4;
    this.resize = "vertical";
    this.disabled = false;
    this.readonly = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
    this.defaultValue = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());
    this.updateComplete.then(() => {
      this.setTextareaHeight();
      this.resizeObserver.observe(this.input);
    });
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    if (this.input) {
      (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.input);
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.setTextareaHeight();
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  setTextareaHeight() {
    if (this.resize === "auto") {
      this.sizeAdjuster.style.height = `${this.input.clientHeight}px`;
      this.input.style.height = "auto";
      this.input.style.height = `${this.input.scrollHeight}px`;
    } else {
      this.input.style.height = "";
    }
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleRowsChange() {
    this.setTextareaHeight();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
    this.setTextareaHeight();
  }
  /** Sets focus on the textarea. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the textarea. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the textarea. */
  select() {
    this.input.select();
  }
  /** Gets or sets the textarea's scroll position. */
  scrollPosition(position) {
    if (position) {
      if (typeof position.top === "number") this.input.scrollTop = position.top;
      if (typeof position.left === "number") this.input.scrollLeft = position.left;
      return void 0;
    }
    return {
      top: this.input.scrollTop,
      left: this.input.scrollTop
    };
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
      this.setTextareaHeight();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x`
      <div
        part="form-control"
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$3({
      textarea: true,
      "textarea--small": this.size === "small",
      "textarea--medium": this.size === "medium",
      "textarea--large": this.size === "large",
      "textarea--standard": !this.filled,
      "textarea--filled": this.filled,
      "textarea--disabled": this.disabled,
      "textarea--focused": this.hasFocus,
      "textarea--empty": !this.value,
      "textarea--resize-none": this.resize === "none",
      "textarea--resize-vertical": this.resize === "vertical",
      "textarea--resize-auto": this.resize === "auto"
    })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${o$6(this.name)}
              .value=${l(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$6(this.placeholder)}
              rows=${o$6(this.rows)}
              minlength=${o$6(this.minlength)}
              maxlength=${o$6(this.maxlength)}
              autocapitalize=${o$6(this.autocapitalize)}
              autocorrect=${o$6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${o$6(this.spellcheck)}
              enterkeyhint=${o$6(this.enterkeyhint)}
              inputmode=${o$6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
            <!-- This "adjuster" exists to prevent layout shifting. https://github.com/shoelace-style/shoelace/issues/2180 -->
            <div part="textarea-adjuster" class="textarea__size-adjuster" ?hidden=${this.resize !== "auto"}></div>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlTextarea.styles = [component_styles_default, form_control_styles_default, textarea_styles_default];
__decorateClass([e$7(".textarea__control")], SlTextarea.prototype, "input", 2);
__decorateClass([e$7(".textarea__size-adjuster")], SlTextarea.prototype, "sizeAdjuster", 2);
__decorateClass([r$3()], SlTextarea.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlTextarea.prototype, "title", 2);
__decorateClass([n$6()], SlTextarea.prototype, "name", 2);
__decorateClass([n$6()], SlTextarea.prototype, "value", 2);
__decorateClass([n$6({
  reflect: true
})], SlTextarea.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTextarea.prototype, "filled", 2);
__decorateClass([n$6()], SlTextarea.prototype, "label", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlTextarea.prototype, "helpText", 2);
__decorateClass([n$6()], SlTextarea.prototype, "placeholder", 2);
__decorateClass([n$6({
  type: Number
})], SlTextarea.prototype, "rows", 2);
__decorateClass([n$6()], SlTextarea.prototype, "resize", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTextarea.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTextarea.prototype, "readonly", 2);
__decorateClass([n$6({
  reflect: true
})], SlTextarea.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTextarea.prototype, "required", 2);
__decorateClass([n$6({
  type: Number
})], SlTextarea.prototype, "minlength", 2);
__decorateClass([n$6({
  type: Number
})], SlTextarea.prototype, "maxlength", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocapitalize", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocorrect", 2);
__decorateClass([n$6()], SlTextarea.prototype, "autocomplete", 2);
__decorateClass([n$6({
  type: Boolean
})], SlTextarea.prototype, "autofocus", 2);
__decorateClass([n$6()], SlTextarea.prototype, "enterkeyhint", 2);
__decorateClass([n$6({
  type: Boolean,
  converter: {
    // Allow "true|false" attribute values but keep the property boolean
    fromAttribute: value => !value || value === "false" ? false : true,
    toAttribute: value => value ? "true" : "false"
  }
})], SlTextarea.prototype, "spellcheck", 2);
__decorateClass([n$6()], SlTextarea.prototype, "inputmode", 2);
__decorateClass([defaultValue()], SlTextarea.prototype, "defaultValue", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlTextarea.prototype, "handleDisabledChange", 1);
__decorateClass([watch("rows", {
  waitUntilFirstUpdate: true
})], SlTextarea.prototype, "handleRowsChange", 1);
__decorateClass([watch("value", {
  waitUntilFirstUpdate: true
})], SlTextarea.prototype, "handleValueChange", 1);

var tagName$Q = "sl-textarea";
SlTextarea.define("sl-textarea");
o$8({
  tagName: tagName$Q,
  elementClass: SlTextarea,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlTextarea"
});

// src/components/tooltip/tooltip.styles.ts
var tooltip_styles_default = i$7`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    text-align: start;
    white-space: normal;
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// src/components/popup/popup.styles.ts
var popup_styles_default = i$7`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp$1(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$2 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset$1 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === 'static';
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === 'rtl';
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = offset$1;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = shift$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$1 = flip$2;

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = size$1;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = arrow$1;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

function e$2(t) {
  return i$1(t);
}
function r$1(t) {
  return t.assignedSlot ? t.assignedSlot : t.parentNode instanceof ShadowRoot ? t.parentNode.host : t.parentNode;
}
function i$1(e) {
  for (let t = e; t; t = r$1(t)) if (t instanceof Element && "none" === getComputedStyle(t).display) return null;
  for (let n = r$1(e); n; n = r$1(n)) {
    if (!(n instanceof Element)) continue;
    const e = getComputedStyle(n);
    if ("contents" !== e.display) {
      if ("static" !== e.position || isContainingBlock(e)) return n;
      if ("BODY" === n.tagName) return n;
    }
  }
  return null;
}

function isVirtualElement(e) {
  return e !== null && typeof e === "object" && "getBoundingClientRect" in e && ("contextElement" in e ? e.contextElement instanceof Element : true);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({
        flatten: true
      })[0];
    }
    if (this.anchorEl && this.active) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl || !this.active) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise(resolve => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
    // The offset middleware goes first
    offset({
      mainAxis: this.distance,
      crossAxis: this.skidding
    })];
    if (this.sync) {
      middleware.push(size({
        apply: ({
          rects
        }) => {
          const syncWidth = this.sync === "width" || this.sync === "both";
          const syncHeight = this.sync === "height" || this.sync === "both";
          this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
          this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
        }
      }));
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(flip$1({
        boundary: this.flipBoundary,
        // @ts-expect-error - We're converting a string attribute to an array here
        fallbackPlacements: this.flipFallbackPlacements,
        fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
        padding: this.flipPadding
      }));
    }
    if (this.shift) {
      middleware.push(shift({
        boundary: this.shiftBoundary,
        padding: this.shiftPadding
      }));
    }
    if (this.autoSize) {
      middleware.push(size({
        boundary: this.autoSizeBoundary,
        padding: this.autoSizePadding,
        apply: ({
          availableWidth,
          availableHeight
        }) => {
          if (this.autoSize === "vertical" || this.autoSize === "both") {
            this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
          } else {
            this.style.removeProperty("--auto-size-available-height");
          }
          if (this.autoSize === "horizontal" || this.autoSize === "both") {
            this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
          } else {
            this.style.removeProperty("--auto-size-available-width");
          }
        }
      }));
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(arrow({
        element: this.arrowEl,
        padding: this.arrowPadding
      }));
    }
    const getOffsetParent = this.strategy === "absolute" ? element => platform.getOffsetParent(element, e$2) : platform.getOffsetParent;
    computePosition(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent
      })
    }).then(({
      x,
      y,
      middlewareData,
      placement
    }) => {
      const isRtl = this.localize.dir() === "rtl";
      const staticSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x}px`,
        top: `${y}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e$3({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${e$3({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([e$7(".popup")], SlPopup.prototype, "popup", 2);
__decorateClass([e$7(".popup__arrow")], SlPopup.prototype, "arrowEl", 2);
__decorateClass([n$6()], SlPopup.prototype, "anchor", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlPopup.prototype, "active", 2);
__decorateClass([n$6({
  reflect: true
})], SlPopup.prototype, "placement", 2);
__decorateClass([n$6({
  reflect: true
})], SlPopup.prototype, "strategy", 2);
__decorateClass([n$6({
  type: Number
})], SlPopup.prototype, "distance", 2);
__decorateClass([n$6({
  type: Number
})], SlPopup.prototype, "skidding", 2);
__decorateClass([n$6({
  type: Boolean
})], SlPopup.prototype, "arrow", 2);
__decorateClass([n$6({
  attribute: "arrow-placement"
})], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([n$6({
  attribute: "arrow-padding",
  type: Number
})], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([n$6({
  type: Boolean
})], SlPopup.prototype, "flip", 2);
__decorateClass([n$6({
  attribute: "flip-fallback-placements",
  converter: {
    fromAttribute: value => {
      return value.split(" ").map(p => p.trim()).filter(p => p !== "");
    },
    toAttribute: value => {
      return value.join(" ");
    }
  }
})], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([n$6({
  attribute: "flip-fallback-strategy"
})], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([n$6({
  type: Object
})], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([n$6({
  attribute: "flip-padding",
  type: Number
})], SlPopup.prototype, "flipPadding", 2);
__decorateClass([n$6({
  type: Boolean
})], SlPopup.prototype, "shift", 2);
__decorateClass([n$6({
  type: Object
})], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([n$6({
  attribute: "shift-padding",
  type: Number
})], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([n$6({
  attribute: "auto-size"
})], SlPopup.prototype, "autoSize", 2);
__decorateClass([n$6()], SlPopup.prototype, "sync", 2);
__decorateClass([n$6({
  type: Object
})], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([n$6({
  attribute: "auto-size-padding",
  type: Number
})], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([n$6({
  attribute: "hover-bridge",
  type: Boolean
})], SlPopup.prototype, "hoverBridge", 2);

// src/utilities/animation-registry.ts
var defaultAnimationRegistry = /* @__PURE__ */new Map();
var customAnimationRegistry = /* @__PURE__ */new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : {
    keyframes: [],
    options: {
      duration: 0
    }
  };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: {
      duration: 0
    }
  };
}

// src/internal/event.ts
function waitForEvent(el, eventName) {
  return new Promise(resolve => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// src/internal/animate.ts
function animateTo(el, keyframes, options) {
  return new Promise(resolve => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, {
      once: true
    });
    animation.addEventListener("finish", resolve, {
      once: true
    });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(el.getAnimations().map(animation => {
    return new Promise(resolve => {
      animation.cancel();
      requestAnimationFrame(resolve);
    });
  }));
}
function shimKeyframesHeightAuto(keyframes, calculatedHeight) {
  return keyframes.map(keyframe => __spreadProps(__spreadValues({}, keyframe), {
    height: keyframe.height === "auto" ? `${calculatedHeight}px` : keyframe.height
  }));
}

var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super();
    this.localize = new LocalizeController(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleDocumentKeyDown = event => {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--show-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(getComputedStyle(this).getPropertyValue("--hide-delay"));
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    var _a, _b;
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      if ("CloseWatcher" in window) {
        (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
        };
      } else {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      await stopAnimations(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const {
        keyframes,
        options
      } = getAnimation(this, "tooltip.show", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.reposition();
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      (_b = this.closeWatcher) == null ? void 0 : _b.destroy();
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      await stopAnimations(this.body);
      const {
        keyframes,
        options
      } = getAnimation(this, "tooltip.hide", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return x`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${e$3({
      tooltip: true,
      "tooltip--open": this.open
    })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${this.open ? "polite" : "off"}>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = {
  "sl-popup": SlPopup
};
__decorateClass([e$7("slot:not([name])")], SlTooltip.prototype, "defaultSlot", 2);
__decorateClass([e$7(".tooltip__body")], SlTooltip.prototype, "body", 2);
__decorateClass([e$7("sl-popup")], SlTooltip.prototype, "popup", 2);
__decorateClass([n$6()], SlTooltip.prototype, "content", 2);
__decorateClass([n$6()], SlTooltip.prototype, "placement", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTooltip.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Number
})], SlTooltip.prototype, "distance", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlTooltip.prototype, "open", 2);
__decorateClass([n$6({
  type: Number
})], SlTooltip.prototype, "skidding", 2);
__decorateClass([n$6()], SlTooltip.prototype, "trigger", 2);
__decorateClass([n$6({
  type: Boolean
})], SlTooltip.prototype, "hoist", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlTooltip.prototype, "handleOpenChange", 1);
__decorateClass([watch(["content", "distance", "hoist", "placement", "skidding"])], SlTooltip.prototype, "handleOptionsChange", 1);
__decorateClass([watch("disabled")], SlTooltip.prototype, "handleDisabledChange", 1);
setDefaultAnimation("tooltip.show", {
  keyframes: [{
    opacity: 0,
    scale: 0.8
  }, {
    opacity: 1,
    scale: 1
  }],
  options: {
    duration: 150,
    easing: "ease"
  }
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [{
    opacity: 1,
    scale: 1
  }, {
    opacity: 0,
    scale: 0.8
  }],
  options: {
    duration: 150,
    easing: "ease"
  }
});

var tagName$P = "sl-tooltip";
SlTooltip.define("sl-tooltip");
o$8({
  tagName: tagName$P,
  elementClass: SlTooltip,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide"
  },
  displayName: "SlTooltip"
});

// src/components/tree-item/tree-item.styles.ts
var tree_item_styles_default = i$7`
  :host {
    display: block;
    outline: 0;
    z-index: 0;
  }

  :host(:focus) {
    outline: none;
  }

  slot:not([name])::slotted(sl-icon) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .tree-item {
    position: relative;
    display: flex;
    align-items: stretch;
    flex-direction: column;
    color: var(--sl-color-neutral-700);
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }

  .tree-item__checkbox {
    pointer-events: none;
  }

  .tree-item__expand-button,
  .tree-item__checkbox,
  .tree-item__label {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-dense);
    letter-spacing: var(--sl-letter-spacing-normal);
  }

  .tree-item__checkbox::part(base) {
    display: flex;
    align-items: center;
  }

  .tree-item__indentation {
    display: block;
    width: 1em;
    flex-shrink: 0;
  }

  .tree-item__expand-button {
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: content-box;
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-x-small);
    width: 1rem;
    height: 1rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .tree-item__expand-button {
    transition: var(--sl-transition-medium) rotate ease;
  }

  .tree-item--expanded .tree-item__expand-button {
    rotate: 90deg;
  }

  .tree-item--expanded.tree-item--rtl .tree-item__expand-button {
    rotate: -90deg;
  }

  .tree-item--expanded slot[name='expand-icon'],
  .tree-item:not(.tree-item--expanded) slot[name='collapse-icon'] {
    display: none;
  }

  .tree-item:not(.tree-item--has-expand-button) .tree-item__expand-icon-slot {
    display: none;
  }

  .tree-item__expand-button--visible {
    cursor: pointer;
  }

  .tree-item__item {
    display: flex;
    align-items: center;
    border-inline-start: solid 3px transparent;
  }

  .tree-item--disabled .tree-item__item {
    opacity: 0.5;
    outline: none;
    cursor: not-allowed;
  }

  :host(:focus-visible) .tree-item__item {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
    z-index: 2;
  }

  :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
    background-color: var(--sl-color-neutral-100);
    border-inline-start-color: var(--sl-color-primary-600);
  }

  :host(:not([aria-disabled='true'])) .tree-item__expand-button {
    color: var(--sl-color-neutral-600);
  }

  .tree-item__label {
    display: flex;
    align-items: center;
    transition: var(--sl-transition-fast) color;
  }

  .tree-item__children {
    display: block;
    font-size: calc(1em + var(--indent-size, var(--sl-spacing-medium)));
  }

  /* Indentation lines */
  .tree-item__children {
    position: relative;
  }

  .tree-item__children::before {
    content: '';
    position: absolute;
    top: var(--indent-guide-offset);
    bottom: var(--indent-guide-offset);
    left: calc(1em - (var(--indent-guide-width) / 2) - 1px);
    border-inline-end: var(--indent-guide-width) var(--indent-guide-style) var(--indent-guide-color);
    z-index: 1;
  }

  .tree-item--rtl .tree-item__children::before {
    left: auto;
    right: 1em;
  }

  @media (forced-colors: active) {
    :host(:not([aria-disabled='true'])) .tree-item--selected .tree-item__item {
      outline: dashed 1px SelectedItem;
    }
  }
`;

// src/components/checkbox/checkbox.styles.ts
var checkbox_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: control => control.checked ? control.value || "on" : void 0,
      defaultValue: control => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x`
      <div
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${e$3({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$6(this.value)}
            .indeterminate=${l(this.indeterminate)}
            .checked=${l(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? x`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? x`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, form_control_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7('input[type="checkbox"]')], SlCheckbox.prototype, "input", 2);
__decorateClass([r$3()], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "title", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "name", 2);
__decorateClass([n$6()], SlCheckbox.prototype, "value", 2);
__decorateClass([n$6({
  reflect: true
})], SlCheckbox.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCheckbox.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCheckbox.prototype, "checked", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass([defaultValue("checked")], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass([n$6({
  reflect: true
})], SlCheckbox.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCheckbox.prototype, "required", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlCheckbox.prototype, "helpText", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass([watch(["checked", "indeterminate"], {
  waitUntilFirstUpdate: true
})], SlCheckbox.prototype, "handleStateChange", 1);

// src/components/spinner/spinner.styles.ts
var spinner_styles_default = i$7`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
  }
  render() {
    return x`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n$3(n, r, t) {
  return n ? r(n) : t?.(n);
}

var _SlTreeItem = class _SlTreeItem extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.indeterminate = false;
    this.isLeaf = false;
    this.loading = false;
    this.selectable = false;
    this.expanded = false;
    this.selected = false;
    this.disabled = false;
    this.lazy = false;
  }
  static isTreeItem(node) {
    return node instanceof Element && node.getAttribute("role") === "treeitem";
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "treeitem");
    this.setAttribute("tabindex", "-1");
    if (this.isNestedItem()) {
      this.slot = "children";
    }
  }
  firstUpdated() {
    this.childrenContainer.hidden = !this.expanded;
    this.childrenContainer.style.height = this.expanded ? "auto" : "0";
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
    this.handleExpandedChange();
  }
  async animateCollapse() {
    this.emit("sl-collapse");
    await stopAnimations(this.childrenContainer);
    const {
      keyframes,
      options
    } = getAnimation(this, "tree-item.collapse", {
      dir: this.localize.dir()
    });
    await animateTo(this.childrenContainer, shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight), options);
    this.childrenContainer.hidden = true;
    this.emit("sl-after-collapse");
  }
  // Checks whether the item is nested into an item
  isNestedItem() {
    const parent = this.parentElement;
    return !!parent && _SlTreeItem.isTreeItem(parent);
  }
  handleChildrenSlotChange() {
    this.loading = false;
    this.isLeaf = !this.lazy && this.getChildrenItems().length === 0;
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("selected") && !changedProperties.has("indeterminate")) {
      this.indeterminate = false;
    }
  }
  async animateExpand() {
    this.emit("sl-expand");
    await stopAnimations(this.childrenContainer);
    this.childrenContainer.hidden = false;
    const {
      keyframes,
      options
    } = getAnimation(this, "tree-item.expand", {
      dir: this.localize.dir()
    });
    await animateTo(this.childrenContainer, shimKeyframesHeightAuto(keyframes, this.childrenContainer.scrollHeight), options);
    this.childrenContainer.style.height = "auto";
    this.emit("sl-after-expand");
  }
  handleLoadingChange() {
    this.setAttribute("aria-busy", this.loading ? "true" : "false");
    if (!this.loading) {
      this.animateExpand();
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleExpandedChange() {
    if (!this.isLeaf) {
      this.setAttribute("aria-expanded", this.expanded ? "true" : "false");
    } else {
      this.removeAttribute("aria-expanded");
    }
  }
  handleExpandAnimation() {
    if (this.expanded) {
      if (this.lazy) {
        this.loading = true;
        this.emit("sl-lazy-load");
      } else {
        this.animateExpand();
      }
    } else {
      this.animateCollapse();
    }
  }
  handleLazyChange() {
    this.emit("sl-lazy-change");
  }
  /** Gets all the nested tree items in this node. */
  getChildrenItems({
    includeDisabled = true
  } = {}) {
    return this.childrenSlot ? [...this.childrenSlot.assignedElements({
      flatten: true
    })].filter(item => _SlTreeItem.isTreeItem(item) && (includeDisabled || !item.disabled)) : [];
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const showExpandButton = !this.loading && (!this.isLeaf || this.lazy);
    return x`
      <div
        part="base"
        class="${e$3({
      "tree-item": true,
      "tree-item--expanded": this.expanded,
      "tree-item--selected": this.selected,
      "tree-item--disabled": this.disabled,
      "tree-item--leaf": this.isLeaf,
      "tree-item--has-expand-button": showExpandButton,
      "tree-item--rtl": this.localize.dir() === "rtl"
    })}"
      >
        <div
          class="tree-item__item"
          part="
            item
            ${this.disabled ? "item--disabled" : ""}
            ${this.expanded ? "item--expanded" : ""}
            ${this.indeterminate ? "item--indeterminate" : ""}
            ${this.selected ? "item--selected" : ""}
          "
        >
          <div class="tree-item__indentation" part="indentation"></div>

          <div
            part="expand-button"
            class=${e$3({
      "tree-item__expand-button": true,
      "tree-item__expand-button--visible": showExpandButton
    })}
            aria-hidden="true"
          >
            ${n$3(this.loading, () => x` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `)}
            <slot class="tree-item__expand-icon-slot" name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot class="tree-item__expand-icon-slot" name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </div>

          ${n$3(this.selectable, () => x`
              <sl-checkbox
                part="checkbox"
                exportparts="
                    base:checkbox__base,
                    control:checkbox__control,
                    control--checked:checkbox__control--checked,
                    control--indeterminate:checkbox__control--indeterminate,
                    checked-icon:checkbox__checked-icon,
                    indeterminate-icon:checkbox__indeterminate-icon,
                    label:checkbox__label
                  "
                class="tree-item__checkbox"
                ?disabled="${this.disabled}"
                ?checked="${l(this.selected)}"
                ?indeterminate="${this.indeterminate}"
                tabindex="-1"
              ></sl-checkbox>
            `)}

          <slot class="tree-item__label" part="label"></slot>
        </div>

        <div class="tree-item__children" part="children" role="group">
          <slot name="children" @slotchange="${this.handleChildrenSlotChange}"></slot>
        </div>
      </div>
    `;
  }
};
_SlTreeItem.styles = [component_styles_default, tree_item_styles_default];
_SlTreeItem.dependencies = {
  "sl-checkbox": SlCheckbox,
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([r$3()], _SlTreeItem.prototype, "indeterminate", 2);
__decorateClass([r$3()], _SlTreeItem.prototype, "isLeaf", 2);
__decorateClass([r$3()], _SlTreeItem.prototype, "loading", 2);
__decorateClass([r$3()], _SlTreeItem.prototype, "selectable", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlTreeItem.prototype, "expanded", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlTreeItem.prototype, "selected", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlTreeItem.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlTreeItem.prototype, "lazy", 2);
__decorateClass([e$7("slot:not([name])")], _SlTreeItem.prototype, "defaultSlot", 2);
__decorateClass([e$7("slot[name=children]")], _SlTreeItem.prototype, "childrenSlot", 2);
__decorateClass([e$7(".tree-item__item")], _SlTreeItem.prototype, "itemElement", 2);
__decorateClass([e$7(".tree-item__children")], _SlTreeItem.prototype, "childrenContainer", 2);
__decorateClass([e$7(".tree-item__expand-button slot")], _SlTreeItem.prototype, "expandButtonSlot", 2);
__decorateClass([watch("loading", {
  waitUntilFirstUpdate: true
})], _SlTreeItem.prototype, "handleLoadingChange", 1);
__decorateClass([watch("disabled")], _SlTreeItem.prototype, "handleDisabledChange", 1);
__decorateClass([watch("selected")], _SlTreeItem.prototype, "handleSelectedChange", 1);
__decorateClass([watch("expanded", {
  waitUntilFirstUpdate: true
})], _SlTreeItem.prototype, "handleExpandedChange", 1);
__decorateClass([watch("expanded", {
  waitUntilFirstUpdate: true
})], _SlTreeItem.prototype, "handleExpandAnimation", 1);
__decorateClass([watch("lazy", {
  waitUntilFirstUpdate: true
})], _SlTreeItem.prototype, "handleLazyChange", 1);
var SlTreeItem = _SlTreeItem;
setDefaultAnimation("tree-item.expand", {
  keyframes: [{
    height: "0",
    opacity: "0",
    overflow: "hidden"
  }, {
    height: "auto",
    opacity: "1",
    overflow: "hidden"
  }],
  options: {
    duration: 250,
    easing: "cubic-bezier(0.4, 0.0, 0.2, 1)"
  }
});
setDefaultAnimation("tree-item.collapse", {
  keyframes: [{
    height: "auto",
    opacity: "1",
    overflow: "hidden"
  }, {
    height: "0",
    opacity: "0",
    overflow: "hidden"
  }],
  options: {
    duration: 200,
    easing: "cubic-bezier(0.4, 0.0, 0.2, 1)"
  }
});

var tagName$O = "sl-tree-item";
SlTreeItem.define("sl-tree-item");
o$8({
  tagName: tagName$O,
  elementClass: SlTreeItem,
  react: React$1,
  events: {
    onSlExpand: "sl-expand",
    onSlAfterExpand: "sl-after-expand",
    onSlCollapse: "sl-collapse",
    onSlAfterCollapse: "sl-after-collapse",
    onSlLazyChange: "sl-lazy-change",
    onSlLazyLoad: "sl-lazy-load"
  },
  displayName: "SlTreeItem"
});

// src/components/tree/tree.styles.ts
var tree_styles_default = i$7`
  :host {
    /*
     * These are actually used by tree item, but we define them here so they can more easily be set and all tree items
     * stay consistent.
     */
    --indent-guide-color: var(--sl-color-neutral-200);
    --indent-guide-offset: 0;
    --indent-guide-style: solid;
    --indent-guide-width: 0;
    --indent-size: var(--sl-spacing-large);

    display: block;

    /*
     * Tree item indentation uses the "em" unit to increment its width on each level, so setting the font size to zero
     * here removes the indentation for all the nodes on the first level.
     */
    font-size: 0;
  }
`;

// src/internal/math.ts
function clamp(value, min, max) {
  const noNegativeZero = n => Object.is(n, -0) ? 0 : n;
  if (value < min) {
    return noNegativeZero(min);
  }
  if (value > max) {
    return noNegativeZero(max);
  }
  return noNegativeZero(value);
}

function syncCheckboxes(changedTreeItem, initialSync = false) {
  function syncParentItem(treeItem) {
    const children = treeItem.getChildrenItems({
      includeDisabled: false
    });
    if (children.length) {
      const allChecked = children.every(item => item.selected);
      const allUnchecked = children.every(item => !item.selected && !item.indeterminate);
      treeItem.selected = allChecked;
      treeItem.indeterminate = !allChecked && !allUnchecked;
    }
  }
  function syncAncestors(treeItem) {
    const parentItem = treeItem.parentElement;
    if (SlTreeItem.isTreeItem(parentItem)) {
      syncParentItem(parentItem);
      syncAncestors(parentItem);
    }
  }
  function syncDescendants(treeItem) {
    for (const childItem of treeItem.getChildrenItems()) {
      childItem.selected = initialSync ? treeItem.selected || childItem.selected : !childItem.disabled && treeItem.selected;
      syncDescendants(childItem);
    }
    if (initialSync) {
      syncParentItem(treeItem);
    }
  }
  syncDescendants(changedTreeItem);
  syncAncestors(changedTreeItem);
}
var SlTree = class extends ShoelaceElement {
  constructor() {
    super();
    this.selection = "single";
    this.clickTarget = null;
    this.localize = new LocalizeController(this);
    // Initializes new items by setting the `selectable` property and the expanded/collapsed icons if any
    this.initTreeItem = item => {
      item.selectable = this.selection === "multiple";
      ["expand", "collapse"].filter(status => !!this.querySelector(`[slot="${status}-icon"]`)).forEach(status => {
        const existingIcon = item.querySelector(`[slot="${status}-icon"]`);
        const expandButtonIcon = this.getExpandButtonIcon(status);
        if (!expandButtonIcon) return;
        if (existingIcon === null) {
          item.append(expandButtonIcon);
        } else if (existingIcon.hasAttribute("data-default")) {
          existingIcon.replaceWith(expandButtonIcon);
        } else ;
      });
    };
    this.handleTreeChanged = mutations => {
      for (const mutation of mutations) {
        const addedNodes = [...mutation.addedNodes].filter(SlTreeItem.isTreeItem);
        const removedNodes = [...mutation.removedNodes].filter(SlTreeItem.isTreeItem);
        addedNodes.forEach(this.initTreeItem);
        if (this.lastFocusedItem && removedNodes.includes(this.lastFocusedItem)) {
          this.lastFocusedItem = null;
        }
      }
    };
    this.handleFocusOut = event => {
      const relatedTarget = event.relatedTarget;
      if (!relatedTarget || !this.contains(relatedTarget)) {
        this.tabIndex = 0;
      }
    };
    this.handleFocusIn = event => {
      const target = event.target;
      if (event.target === this) {
        this.focusItem(this.lastFocusedItem || this.getAllTreeItems()[0]);
      }
      if (SlTreeItem.isTreeItem(target) && !target.disabled) {
        if (this.lastFocusedItem) {
          this.lastFocusedItem.tabIndex = -1;
        }
        this.lastFocusedItem = target;
        this.tabIndex = -1;
        target.tabIndex = 0;
      }
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
    this.addEventListener("sl-lazy-change", this.handleSlotChange);
  }
  async connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tree");
    this.setAttribute("tabindex", "0");
    await this.updateComplete;
    this.mutationObserver = new MutationObserver(this.handleTreeChanged);
    this.mutationObserver.observe(this, {
      childList: true,
      subtree: true
    });
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
  }
  // Generates a clone of the expand icon element to use for each tree item
  getExpandButtonIcon(status) {
    const slot = status === "expand" ? this.expandedIconSlot : this.collapsedIconSlot;
    const icon = slot.assignedElements({
      flatten: true
    })[0];
    if (icon) {
      const clone = icon.cloneNode(true);
      [clone, ...clone.querySelectorAll("[id]")].forEach(el => el.removeAttribute("id"));
      clone.setAttribute("data-default", "");
      clone.slot = `${status}-icon`;
      return clone;
    }
    return null;
  }
  selectItem(selectedItem) {
    const previousSelection = [...this.selectedItems];
    if (this.selection === "multiple") {
      selectedItem.selected = !selectedItem.selected;
      if (selectedItem.lazy) {
        selectedItem.expanded = true;
      }
      syncCheckboxes(selectedItem);
    } else if (this.selection === "single" || selectedItem.isLeaf) {
      const items = this.getAllTreeItems();
      for (const item of items) {
        item.selected = item === selectedItem;
      }
    } else if (this.selection === "leaf") {
      selectedItem.expanded = !selectedItem.expanded;
    }
    const nextSelection = this.selectedItems;
    if (previousSelection.length !== nextSelection.length || nextSelection.some(item => !previousSelection.includes(item))) {
      Promise.all(nextSelection.map(el => el.updateComplete)).then(() => {
        this.emit("sl-selection-change", {
          detail: {
            selection: nextSelection
          }
        });
      });
    }
  }
  getAllTreeItems() {
    return [...this.querySelectorAll("sl-tree-item")];
  }
  focusItem(item) {
    item == null ? void 0 : item.focus();
  }
  handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowRight", "ArrowLeft", "Home", "End", "Enter", " "].includes(event.key)) {
      return;
    }
    if (event.composedPath().some(el => {
      var _a;
      return ["input", "textarea"].includes((_a = el == null ? void 0 : el.tagName) == null ? void 0 : _a.toLowerCase());
    })) {
      return;
    }
    const items = this.getFocusableItems();
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (items.length > 0) {
      event.preventDefault();
      const activeItemIndex = items.findIndex(item => item.matches(":focus"));
      const activeItem = items[activeItemIndex];
      const focusItemAt = index => {
        const item = items[clamp(index, 0, items.length - 1)];
        this.focusItem(item);
      };
      const toggleExpand = expanded => {
        activeItem.expanded = expanded;
      };
      if (event.key === "ArrowDown") {
        focusItemAt(activeItemIndex + 1);
      } else if (event.key === "ArrowUp") {
        focusItemAt(activeItemIndex - 1);
      } else if (isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
        if (!activeItem || activeItem.disabled || activeItem.expanded || activeItem.isLeaf && !activeItem.lazy) {
          focusItemAt(activeItemIndex + 1);
        } else {
          toggleExpand(true);
        }
      } else if (isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
        if (!activeItem || activeItem.disabled || activeItem.isLeaf || !activeItem.expanded) {
          focusItemAt(activeItemIndex - 1);
        } else {
          toggleExpand(false);
        }
      } else if (event.key === "Home") {
        focusItemAt(0);
      } else if (event.key === "End") {
        focusItemAt(items.length - 1);
      } else if (event.key === "Enter" || event.key === " ") {
        if (!activeItem.disabled) {
          this.selectItem(activeItem);
        }
      }
    }
  }
  handleClick(event) {
    const target = event.target;
    const treeItem = target.closest("sl-tree-item");
    const isExpandButton = event.composedPath().some(el => {
      var _a;
      return (_a = el == null ? void 0 : el.classList) == null ? void 0 : _a.contains("tree-item__expand-button");
    });
    if (!treeItem || treeItem.disabled || target !== this.clickTarget) {
      return;
    }
    if (isExpandButton) {
      treeItem.expanded = !treeItem.expanded;
    } else {
      this.selectItem(treeItem);
    }
  }
  handleMouseDown(event) {
    this.clickTarget = event.target;
  }
  handleSlotChange() {
    const items = this.getAllTreeItems();
    items.forEach(this.initTreeItem);
  }
  async handleSelectionChange() {
    const isSelectionMultiple = this.selection === "multiple";
    const items = this.getAllTreeItems();
    this.setAttribute("aria-multiselectable", isSelectionMultiple ? "true" : "false");
    for (const item of items) {
      item.selectable = isSelectionMultiple;
    }
    if (isSelectionMultiple) {
      await this.updateComplete;
      [...this.querySelectorAll(":scope > sl-tree-item")].forEach(treeItem => syncCheckboxes(treeItem, true));
    }
  }
  /** @internal Returns the list of tree items that are selected in the tree. */
  get selectedItems() {
    const items = this.getAllTreeItems();
    const isSelected = item => item.selected;
    return items.filter(isSelected);
  }
  /** @internal Gets focusable tree items in the tree. */
  getFocusableItems() {
    const items = this.getAllTreeItems();
    const collapsedItems = /* @__PURE__ */new Set();
    return items.filter(item => {
      var _a;
      if (item.disabled) return false;
      const parent = (_a = item.parentElement) == null ? void 0 : _a.closest("[role=treeitem]");
      if (parent && (!parent.expanded || parent.loading || collapsedItems.has(parent))) {
        collapsedItems.add(item);
      }
      return !collapsedItems.has(item);
    });
  }
  render() {
    return x`
      <div
        part="base"
        class="tree"
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
        <span hidden aria-hidden="true"><slot name="expand-icon"></slot></span>
        <span hidden aria-hidden="true"><slot name="collapse-icon"></slot></span>
      </div>
    `;
  }
};
SlTree.styles = [component_styles_default, tree_styles_default];
__decorateClass([e$7("slot:not([name])")], SlTree.prototype, "defaultSlot", 2);
__decorateClass([e$7("slot[name=expand-icon]")], SlTree.prototype, "expandedIconSlot", 2);
__decorateClass([e$7("slot[name=collapse-icon]")], SlTree.prototype, "collapsedIconSlot", 2);
__decorateClass([n$6()], SlTree.prototype, "selection", 2);
__decorateClass([watch("selection")], SlTree.prototype, "handleSelectionChange", 1);

var tagName$N = "sl-tree";
SlTree.define("sl-tree");
o$8({
  tagName: tagName$N,
  elementClass: SlTree,
  react: React$1,
  events: {
    onSlSelectionChange: "sl-selection-change"
  },
  displayName: "SlTree"
});

// src/components/rating/rating.styles.ts
var rating_styles_default = i$7`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$2 = "important",
  i = " !" + n$2,
  o$5 = e$4(class extends i$3 {
    constructor(t$1) {
      if (super(t$1), t$1.type !== t.ATTRIBUTE || "style" !== t$1.name || t$1.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
    }
    render(t) {
      return Object.keys(t).reduce((e, r) => {
        const s = t[r];
        return null == s ? e : e + `${r = r.includes("-") ? r : r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
      }, "");
    }
    update(e, [r]) {
      const {
        style: s
      } = e.element;
      if (void 0 === this.ft) return this.ft = new Set(Object.keys(r)), this.render(r);
      for (const t of this.ft) null == r[t] && (this.ft.delete(t), t.includes("-") ? s.removeProperty(t) : s[t] = null);
      for (const t in r) {
        const e = r[t];
        if (null != e) {
          this.ft.add(t);
          const r = "string" == typeof e && e.endsWith(i);
          t.includes("-") || r ? s.setProperty(t, r ? e.slice(0, -11) : e, r ? n$2 : "") : s[t] = e;
        }
      }
      return T;
    }
  });

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$1 = class e extends i$3 {
  constructor(i) {
    if (super(i), this.it = E, i.type !== t.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r) {
    if (r === E || null == r) return this._t = void 0, this.it = r;
    if (r === T) return r;
    if ("string" != typeof r) throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r === this.it) return this._t;
    this.it = r;
    const s = [r];
    return s.raw = s, this._t = {
      _$litType$: this.constructor.resultType,
      strings: s,
      values: []
    };
  }
};
e$1.directiveName = "unsafeHTML", e$1.resultType = 1;
const o$4 = e$4(e$1);

var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.hoverValue = 0;
    this.isHovering = false;
    this.label = "";
    this.value = 0;
    this.max = 5;
    this.precision = 1;
    this.readonly = false;
    this.disabled = false;
    this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(event) {
    return this.getValueFromXCoordinate(event.clientX);
  }
  getValueFromTouchPosition(event) {
    return this.getValueFromXCoordinate(event.touches[0].clientX);
  }
  getValueFromXCoordinate(coordinate) {
    const isRtl = this.localize.dir() === "rtl";
    const {
      left,
      right,
      width
    } = this.rating.getBoundingClientRect();
    const value = isRtl ? this.roundToPrecision((right - coordinate) / width * this.max, this.precision) : this.roundToPrecision((coordinate - left) / width * this.max, this.precision);
    return clamp(value, 0, this.max);
  }
  handleClick(event) {
    if (this.disabled) {
      return;
    }
    this.setValue(this.getValueFromMousePosition(event));
    this.emit("sl-change");
  }
  setValue(newValue) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.value = newValue === this.value ? 0 : newValue;
    this.isHovering = false;
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    const oldValue = this.value;
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.key === "ArrowDown" || isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
      const decrement = event.shiftKey ? 1 : this.precision;
      this.value = Math.max(0, this.value - decrement);
      event.preventDefault();
    }
    if (event.key === "ArrowUp" || isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
      const increment = event.shiftKey ? 1 : this.precision;
      this.value = Math.min(this.max, this.value + increment);
      event.preventDefault();
    }
    if (event.key === "Home") {
      this.value = 0;
      event.preventDefault();
    }
    if (event.key === "End") {
      this.value = this.max;
      event.preventDefault();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
    }
  }
  handleMouseEnter(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseMove(event) {
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseLeave() {
    this.isHovering = false;
  }
  handleTouchStart(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromTouchPosition(event);
    event.preventDefault();
  }
  handleTouchMove(event) {
    this.hoverValue = this.getValueFromTouchPosition(event);
  }
  handleTouchEnd(event) {
    this.isHovering = false;
    this.setValue(this.hoverValue);
    this.emit("sl-change");
    event.preventDefault();
  }
  roundToPrecision(numberToRound, precision = 0.5) {
    const multiplier = 1 / precision;
    return Math.ceil(numberToRound * multiplier) / multiplier;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue
      }
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue
      }
    });
  }
  /** Sets focus on the rating. */
  focus(options) {
    this.rating.focus(options);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const counter = Array.from(Array(this.max).keys());
    let displayValue = 0;
    if (this.disabled || this.readonly) {
      displayValue = this.value;
    } else {
      displayValue = this.isHovering ? this.hoverValue : this.value;
    }
    return x`
      <div
        part="base"
        class=${e$3({
      rating: true,
      "rating--readonly": this.readonly,
      "rating--disabled": this.disabled,
      "rating--rtl": isRtl
    })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled || this.readonly ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${counter.map(index => {
      if (displayValue > index && displayValue < index + 1) {
        return x`
                <span
                  class=${e$3({
          rating__symbol: true,
          "rating__partial-symbol-container": true,
          "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1
        })}
                  role="presentation"
                >
                  <div
                    style=${o$5({
          clipPath: isRtl ? `inset(0 ${(displayValue - index) * 100}% 0 0)` : `inset(0 0 0 ${(displayValue - index) * 100}%)`
        })}
                  >
                    ${o$4(this.getSymbol(index + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${o$5({
          clipPath: isRtl ? `inset(0 0 0 ${100 - (displayValue - index) * 100}%)` : `inset(0 ${100 - (displayValue - index) * 100}% 0 0)`
        })}
                  >
                    ${o$4(this.getSymbol(index + 1))}
                  </div>
                </span>
              `;
      }
      return x`
              <span
                class=${e$3({
        rating__symbol: true,
        "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1,
        "rating__symbol--active": displayValue >= index + 1
      })}
                role="presentation"
              >
                ${o$4(this.getSymbol(index + 1))}
              </span>
            `;
    })}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".rating")], SlRating.prototype, "rating", 2);
__decorateClass([r$3()], SlRating.prototype, "hoverValue", 2);
__decorateClass([r$3()], SlRating.prototype, "isHovering", 2);
__decorateClass([n$6()], SlRating.prototype, "label", 2);
__decorateClass([n$6({
  type: Number
})], SlRating.prototype, "value", 2);
__decorateClass([n$6({
  type: Number
})], SlRating.prototype, "max", 2);
__decorateClass([n$6({
  type: Number
})], SlRating.prototype, "precision", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRating.prototype, "readonly", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRating.prototype, "disabled", 2);
__decorateClass([n$6()], SlRating.prototype, "getSymbol", 2);
__decorateClass([t$2({
  passive: true
})], SlRating.prototype, "handleTouchMove", 1);
__decorateClass([watch("hoverValue")], SlRating.prototype, "handleHoverValueChange", 1);
__decorateClass([watch("isHovering")], SlRating.prototype, "handleIsHoveringChange", 1);

var tagName$M = "sl-rating";
SlRating.define("sl-rating");
o$8({
  tagName: tagName$M,
  elementClass: SlRating,
  react: React$1,
  events: {
    onSlChange: "sl-change",
    onSlHover: "sl-hover"
  },
  displayName: "SlRating"
});

var availableUnits = [{
  max: 276e4,
  value: 6e4,
  unit: "minute"
},
// max 46 minutes
{
  max: 72e6,
  value: 36e5,
  unit: "hour"
},
// max 20 hours
{
  max: 5184e5,
  value: 864e5,
  unit: "day"
},
// max 6 days
{
  max: 24192e5,
  value: 6048e5,
  unit: "week"
},
// max 28 days
{
  max: 28512e6,
  value: 2592e6,
  unit: "month"
},
// max 11 months
{
  max: Infinity,
  value: 31536e6,
  unit: "year"
}];
var SlRelativeTime = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.isoTime = "";
    this.relativeTime = "";
    this.date = /* @__PURE__ */new Date();
    this.format = "long";
    this.numeric = "auto";
    this.sync = false;
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.updateTimeout);
  }
  render() {
    const now = /* @__PURE__ */new Date();
    const then = new Date(this.date);
    if (isNaN(then.getMilliseconds())) {
      this.relativeTime = "";
      this.isoTime = "";
      return "";
    }
    const diff = then.getTime() - now.getTime();
    const {
      unit,
      value
    } = availableUnits.find(singleUnit => Math.abs(diff) < singleUnit.max);
    this.isoTime = then.toISOString();
    this.relativeTime = this.localize.relativeTime(Math.round(diff / value), unit, {
      numeric: this.numeric,
      style: this.format
    });
    clearTimeout(this.updateTimeout);
    if (this.sync) {
      let nextInterval;
      if (unit === "minute") {
        nextInterval = getTimeUntilNextUnit("second");
      } else if (unit === "hour") {
        nextInterval = getTimeUntilNextUnit("minute");
      } else if (unit === "day") {
        nextInterval = getTimeUntilNextUnit("hour");
      } else {
        nextInterval = getTimeUntilNextUnit("day");
      }
      this.updateTimeout = window.setTimeout(() => this.requestUpdate(), nextInterval);
    }
    return x` <time datetime=${this.isoTime}>${this.relativeTime}</time> `;
  }
};
__decorateClass([r$3()], SlRelativeTime.prototype, "isoTime", 2);
__decorateClass([r$3()], SlRelativeTime.prototype, "relativeTime", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "date", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "format", 2);
__decorateClass([n$6()], SlRelativeTime.prototype, "numeric", 2);
__decorateClass([n$6({
  type: Boolean
})], SlRelativeTime.prototype, "sync", 2);
function getTimeUntilNextUnit(unit) {
  const units = {
    second: 1e3,
    minute: 6e4,
    hour: 36e5,
    day: 864e5
  };
  const value = units[unit];
  return value - Date.now() % value;
}

var tagName$L = "sl-relative-time";
SlRelativeTime.define("sl-relative-time");
o$8({
  tagName: tagName$L,
  elementClass: SlRelativeTime,
  react: React$1,
  events: {},
  displayName: "SlRelativeTime"
});

var tagName$K = "sl-resize-observer";
SlResizeObserver.define("sl-resize-observer");
o$8({
  tagName: tagName$K,
  elementClass: SlResizeObserver,
  react: React$1,
  events: {
    onSlResize: "sl-resize"
  },
  displayName: "SlResizeObserver"
});

// src/components/select/select.styles.ts
var select_styles_default = i$7`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix and Suffix */
  .select__prefix,
  .select__suffix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-small);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    display: block;
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-2x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.valueHasChanged = false;
    this.name = "";
    this._value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = option => {
      return x`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${event => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = event => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = event => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({
          preventScroll: true
        });
      }
      if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          this.valueHasChanged = true;
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({
              preventScroll: true
            });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1) newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0) newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key && event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = event => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  get value() {
    return this._value;
  }
  set value(val) {
    if (this.multiple) {
      val = Array.isArray(val) ? val : val.split(" ");
    } else {
      val = Array.isArray(val) ? val.join(" ") : val;
    }
    if (this._value === val) {
      return;
    }
    this.valueHasChanged = true;
    this._value = val;
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    setTimeout(() => {
      this.handleDefaultSlotChange();
    });
    this.open = false;
  }
  addOpenListeners() {
    var _a;
    document.addEventListener("focusin", this.handleDocumentFocusIn);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn);
    }
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({
            preventScroll: true
          });
        }
      };
    }
  }
  removeOpenListeners() {
    var _a;
    document.removeEventListener("focusin", this.handleDocumentFocusIn);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    if (this.getRootNode() !== document) {
      this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn);
    }
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path = event.composedPath();
    const isIconButton = path.some(el => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({
      preventScroll: true
    });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    this.valueHasChanged = true;
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({
        preventScroll: true
      });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      this.valueHasChanged = true;
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({
        preventScroll: true
      }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({
          preventScroll: true
        });
      }
    }
  }
  /* @internal - used by options to update labels */
  handleDefaultSlotChange() {
    if (!customElements.get("sl-option")) {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
    const allOptions = this.getAllOptions();
    const val = this.valueHasChanged ? this.value : this.defaultValue;
    const value = Array.isArray(val) ? val : [val];
    const values = [];
    allOptions.forEach(option => values.push(option.value));
    this.setSelectedOptions(allOptions.filter(el => value.includes(el.value)));
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    this.valueHasChanged = true;
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach(el => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach(el => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach(el => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a, _b, _c;
    const options = this.getAllOptions();
    this.selectedOptions = options.filter(el => el.selected);
    const cachedValueHasChanged = this.valueHasChanged;
    if (this.multiple) {
      this.value = this.selectedOptions.map(el => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      const selectedOption = this.selectedOptions[0];
      this.value = (_a = selectedOption == null ? void 0 : selectedOption.value) != null ? _a : "";
      this.displayLabel = (_c = (_b = selectedOption == null ? void 0 : selectedOption.getTextLabel) == null ? void 0 : _b.call(selectedOption)) != null ? _c : "";
    }
    this.valueHasChanged = cachedValueHasChanged;
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index) => {
      if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag = this.getTag(option, index);
        return x`<div @sl-remove=${e => this.handleTagRemove(e, option)}>
          ${typeof tag === "string" ? o$4(tag) : tag}
        </div>`;
      } else if (index === this.maxOptionsVisible) {
        return x`<sl-tag size=${this.size}>+${this.selectedOptions.length - index}</sl-tag>`;
      }
      return x``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);
    if (name === "value") {
      const cachedValueHasChanged = this.valueHasChanged;
      this.value = this.defaultValue;
      this.valueHasChanged = cachedValueHasChanged;
    }
  }
  handleValueChange() {
    if (!this.valueHasChanged) {
      const cachedValueHasChanged = this.valueHasChanged;
      this.value = this.defaultValue;
      this.valueHasChanged = cachedValueHasChanged;
    }
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter(el => value.includes(el.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const {
        keyframes,
        options
      } = getAnimation(this, "select.show", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const {
        keyframes,
        options
      } = getAnimation(this, "select.hide", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value && this.value.length <= 0;
    return x`
      <div
        part="form-control"
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e$3({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? x`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? x`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="suffix" part="suffix" class="select__suffix"></slot>

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass([e$7(".select")], SlSelect.prototype, "popup", 2);
__decorateClass([e$7(".select__combobox")], SlSelect.prototype, "combobox", 2);
__decorateClass([e$7(".select__display-input")], SlSelect.prototype, "displayInput", 2);
__decorateClass([e$7(".select__value-input")], SlSelect.prototype, "valueInput", 2);
__decorateClass([e$7(".select__listbox")], SlSelect.prototype, "listbox", 2);
__decorateClass([r$3()], SlSelect.prototype, "hasFocus", 2);
__decorateClass([r$3()], SlSelect.prototype, "displayLabel", 2);
__decorateClass([r$3()], SlSelect.prototype, "currentOption", 2);
__decorateClass([r$3()], SlSelect.prototype, "selectedOptions", 2);
__decorateClass([r$3()], SlSelect.prototype, "valueHasChanged", 2);
__decorateClass([n$6()], SlSelect.prototype, "name", 2);
__decorateClass([r$3()], SlSelect.prototype, "value", 1);
__decorateClass([n$6({
  attribute: "value"
})], SlSelect.prototype, "defaultValue", 2);
__decorateClass([n$6({
  reflect: true
})], SlSelect.prototype, "size", 2);
__decorateClass([n$6()], SlSelect.prototype, "placeholder", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "multiple", 2);
__decorateClass([n$6({
  attribute: "max-options-visible",
  type: Number
})], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean
})], SlSelect.prototype, "clearable", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "open", 2);
__decorateClass([n$6({
  type: Boolean
})], SlSelect.prototype, "hoist", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "filled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "pill", 2);
__decorateClass([n$6()], SlSelect.prototype, "label", 2);
__decorateClass([n$6({
  reflect: true
})], SlSelect.prototype, "placement", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlSelect.prototype, "helpText", 2);
__decorateClass([n$6({
  reflect: true
})], SlSelect.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSelect.prototype, "required", 2);
__decorateClass([n$6()], SlSelect.prototype, "getTag", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass([watch(["defaultValue", "value"], {
  waitUntilFirstUpdate: true
})], SlSelect.prototype, "handleValueChange", 1);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [{
    opacity: 0,
    scale: 0.9
  }, {
    opacity: 1,
    scale: 1
  }],
  options: {
    duration: 100,
    easing: "ease"
  }
});
setDefaultAnimation("select.hide", {
  keyframes: [{
    opacity: 1,
    scale: 1
  }, {
    opacity: 0,
    scale: 0.9
  }],
  options: {
    duration: 100,
    easing: "ease"
  }
});

var tagName$J = "sl-select";
SlSelect.define("sl-select");
o$8({
  tagName: tagName$J,
  elementClass: SlSelect,
  react: React$1,
  events: {
    onSlChange: "sl-change",
    onSlClear: "sl-clear",
    onSlInput: "sl-input",
    onSlFocus: "sl-focus",
    onSlBlur: "sl-blur",
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlSelect"
});

var tagName$I = "sl-spinner";
SlSpinner.define("sl-spinner");
o$8({
  tagName: tagName$I,
  elementClass: SlSpinner,
  react: React$1,
  events: {},
  displayName: "SlSpinner"
});

// src/components/skeleton/skeleton.styles.ts
var skeleton_styles_default = i$7`
  :host {
    --border-radius: var(--sl-border-radius-pill);
    --color: var(--sl-color-neutral-200);
    --sheen-color: var(--sl-color-neutral-300);

    display: block;
    position: relative;
  }

  .skeleton {
    display: flex;
    width: 100%;
    height: 100%;
    min-height: 1rem;
  }

  .skeleton__indicator {
    flex: 1 1 auto;
    background: var(--color);
    border-radius: var(--border-radius);
  }

  .skeleton--sheen .skeleton__indicator {
    background: linear-gradient(270deg, var(--sheen-color), var(--color), var(--color), var(--sheen-color));
    background-size: 400% 100%;
    animation: sheen 8s ease-in-out infinite;
  }

  .skeleton--pulse .skeleton__indicator {
    animation: pulse 2s ease-in-out 0.5s infinite;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    :host {
      --color: GrayText;
    }
  }

  @keyframes sheen {
    0% {
      background-position: 200% 0;
    }
    to {
      background-position: -200% 0;
    }
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }
    50% {
      opacity: 0.4;
    }
    100% {
      opacity: 1;
    }
  }
`;

var SlSkeleton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.effect = "none";
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      skeleton: true,
      "skeleton--pulse": this.effect === "pulse",
      "skeleton--sheen": this.effect === "sheen"
    })}
      >
        <div part="indicator" class="skeleton__indicator"></div>
      </div>
    `;
  }
};
SlSkeleton.styles = [component_styles_default, skeleton_styles_default];
__decorateClass([n$6()], SlSkeleton.prototype, "effect", 2);

var tagName$H = "sl-skeleton";
SlSkeleton.define("sl-skeleton");
o$8({
  tagName: tagName$H,
  elementClass: SlSkeleton,
  react: React$1,
  events: {},
  displayName: "SlSkeleton"
});

// src/components/switch/switch.styles.ts
var switch_styles_default = i$7`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`;

var SlSwitch = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: control => control.checked ? control.value || "on" : void 0,
      defaultValue: control => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleClick() {
    this.checked = !this.checked;
    this.emit("sl-change");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleKeyDown(event) {
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.checked = false;
      this.emit("sl-change");
      this.emit("sl-input");
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.checked = true;
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleCheckedChange() {
    this.input.checked = this.checked;
    this.formControlController.updateValidity();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(true);
  }
  /** Simulates a click on the switch. */
  click() {
    this.input.click();
  }
  /** Sets focus on the switch. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the switch. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x`
      <div
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${e$3({
      switch: true,
      "switch--checked": this.checked,
      "switch--disabled": this.disabled,
      "switch--focused": this.hasFocus,
      "switch--small": this.size === "small",
      "switch--medium": this.size === "medium",
      "switch--large": this.size === "large"
    })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o$6(this.value)}
            .checked=${l(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSwitch.styles = [component_styles_default, form_control_styles_default, switch_styles_default];
__decorateClass([e$7('input[type="checkbox"]')], SlSwitch.prototype, "input", 2);
__decorateClass([r$3()], SlSwitch.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlSwitch.prototype, "title", 2);
__decorateClass([n$6()], SlSwitch.prototype, "name", 2);
__decorateClass([n$6()], SlSwitch.prototype, "value", 2);
__decorateClass([n$6({
  reflect: true
})], SlSwitch.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSwitch.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSwitch.prototype, "checked", 2);
__decorateClass([defaultValue("checked")], SlSwitch.prototype, "defaultChecked", 2);
__decorateClass([n$6({
  reflect: true
})], SlSwitch.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSwitch.prototype, "required", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlSwitch.prototype, "helpText", 2);
__decorateClass([watch("checked", {
  waitUntilFirstUpdate: true
})], SlSwitch.prototype, "handleCheckedChange", 1);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlSwitch.prototype, "handleDisabledChange", 1);

var tagName$G = "sl-switch";
SlSwitch.define("sl-switch");
o$8({
  tagName: tagName$G,
  elementClass: SlSwitch,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlInput: "sl-input",
    onSlFocus: "sl-focus",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlSwitch"
});

// src/components/split-panel/split-panel.styles.ts
var split_panel_styles_default = i$7`
  :host {
    --divider-width: 4px;
    --divider-hit-area: 12px;
    --min: 0%;
    --max: 100%;

    display: grid;
  }

  .start,
  .end {
    overflow: hidden;
  }

  .divider {
    flex: 0 0 var(--divider-width);
    display: flex;
    position: relative;
    align-items: center;
    justify-content: center;
    background-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-900);
    z-index: 1;
  }

  .divider:focus {
    outline: none;
  }

  :host(:not([disabled])) .divider:focus-visible {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  :host([disabled]) .divider {
    cursor: not-allowed;
  }

  /* Horizontal */
  :host(:not([vertical], [disabled])) .divider {
    cursor: col-resize;
  }

  :host(:not([vertical])) .divider::after {
    display: flex;
    content: '';
    position: absolute;
    height: 100%;
    left: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    width: var(--divider-hit-area);
  }

  /* Vertical */
  :host([vertical]) {
    flex-direction: column;
  }

  :host([vertical]:not([disabled])) .divider {
    cursor: row-resize;
  }

  :host([vertical]) .divider::after {
    content: '';
    position: absolute;
    width: 100%;
    top: calc(var(--divider-hit-area) / -2 + var(--divider-width) / 2);
    height: var(--divider-hit-area);
  }

  @media (forced-colors: active) {
    .divider {
      outline: solid 1px transparent;
    }
  }
`;

// src/internal/drag.ts
function drag(container, options) {
  function move(pointerEvent) {
    const dims = container.getBoundingClientRect();
    const defaultView = container.ownerDocument.defaultView;
    const offsetX = dims.left + defaultView.scrollX;
    const offsetY = dims.top + defaultView.scrollY;
    const x = pointerEvent.pageX - offsetX;
    const y = pointerEvent.pageY - offsetY;
    if (options == null ? void 0 : options.onMove) {
      options.onMove(x, y);
    }
  }
  function stop() {
    document.removeEventListener("pointermove", move);
    document.removeEventListener("pointerup", stop);
    if (options == null ? void 0 : options.onStop) {
      options.onStop();
    }
  }
  document.addEventListener("pointermove", move, {
    passive: true
  });
  document.addEventListener("pointerup", stop);
  if ((options == null ? void 0 : options.initialEvent) instanceof PointerEvent) {
    move(options.initialEvent);
  }
}

var SNAP_NONE = () => null;
var SlSplitPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.isCollapsed = false;
    this.localize = new LocalizeController(this);
    this.positionBeforeCollapsing = 0;
    this.position = 50;
    this.vertical = false;
    this.disabled = false;
    // Returned when the property is queried, so that string 'snap's are preserved.
    this.snapValue = "";
    // Actually used for computing snap points. All string snaps are converted via `toSnapFunction`.
    this.snapFunction = SNAP_NONE;
    this.snapThreshold = 12;
  }
  /**
   * Converts a string containing either a series of fixed/repeated snap points (e.g. "repeat(20%)", "100px 200px 800px", or "10% 50% repeat(10px)") into a SnapFunction. `SnapFunction`s take in a `SnapFunctionOpts` and return the position that the split panel should snap to.
   *
   * @param snap - The snap string.
   * @returns a `SnapFunction` representing the snap string's logic.
   */
  toSnapFunction(snap) {
    const snapPoints = snap.split(" ");
    return ({
      pos,
      size,
      snapThreshold,
      isRtl,
      vertical
    }) => {
      let newPos = pos;
      let minDistance = Number.POSITIVE_INFINITY;
      snapPoints.forEach(value => {
        let snapPoint;
        if (value.startsWith("repeat(")) {
          const repeatVal = snap.substring("repeat(".length, snap.length - 1);
          const isPercent = repeatVal.endsWith("%");
          const repeatNum = Number.parseFloat(repeatVal);
          const snapIntervalPx = isPercent ? size * (repeatNum / 100) : repeatNum;
          snapPoint = Math.round((isRtl && !vertical ? size - pos : pos) / snapIntervalPx) * snapIntervalPx;
        } else if (value.endsWith("%")) {
          snapPoint = size * (Number.parseFloat(value) / 100);
        } else {
          snapPoint = Number.parseFloat(value);
        }
        if (isRtl && !vertical) {
          snapPoint = size - snapPoint;
        }
        const distance = Math.abs(pos - snapPoint);
        if (distance <= snapThreshold && distance < minDistance) {
          newPos = snapPoint;
          minDistance = distance;
        }
      });
      return newPos;
    };
  }
  set snap(snap) {
    this.snapValue = snap != null ? snap : "";
    if (snap) {
      this.snapFunction = typeof snap === "string" ? this.toSnapFunction(snap) : snap;
    } else {
      this.snapFunction = SNAP_NONE;
    }
  }
  get snap() {
    return this.snapValue;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(entries => this.handleResize(entries));
    this.updateComplete.then(() => this.resizeObserver.observe(this));
    this.detectSize();
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this);
  }
  detectSize() {
    const {
      width,
      height
    } = this.getBoundingClientRect();
    this.size = this.vertical ? height : width;
  }
  percentageToPixels(value) {
    return this.size * (value / 100);
  }
  pixelsToPercentage(value) {
    return value / this.size * 100;
  }
  handleDrag(event) {
    const isRtl = this.localize.dir() === "rtl";
    if (this.disabled) {
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    drag(this, {
      onMove: (x, y) => {
        var _a;
        let newPositionInPixels = this.vertical ? y : x;
        if (this.primary === "end") {
          newPositionInPixels = this.size - newPositionInPixels;
        }
        newPositionInPixels = (_a = this.snapFunction({
          pos: newPositionInPixels,
          size: this.size,
          snapThreshold: this.snapThreshold,
          isRtl,
          vertical: this.vertical
        })) != null ? _a : newPositionInPixels;
        this.position = clamp(this.pixelsToPercentage(newPositionInPixels), 0, 100);
      },
      initialEvent: event
    });
  }
  handleKeyDown(event) {
    if (this.disabled) {
      return;
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Enter"].includes(event.key)) {
      let newPosition = this.position;
      const incr = (event.shiftKey ? 10 : 1) * (this.primary === "end" ? -1 : 1);
      event.preventDefault();
      if (event.key === "ArrowLeft" && !this.vertical || event.key === "ArrowUp" && this.vertical) {
        newPosition -= incr;
      }
      if (event.key === "ArrowRight" && !this.vertical || event.key === "ArrowDown" && this.vertical) {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = this.primary === "end" ? 100 : 0;
      }
      if (event.key === "End") {
        newPosition = this.primary === "end" ? 0 : 100;
      }
      if (event.key === "Enter") {
        if (this.isCollapsed) {
          newPosition = this.positionBeforeCollapsing;
          this.isCollapsed = false;
        } else {
          const positionBeforeCollapsing = this.position;
          newPosition = 0;
          requestAnimationFrame(() => {
            this.isCollapsed = true;
            this.positionBeforeCollapsing = positionBeforeCollapsing;
          });
        }
      }
      this.position = clamp(newPosition, 0, 100);
    }
  }
  handleResize(entries) {
    const {
      width,
      height
    } = entries[0].contentRect;
    this.size = this.vertical ? height : width;
    if (isNaN(this.cachedPositionInPixels) || this.position === Infinity) {
      this.cachedPositionInPixels = Number(this.getAttribute("position-in-pixels"));
      this.positionInPixels = Number(this.getAttribute("position-in-pixels"));
      this.position = this.pixelsToPercentage(this.positionInPixels);
    }
    if (this.primary) {
      this.position = this.pixelsToPercentage(this.cachedPositionInPixels);
    }
  }
  handlePositionChange() {
    this.cachedPositionInPixels = this.percentageToPixels(this.position);
    this.isCollapsed = false;
    this.positionBeforeCollapsing = 0;
    this.positionInPixels = this.percentageToPixels(this.position);
    this.emit("sl-reposition");
  }
  handlePositionInPixelsChange() {
    this.position = this.pixelsToPercentage(this.positionInPixels);
  }
  handleVerticalChange() {
    this.detectSize();
  }
  render() {
    const gridTemplate = this.vertical ? "gridTemplateRows" : "gridTemplateColumns";
    const gridTemplateAlt = this.vertical ? "gridTemplateColumns" : "gridTemplateRows";
    const isRtl = this.localize.dir() === "rtl";
    const primary = `
      clamp(
        0%,
        clamp(
          var(--min),
          ${this.position}% - var(--divider-width) / 2,
          var(--max)
        ),
        calc(100% - var(--divider-width))
      )
    `;
    const secondary = "auto";
    if (this.primary === "end") {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] = `${primary} var(--divider-width) ${secondary}`;
      } else {
        this.style[gridTemplate] = `${secondary} var(--divider-width) ${primary}`;
      }
    } else {
      if (isRtl && !this.vertical) {
        this.style[gridTemplate] = `${secondary} var(--divider-width) ${primary}`;
      } else {
        this.style[gridTemplate] = `${primary} var(--divider-width) ${secondary}`;
      }
    }
    this.style[gridTemplateAlt] = "";
    return x`
      <slot name="start" part="panel start" class="start"></slot>

      <div
        part="divider"
        class="divider"
        tabindex=${o$6(this.disabled ? void 0 : "0")}
        role="separator"
        aria-valuenow=${this.position}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label=${this.localize.term("resize")}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleDrag}
        @touchstart=${this.handleDrag}
      >
        <slot name="divider"></slot>
      </div>

      <slot name="end" part="panel end" class="end"></slot>
    `;
  }
};
SlSplitPanel.styles = [component_styles_default, split_panel_styles_default];
__decorateClass([e$7(".divider")], SlSplitPanel.prototype, "divider", 2);
__decorateClass([n$6({
  type: Number,
  reflect: true
})], SlSplitPanel.prototype, "position", 2);
__decorateClass([n$6({
  attribute: "position-in-pixels",
  type: Number
})], SlSplitPanel.prototype, "positionInPixels", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSplitPanel.prototype, "vertical", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlSplitPanel.prototype, "disabled", 2);
__decorateClass([n$6()], SlSplitPanel.prototype, "primary", 2);
__decorateClass([n$6({
  reflect: true
})], SlSplitPanel.prototype, "snap", 1);
__decorateClass([n$6({
  type: Number,
  attribute: "snap-threshold"
})], SlSplitPanel.prototype, "snapThreshold", 2);
__decorateClass([watch("position")], SlSplitPanel.prototype, "handlePositionChange", 1);
__decorateClass([watch("positionInPixels")], SlSplitPanel.prototype, "handlePositionInPixelsChange", 1);
__decorateClass([watch("vertical")], SlSplitPanel.prototype, "handleVerticalChange", 1);

var tagName$F = "sl-split-panel";
SlSplitPanel.define("sl-split-panel");
o$8({
  tagName: tagName$F,
  elementClass: SlSplitPanel,
  react: React$1,
  events: {
    onSlReposition: "sl-reposition"
  },
  displayName: "SlSplitPanel"
});

// src/components/mutation-observer/mutation-observer.styles.ts
var mutation_observer_styles_default = i$7`
  :host {
    display: contents;
  }
`;

var SlMutationObserver = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrOldValue = false;
    this.charData = false;
    this.charDataOldValue = false;
    this.childList = false;
    this.disabled = false;
    this.handleMutation = mutationList => {
      this.emit("sl-mutation", {
        detail: {
          mutationList
        }
      });
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.mutationObserver = new MutationObserver(this.handleMutation);
    if (!this.disabled) {
      this.startObserver();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopObserver();
  }
  startObserver() {
    const observeAttributes = typeof this.attr === "string" && this.attr.length > 0;
    const attributeFilter = observeAttributes && this.attr !== "*" ? this.attr.split(" ") : void 0;
    try {
      this.mutationObserver.observe(this, {
        subtree: true,
        childList: this.childList,
        attributes: observeAttributes,
        attributeFilter,
        attributeOldValue: this.attrOldValue,
        characterData: this.charData,
        characterDataOldValue: this.charDataOldValue
      });
    } catch (e) {}
  }
  stopObserver() {
    this.mutationObserver.disconnect();
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.stopObserver();
    } else {
      this.startObserver();
    }
  }
  handleChange() {
    this.stopObserver();
    this.startObserver();
  }
  render() {
    return x` <slot></slot> `;
  }
};
SlMutationObserver.styles = [component_styles_default, mutation_observer_styles_default];
__decorateClass([n$6({
  reflect: true
})], SlMutationObserver.prototype, "attr", 2);
__decorateClass([n$6({
  attribute: "attr-old-value",
  type: Boolean,
  reflect: true
})], SlMutationObserver.prototype, "attrOldValue", 2);
__decorateClass([n$6({
  attribute: "char-data",
  type: Boolean,
  reflect: true
})], SlMutationObserver.prototype, "charData", 2);
__decorateClass([n$6({
  attribute: "char-data-old-value",
  type: Boolean,
  reflect: true
})], SlMutationObserver.prototype, "charDataOldValue", 2);
__decorateClass([n$6({
  attribute: "child-list",
  type: Boolean,
  reflect: true
})], SlMutationObserver.prototype, "childList", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlMutationObserver.prototype, "disabled", 2);
__decorateClass([watch("disabled")], SlMutationObserver.prototype, "handleDisabledChange", 1);
__decorateClass([watch("attr", {
  waitUntilFirstUpdate: true
}), watch("attr-old-value", {
  waitUntilFirstUpdate: true
}), watch("char-data", {
  waitUntilFirstUpdate: true
}), watch("char-data-old-value", {
  waitUntilFirstUpdate: true
}), watch("childList", {
  waitUntilFirstUpdate: true
})], SlMutationObserver.prototype, "handleChange", 1);

var tagName$E = "sl-mutation-observer";
SlMutationObserver.define("sl-mutation-observer");
o$8({
  tagName: tagName$E,
  elementClass: SlMutationObserver,
  react: React$1,
  events: {
    onSlMutation: "sl-mutation"
  },
  displayName: "SlMutationObserver"
});

// src/components/progress-bar/progress-bar.styles.ts
var progress_bar_styles_default = i$7`
  :host {
    --height: 1rem;
    --track-color: var(--sl-color-neutral-200);
    --indicator-color: var(--sl-color-primary-600);
    --label-color: var(--sl-color-neutral-0);

    display: block;
  }

  .progress-bar {
    position: relative;
    background-color: var(--track-color);
    height: var(--height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset var(--sl-shadow-small);
    overflow: hidden;
  }

  .progress-bar__indicator {
    height: 100%;
    font-family: var(--sl-font-sans);
    font-size: 12px;
    font-weight: var(--sl-font-weight-normal);
    background-color: var(--indicator-color);
    color: var(--label-color);
    text-align: center;
    line-height: var(--height);
    white-space: nowrap;
    overflow: hidden;
    transition:
      400ms width,
      400ms background-color;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Indeterminate */
  .progress-bar--indeterminate .progress-bar__indicator {
    position: absolute;
    animation: indeterminate 2.5s infinite cubic-bezier(0.37, 0, 0.63, 1);
  }

  .progress-bar--indeterminate.progress-bar--rtl .progress-bar__indicator {
    animation-name: indeterminate-rtl;
  }

  @media (forced-colors: active) {
    .progress-bar {
      outline: solid 1px SelectedItem;
      background-color: var(--sl-color-neutral-0);
    }

    .progress-bar__indicator {
      outline: solid 1px SelectedItem;
      background-color: SelectedItem;
    }
  }

  @keyframes indeterminate {
    0% {
      left: -50%;
      width: 50%;
    }
    75%,
    100% {
      left: 100%;
      width: 50%;
    }
  }

  @keyframes indeterminate-rtl {
    0% {
      right: -50%;
      width: 50%;
    }
    75%,
    100% {
      right: 100%;
      width: 50%;
    }
  }
`;

var SlProgressBar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.value = 0;
    this.indeterminate = false;
    this.label = "";
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      "progress-bar": true,
      "progress-bar--indeterminate": this.indeterminate,
      "progress-bar--rtl": this.localize.dir() === "rtl"
    })}
        role="progressbar"
        title=${o$6(this.title)}
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow=${this.indeterminate ? 0 : this.value}
      >
        <div part="indicator" class="progress-bar__indicator" style=${o$5({
      width: `${this.value}%`
    })}>
          ${!this.indeterminate ? x` <slot part="label" class="progress-bar__label"></slot> ` : ""}
        </div>
      </div>
    `;
  }
};
SlProgressBar.styles = [component_styles_default, progress_bar_styles_default];
__decorateClass([n$6({
  type: Number,
  reflect: true
})], SlProgressBar.prototype, "value", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlProgressBar.prototype, "indeterminate", 2);
__decorateClass([n$6()], SlProgressBar.prototype, "label", 2);

var tagName$D = "sl-progress-bar";
SlProgressBar.define("sl-progress-bar");
o$8({
  tagName: tagName$D,
  elementClass: SlProgressBar,
  react: React$1,
  events: {},
  displayName: "SlProgressBar"
});

// src/components/progress-ring/progress-ring.styles.ts
var progress_ring_styles_default = i$7`
  :host {
    --size: 128px;
    --track-width: 4px;
    --track-color: var(--sl-color-neutral-200);
    --indicator-width: var(--track-width);
    --indicator-color: var(--sl-color-primary-600);
    --indicator-transition-duration: 0.35s;

    display: inline-flex;
  }

  .progress-ring {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .progress-ring__image {
    width: var(--size);
    height: var(--size);
    rotate: -90deg;
    transform-origin: 50% 50%;
  }

  .progress-ring__track,
  .progress-ring__indicator {
    --radius: calc(var(--size) / 2 - max(var(--track-width), var(--indicator-width)) * 0.5);
    --circumference: calc(var(--radius) * 2 * 3.141592654);

    fill: none;
    r: var(--radius);
    cx: calc(var(--size) / 2);
    cy: calc(var(--size) / 2);
  }

  .progress-ring__track {
    stroke: var(--track-color);
    stroke-width: var(--track-width);
  }

  .progress-ring__indicator {
    stroke: var(--indicator-color);
    stroke-width: var(--indicator-width);
    stroke-linecap: round;
    transition-property: stroke-dashoffset;
    transition-duration: var(--indicator-transition-duration);
    stroke-dasharray: var(--circumference) var(--circumference);
    stroke-dashoffset: calc(var(--circumference) - var(--percentage) * var(--circumference));
  }

  .progress-ring__label {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    text-align: center;
    user-select: none;
    -webkit-user-select: none;
  }
`;

var SlProgressRing = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.value = 0;
    this.label = "";
  }
  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("value")) {
      const radius = parseFloat(getComputedStyle(this.indicator).getPropertyValue("r"));
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - this.value / 100 * circumference;
      this.indicatorOffset = `${offset}px`;
    }
  }
  render() {
    return x`
      <div
        part="base"
        class="progress-ring"
        role="progressbar"
        aria-label=${this.label.length > 0 ? this.label : this.localize.term("progress")}
        aria-describedby="label"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="${this.value}"
        style="--percentage: ${this.value / 100}"
      >
        <svg class="progress-ring__image">
          <circle class="progress-ring__track"></circle>
          <circle class="progress-ring__indicator" style="stroke-dashoffset: ${this.indicatorOffset}"></circle>
        </svg>

        <slot id="label" part="label" class="progress-ring__label"></slot>
      </div>
    `;
  }
};
SlProgressRing.styles = [component_styles_default, progress_ring_styles_default];
__decorateClass([e$7(".progress-ring__indicator")], SlProgressRing.prototype, "indicator", 2);
__decorateClass([r$3()], SlProgressRing.prototype, "indicatorOffset", 2);
__decorateClass([n$6({
  type: Number,
  reflect: true
})], SlProgressRing.prototype, "value", 2);
__decorateClass([n$6()], SlProgressRing.prototype, "label", 2);

var tagName$C = "sl-progress-ring";
SlProgressRing.define("sl-progress-ring");
o$8({
  tagName: tagName$C,
  elementClass: SlProgressRing,
  react: React$1,
  events: {},
  displayName: "SlProgressRing"
});

// src/components/qr-code/qr-code.styles.ts
var qr_code_styles_default = i$7`
  :host {
    display: inline-block;
  }
`;

/*
 jquery-qrcode v0.14.0 - https://larsjung.de/jquery-qrcode/ */

let G = null;
class H {}
H.render = function (w, B) {
  G(w, B);
};
self.QrCreator = H;
(function (w) {
  function B(t, c, a, e) {
    var b = {},
      h = w(a, c);
    h.u(t);
    h.J();
    e = e || 0;
    var r = h.h(),
      d = h.h() + 2 * e;
    b.text = t;
    b.level = c;
    b.version = a;
    b.O = d;
    b.a = function (b, a) {
      b -= e;
      a -= e;
      return 0 > b || b >= r || 0 > a || a >= r ? false : h.a(b, a);
    };
    return b;
  }
  function C(t, c, a, e, b, h, r, d, g, x) {
    function u(b, a, f, c, d, r, g) {
      b ? (t.lineTo(a + r, f + g), t.arcTo(a, f, c, d, h)) : t.lineTo(a, f);
    }
    r ? t.moveTo(c + h, a) : t.moveTo(c, a);
    u(d, e, a, e, b, -h, 0);
    u(g, e, b, c, b, 0, -h);
    u(x, c, b, c, a, h, 0);
    u(r, c, a, e, a, 0, h);
  }
  function z(t, c, a, e, b, h, r, d, g, x) {
    function u(b, a, c, d) {
      t.moveTo(b + c, a);
      t.lineTo(b, a);
      t.lineTo(b, a + d);
      t.arcTo(b, a, b + c, a, h);
    }
    r && u(c, a, h, h);
    d && u(e, a, -h, h);
    g && u(e, b, -h, -h);
    x && u(c, b, h, -h);
  }
  function A(t, c) {
    var a = c.fill;
    if ("string" === typeof a) t.fillStyle = a;else {
      var e = a.type,
        b = a.colorStops;
      a = a.position.map(b => Math.round(b * c.size));
      if ("linear-gradient" === e) var h = t.createLinearGradient.apply(t, a);else if ("radial-gradient" === e) h = t.createRadialGradient.apply(t, a);else throw Error("Unsupported fill");
      b.forEach(([b, a]) => {
        h.addColorStop(b, a);
      });
      t.fillStyle = h;
    }
  }
  function y(t, c) {
    a: {
      var a = c.text,
        e = c.v,
        b = c.N,
        h = c.K,
        r = c.P;
      b = Math.max(1, b || 1);
      for (h = Math.min(40, h || 40); b <= h; b += 1) try {
        var d = B(a, e, b, r);
        break a;
      } catch (J) {}
      d = void 0;
    }
    if (!d) return null;
    a = t.getContext("2d");
    c.background && (a.fillStyle = c.background, a.fillRect(c.left, c.top, c.size, c.size));
    e = d.O;
    h = c.size / e;
    a.beginPath();
    for (r = 0; r < e; r += 1) for (b = 0; b < e; b += 1) {
      var g = a,
        x = c.left + b * h,
        u = c.top + r * h,
        p = r,
        q = b,
        f = d.a,
        k = x + h,
        m = u + h,
        D = p - 1,
        E = p + 1,
        n = q - 1,
        l = q + 1,
        y = Math.floor(Math.min(.5, Math.max(0, c.R)) * h),
        v = f(p, q),
        I = f(D, n),
        w = f(D, q);
      D = f(D, l);
      var F = f(p, l);
      l = f(E, l);
      q = f(E, q);
      E = f(E, n);
      p = f(p, n);
      x = Math.round(x);
      u = Math.round(u);
      k = Math.round(k);
      m = Math.round(m);
      v ? C(g, x, u, k, m, y, !w && !p, !w && !F, !q && !F, !q && !p) : z(g, x, u, k, m, y, w && p && I, w && F && D, q && F && l, q && p && E);
    }
    A(a, c);
    a.fill();
    return t;
  }
  var v = {
    minVersion: 1,
    maxVersion: 40,
    ecLevel: "L",
    left: 0,
    top: 0,
    size: 200,
    fill: "#000",
    background: null,
    text: "no text",
    radius: .5,
    quiet: 0
  };
  G = function (t, c) {
    var a = {};
    Object.assign(a, v, t);
    a.N = a.minVersion;
    a.K = a.maxVersion;
    a.v = a.ecLevel;
    a.left = a.left;
    a.top = a.top;
    a.size = a.size;
    a.fill = a.fill;
    a.background = a.background;
    a.text = a.text;
    a.R = a.radius;
    a.P = a.quiet;
    if (c instanceof HTMLCanvasElement) {
      if (c.width !== a.size || c.height !== a.size) c.width = a.size, c.height = a.size;
      c.getContext("2d").clearRect(0, 0, c.width, c.height);
      y(c, a);
    } else t = document.createElement("canvas"), t.width = a.size, t.height = a.size, a = y(t, a), c.appendChild(a);
  };
})(function () {
  function w(c) {
    var a = C.s(c);
    return {
      S: function () {
        return 4;
      },
      b: function () {
        return a.length;
      },
      write: function (c) {
        for (var b = 0; b < a.length; b += 1) c.put(a[b], 8);
      }
    };
  }
  function B() {
    var c = [],
      a = 0,
      e = {
        B: function () {
          return c;
        },
        c: function (b) {
          return 1 == (c[Math.floor(b / 8)] >>> 7 - b % 8 & 1);
        },
        put: function (b, h) {
          for (var a = 0; a < h; a += 1) e.m(1 == (b >>> h - a - 1 & 1));
        },
        f: function () {
          return a;
        },
        m: function (b) {
          var h = Math.floor(a / 8);
          c.length <= h && c.push(0);
          b && (c[h] |= 128 >>> a % 8);
          a += 1;
        }
      };
    return e;
  }
  function C(c, a) {
    function e(b, h) {
      for (var a = -1; 7 >= a; a += 1) if (!(-1 >= b + a || d <= b + a)) for (var c = -1; 7 >= c; c += 1) -1 >= h + c || d <= h + c || (r[b + a][h + c] = 0 <= a && 6 >= a && (0 == c || 6 == c) || 0 <= c && 6 >= c && (0 == a || 6 == a) || 2 <= a && 4 >= a && 2 <= c && 4 >= c ? true : false);
    }
    function b(b, a) {
      for (var f = d = 4 * c + 17, k = Array(f), m = 0; m < f; m += 1) {
        k[m] = Array(f);
        for (var p = 0; p < f; p += 1) k[m][p] = null;
      }
      r = k;
      e(0, 0);
      e(d - 7, 0);
      e(0, d - 7);
      f = y.G(c);
      for (k = 0; k < f.length; k += 1) for (m = 0; m < f.length; m += 1) {
        p = f[k];
        var q = f[m];
        if (null == r[p][q]) for (var n = -2; 2 >= n; n += 1) for (var l = -2; 2 >= l; l += 1) r[p + n][q + l] = -2 == n || 2 == n || -2 == l || 2 == l || 0 == n && 0 == l;
      }
      for (f = 8; f < d - 8; f += 1) null == r[f][6] && (r[f][6] = 0 == f % 2);
      for (f = 8; f < d - 8; f += 1) null == r[6][f] && (r[6][f] = 0 == f % 2);
      f = y.w(h << 3 | a);
      for (k = 0; 15 > k; k += 1) m = !b && 1 == (f >> k & 1), r[6 > k ? k : 8 > k ? k + 1 : d - 15 + k][8] = m, r[8][8 > k ? d - k - 1 : 9 > k ? 15 - k : 14 - k] = m;
      r[d - 8][8] = !b;
      if (7 <= c) {
        f = y.A(c);
        for (k = 0; 18 > k; k += 1) m = !b && 1 == (f >> k & 1), r[Math.floor(k / 3)][k % 3 + d - 8 - 3] = m;
        for (k = 0; 18 > k; k += 1) m = !b && 1 == (f >> k & 1), r[k % 3 + d - 8 - 3][Math.floor(k / 3)] = m;
      }
      if (null == g) {
        b = t.I(c, h);
        f = B();
        for (k = 0; k < x.length; k += 1) m = x[k], f.put(4, 4), f.put(m.b(), y.f(4, c)), m.write(f);
        for (k = m = 0; k < b.length; k += 1) m += b[k].j;
        if (f.f() > 8 * m) throw Error("code length overflow. (" + f.f() + ">" + 8 * m + ")");
        for (f.f() + 4 <= 8 * m && f.put(0, 4); 0 != f.f() % 8;) f.m(false);
        for (; !(f.f() >= 8 * m);) {
          f.put(236, 8);
          if (f.f() >= 8 * m) break;
          f.put(17, 8);
        }
        var u = 0;
        m = k = 0;
        p = Array(b.length);
        q = Array(b.length);
        for (n = 0; n < b.length; n += 1) {
          var v = b[n].j,
            w = b[n].o - v;
          k = Math.max(k, v);
          m = Math.max(m, w);
          p[n] = Array(v);
          for (l = 0; l < p[n].length; l += 1) p[n][l] = 255 & f.B()[l + u];
          u += v;
          l = y.C(w);
          v = z(p[n], l.b() - 1).l(l);
          q[n] = Array(l.b() - 1);
          for (l = 0; l < q[n].length; l += 1) w = l + v.b() - q[n].length, q[n][l] = 0 <= w ? v.c(w) : 0;
        }
        for (l = f = 0; l < b.length; l += 1) f += b[l].o;
        f = Array(f);
        for (l = u = 0; l < k; l += 1) for (n = 0; n < b.length; n += 1) l < p[n].length && (f[u] = p[n][l], u += 1);
        for (l = 0; l < m; l += 1) for (n = 0; n < b.length; n += 1) l < q[n].length && (f[u] = q[n][l], u += 1);
        g = f;
      }
      b = g;
      f = -1;
      k = d - 1;
      m = 7;
      p = 0;
      a = y.F(a);
      for (q = d - 1; 0 < q; q -= 2) for (6 == q && --q;;) {
        for (n = 0; 2 > n; n += 1) null == r[k][q - n] && (l = false, p < b.length && (l = 1 == (b[p] >>> m & 1)), a(k, q - n) && (l = !l), r[k][q - n] = l, --m, -1 == m && (p += 1, m = 7));
        k += f;
        if (0 > k || d <= k) {
          k -= f;
          f = -f;
          break;
        }
      }
    }
    var h = A[a],
      r = null,
      d = 0,
      g = null,
      x = [],
      u = {
        u: function (b) {
          b = w(b);
          x.push(b);
          g = null;
        },
        a: function (b, a) {
          if (0 > b || d <= b || 0 > a || d <= a) throw Error(b + "," + a);
          return r[b][a];
        },
        h: function () {
          return d;
        },
        J: function () {
          for (var a = 0, h = 0, c = 0; 8 > c; c += 1) {
            b(true, c);
            var d = y.D(u);
            if (0 == c || a > d) a = d, h = c;
          }
          b(false, h);
        }
      };
    return u;
  }
  function z(c, a) {
    if ("undefined" == typeof c.length) throw Error(c.length + "/" + a);
    var e = function () {
        for (var b = 0; b < c.length && 0 == c[b];) b += 1;
        for (var r = Array(c.length - b + a), d = 0; d < c.length - b; d += 1) r[d] = c[d + b];
        return r;
      }(),
      b = {
        c: function (b) {
          return e[b];
        },
        b: function () {
          return e.length;
        },
        multiply: function (a) {
          for (var h = Array(b.b() + a.b() - 1), c = 0; c < b.b(); c += 1) for (var g = 0; g < a.b(); g += 1) h[c + g] ^= v.i(v.g(b.c(c)) + v.g(a.c(g)));
          return z(h, 0);
        },
        l: function (a) {
          if (0 > b.b() - a.b()) return b;
          for (var c = v.g(b.c(0)) - v.g(a.c(0)), h = Array(b.b()), g = 0; g < b.b(); g += 1) h[g] = b.c(g);
          for (g = 0; g < a.b(); g += 1) h[g] ^= v.i(v.g(a.c(g)) + c);
          return z(h, 0).l(a);
        }
      };
    return b;
  }
  C.s = function (c) {
    for (var a = [], e = 0; e < c.length; e++) {
      var b = c.charCodeAt(e);
      128 > b ? a.push(b) : 2048 > b ? a.push(192 | b >> 6, 128 | b & 63) : 55296 > b || 57344 <= b ? a.push(224 | b >> 12, 128 | b >> 6 & 63, 128 | b & 63) : (e++, b = 65536 + ((b & 1023) << 10 | c.charCodeAt(e) & 1023), a.push(240 | b >> 18, 128 | b >> 12 & 63, 128 | b >> 6 & 63, 128 | b & 63));
    }
    return a;
  };
  var A = {
      L: 1,
      M: 0,
      Q: 3,
      H: 2
    },
    y = function () {
      function c(b) {
        for (var a = 0; 0 != b;) a += 1, b >>>= 1;
        return a;
      }
      var a = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
        e = {
          w: function (b) {
            for (var a = b << 10; 0 <= c(a) - c(1335);) a ^= 1335 << c(a) - c(1335);
            return (b << 10 | a) ^ 21522;
          },
          A: function (b) {
            for (var a = b << 12; 0 <= c(a) - c(7973);) a ^= 7973 << c(a) - c(7973);
            return b << 12 | a;
          },
          G: function (b) {
            return a[b - 1];
          },
          F: function (b) {
            switch (b) {
              case 0:
                return function (b, a) {
                  return 0 == (b + a) % 2;
                };
              case 1:
                return function (b) {
                  return 0 == b % 2;
                };
              case 2:
                return function (b, a) {
                  return 0 == a % 3;
                };
              case 3:
                return function (b, a) {
                  return 0 == (b + a) % 3;
                };
              case 4:
                return function (b, a) {
                  return 0 == (Math.floor(b / 2) + Math.floor(a / 3)) % 2;
                };
              case 5:
                return function (b, a) {
                  return 0 == b * a % 2 + b * a % 3;
                };
              case 6:
                return function (b, a) {
                  return 0 == (b * a % 2 + b * a % 3) % 2;
                };
              case 7:
                return function (b, a) {
                  return 0 == (b * a % 3 + (b + a) % 2) % 2;
                };
              default:
                throw Error("bad maskPattern:" + b);
            }
          },
          C: function (b) {
            for (var a = z([1], 0), c = 0; c < b; c += 1) a = a.multiply(z([1, v.i(c)], 0));
            return a;
          },
          f: function (b, a) {
            if (4 != b || 1 > a || 40 < a) throw Error("mode: " + b + "; type: " + a);
            return 10 > a ? 8 : 16;
          },
          D: function (b) {
            for (var a = b.h(), c = 0, d = 0; d < a; d += 1) for (var g = 0; g < a; g += 1) {
              for (var e = 0, t = b.a(d, g), p = -1; 1 >= p; p += 1) if (!(0 > d + p || a <= d + p)) for (var q = -1; 1 >= q; q += 1) 0 > g + q || a <= g + q || (0 != p || 0 != q) && t == b.a(d + p, g + q) && (e += 1);
              5 < e && (c += 3 + e - 5);
            }
            for (d = 0; d < a - 1; d += 1) for (g = 0; g < a - 1; g += 1) if (e = 0, b.a(d, g) && (e += 1), b.a(d + 1, g) && (e += 1), b.a(d, g + 1) && (e += 1), b.a(d + 1, g + 1) && (e += 1), 0 == e || 4 == e) c += 3;
            for (d = 0; d < a; d += 1) for (g = 0; g < a - 6; g += 1) b.a(d, g) && !b.a(d, g + 1) && b.a(d, g + 2) && b.a(d, g + 3) && b.a(d, g + 4) && !b.a(d, g + 5) && b.a(d, g + 6) && (c += 40);
            for (g = 0; g < a; g += 1) for (d = 0; d < a - 6; d += 1) b.a(d, g) && !b.a(d + 1, g) && b.a(d + 2, g) && b.a(d + 3, g) && b.a(d + 4, g) && !b.a(d + 5, g) && b.a(d + 6, g) && (c += 40);
            for (g = e = 0; g < a; g += 1) for (d = 0; d < a; d += 1) b.a(d, g) && (e += 1);
            return c += Math.abs(100 * e / a / a - 50) / 5 * 10;
          }
        };
      return e;
    }(),
    v = function () {
      for (var c = Array(256), a = Array(256), e = 0; 8 > e; e += 1) c[e] = 1 << e;
      for (e = 8; 256 > e; e += 1) c[e] = c[e - 4] ^ c[e - 5] ^ c[e - 6] ^ c[e - 8];
      for (e = 0; 255 > e; e += 1) a[c[e]] = e;
      return {
        g: function (b) {
          if (1 > b) throw Error("glog(" + b + ")");
          return a[b];
        },
        i: function (b) {
          for (; 0 > b;) b += 255;
          for (; 256 <= b;) b -= 255;
          return c[b];
        }
      };
    }(),
    t = function () {
      function c(b, c) {
        switch (c) {
          case A.L:
            return a[4 * (b - 1)];
          case A.M:
            return a[4 * (b - 1) + 1];
          case A.Q:
            return a[4 * (b - 1) + 2];
          case A.H:
            return a[4 * (b - 1) + 3];
        }
      }
      var a = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
        e = {
          I: function (b, a) {
            var e = c(b, a);
            if ("undefined" == typeof e) throw Error("bad rs block @ typeNumber:" + b + "/errorCorrectLevel:" + a);
            b = e.length / 3;
            a = [];
            for (var d = 0; d < b; d += 1) for (var g = e[3 * d], h = e[3 * d + 1], t = e[3 * d + 2], p = 0; p < g; p += 1) {
              var q = t,
                f = {};
              f.o = h;
              f.j = q;
              a.push(f);
            }
            return a;
          }
        };
      return e;
    }();
  return C;
}());
var QrCreator$1 = QrCreator;

var SlQrCode = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.value = "";
    this.label = "";
    this.size = 128;
    this.fill = "black";
    this.background = "white";
    this.radius = 0;
    this.errorCorrection = "H";
  }
  firstUpdated() {
    this.generate();
  }
  generate() {
    if (!this.hasUpdated) {
      return;
    }
    QrCreator$1.render({
      text: this.value,
      radius: this.radius,
      ecLevel: this.errorCorrection,
      fill: this.fill,
      background: this.background,
      // We draw the canvas larger and scale its container down to avoid blurring on high-density displays
      size: this.size * 2
    }, this.canvas);
  }
  render() {
    var _a;
    return x`
      <canvas
        part="base"
        class="qr-code"
        role="img"
        aria-label=${((_a = this.label) == null ? void 0 : _a.length) > 0 ? this.label : this.value}
        style=${o$5({
      width: `${this.size}px`,
      height: `${this.size}px`
    })}
      ></canvas>
    `;
  }
};
SlQrCode.styles = [component_styles_default, qr_code_styles_default];
__decorateClass([e$7("canvas")], SlQrCode.prototype, "canvas", 2);
__decorateClass([n$6()], SlQrCode.prototype, "value", 2);
__decorateClass([n$6()], SlQrCode.prototype, "label", 2);
__decorateClass([n$6({
  type: Number
})], SlQrCode.prototype, "size", 2);
__decorateClass([n$6()], SlQrCode.prototype, "fill", 2);
__decorateClass([n$6()], SlQrCode.prototype, "background", 2);
__decorateClass([n$6({
  type: Number
})], SlQrCode.prototype, "radius", 2);
__decorateClass([n$6({
  attribute: "error-correction"
})], SlQrCode.prototype, "errorCorrection", 2);
__decorateClass([watch(["background", "errorCorrection", "fill", "radius", "size", "value"])], SlQrCode.prototype, "generate", 1);

var tagName$B = "sl-qr-code";
SlQrCode.define("sl-qr-code");
o$8({
  tagName: tagName$B,
  elementClass: SlQrCode,
  react: React$1,
  events: {},
  displayName: "SlQrCode"
});

// src/components/button/button.styles.ts
var button_styles_default = i$7`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;

var radio_button_styles_default = i$7`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;

var SlRadioButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.hasFocus = false;
    this.checked = false;
    this.disabled = false;
    this.size = "medium";
    this.pill = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "presentation");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleClick(e) {
    if (this.disabled) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    this.checked = true;
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus on the radio button. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the radio button. */
  blur() {
    this.input.blur();
  }
  render() {
    return u`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${e$3({
      button: true,
      "button--default": true,
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--checked": this.checked,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--outline": true,
      "button--pill": this.pill,
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
          aria-disabled=${this.disabled}
          type="button"
          value=${o$6(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
  }
};
SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
__decorateClass([e$7(".button")], SlRadioButton.prototype, "input", 2);
__decorateClass([e$7(".hidden-input")], SlRadioButton.prototype, "hiddenInput", 2);
__decorateClass([r$3()], SlRadioButton.prototype, "hasFocus", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRadioButton.prototype, "checked", 2);
__decorateClass([n$6()], SlRadioButton.prototype, "value", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRadioButton.prototype, "disabled", 2);
__decorateClass([n$6({
  reflect: true
})], SlRadioButton.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRadioButton.prototype, "pill", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlRadioButton.prototype, "handleDisabledChange", 1);

var tagName$A = "sl-radio-button";
SlRadioButton.define("sl-radio-button");
o$8({
  tagName: tagName$A,
  elementClass: SlRadioButton,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus"
  },
  displayName: "SlRadioButton"
});

// src/components/radio/radio.styles.ts
var radio_styles_default = i$7`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;

var SlRadio = class extends ShoelaceElement {
  constructor() {
    super();
    this.checked = false;
    this.hasFocus = false;
    this.size = "medium";
    this.disabled = false;
    this.handleBlur = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.handleClick = () => {
      if (!this.disabled) {
        this.checked = true;
      }
    };
    this.handleFocus = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.addEventListener("blur", this.handleBlur);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("focus", this.handleFocus);
  }
  connectedCallback() {
    super.connectedCallback();
    this.setInitialAttributes();
  }
  setInitialAttributes() {
    this.setAttribute("role", "radio");
    this.setAttribute("tabindex", "-1");
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleCheckedChange() {
    this.setAttribute("aria-checked", this.checked ? "true" : "false");
    this.setAttribute("tabindex", this.checked ? "0" : "-1");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$3({
      radio: true,
      "radio--checked": this.checked,
      "radio--disabled": this.disabled,
      "radio--focused": this.hasFocus,
      "radio--small": this.size === "small",
      "radio--medium": this.size === "medium",
      "radio--large": this.size === "large"
    })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? x` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
  }
};
SlRadio.styles = [component_styles_default, radio_styles_default];
SlRadio.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([r$3()], SlRadio.prototype, "checked", 2);
__decorateClass([r$3()], SlRadio.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlRadio.prototype, "value", 2);
__decorateClass([n$6({
  reflect: true
})], SlRadio.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRadio.prototype, "disabled", 2);
__decorateClass([watch("checked")], SlRadio.prototype, "handleCheckedChange", 1);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlRadio.prototype, "handleDisabledChange", 1);

var tagName$z = "sl-radio";
SlRadio.define("sl-radio");
o$8({
  tagName: tagName$z,
  elementClass: SlRadio,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus"
  },
  displayName: "SlRadio"
});

// src/components/range/range.styles.ts
var range_styles_default = i$7`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;

var SlRange = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.hasTooltip = false;
    this.title = "";
    this.name = "";
    this.value = 0;
    this.label = "";
    this.helpText = "";
    this.disabled = false;
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.tooltip = "top";
    this.tooltipFormatter = value => value.toString();
    this.form = "";
    this.defaultValue = 0;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => this.syncRange());
    if (this.value < this.min) {
      this.value = this.min;
    }
    if (this.value > this.max) {
      this.value = this.max;
    }
    this.updateComplete.then(() => {
      this.syncRange();
      this.resizeObserver.observe(this.input);
    });
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.input);
  }
  handleChange() {
    this.emit("sl-change");
  }
  handleInput() {
    this.value = parseFloat(this.input.value);
    this.emit("sl-input");
    this.syncRange();
  }
  handleBlur() {
    this.hasFocus = false;
    this.hasTooltip = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.hasTooltip = true;
    this.emit("sl-focus");
  }
  handleThumbDragStart() {
    this.hasTooltip = true;
  }
  handleThumbDragEnd() {
    this.hasTooltip = false;
  }
  syncProgress(percent) {
    this.input.style.setProperty("--percent", `${percent * 100}%`);
  }
  syncTooltip(percent) {
    if (this.output !== null) {
      const inputWidth = this.input.offsetWidth;
      const tooltipWidth = this.output.offsetWidth;
      const thumbSize = getComputedStyle(this.input).getPropertyValue("--thumb-size");
      const isRtl = this.localize.dir() === "rtl";
      const percentAsWidth = inputWidth * percent;
      if (isRtl) {
        const x = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc((${x} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
      } else {
        const x = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
        this.output.style.translate = `calc(${x} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
      }
    }
  }
  handleValueChange() {
    this.formControlController.updateValidity();
    this.input.value = this.value.toString();
    this.value = parseFloat(this.input.value);
    this.syncRange();
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  syncRange() {
    const percent = Math.max(0, (this.value - this.min) / (this.max - this.min));
    this.syncProgress(percent);
    if (this.tooltip !== "none" && this.hasTooltip) {
      this.updateComplete.then(() => this.syncTooltip(percent));
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  /** Sets focus on the range. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the range. */
  blur() {
    this.input.blur();
  }
  /** Increments the value of the range by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Decrements the value of the range by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== Number(this.input.value)) {
      this.value = Number(this.input.value);
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return x`
      <div
        part="form-control"
        class=${e$3({
      "form-control": true,
      "form-control--medium": true,
      // range only has one size
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$3({
      range: true,
      "range--disabled": this.disabled,
      "range--focused": this.hasFocus,
      "range--rtl": this.localize.dir() === "rtl",
      "range--tooltip-visible": this.hasTooltip,
      "range--tooltip-top": this.tooltip === "top",
      "range--tooltip-bottom": this.tooltip === "bottom"
    })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${o$6(this.name)}
              ?disabled=${this.disabled}
              min=${o$6(this.min)}
              max=${o$6(this.max)}
              step=${o$6(this.step)}
              .value=${l(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? x`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
__decorateClass([e$7(".range__control")], SlRange.prototype, "input", 2);
__decorateClass([e$7(".range__tooltip")], SlRange.prototype, "output", 2);
__decorateClass([r$3()], SlRange.prototype, "hasFocus", 2);
__decorateClass([r$3()], SlRange.prototype, "hasTooltip", 2);
__decorateClass([n$6()], SlRange.prototype, "title", 2);
__decorateClass([n$6()], SlRange.prototype, "name", 2);
__decorateClass([n$6({
  type: Number
})], SlRange.prototype, "value", 2);
__decorateClass([n$6()], SlRange.prototype, "label", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlRange.prototype, "helpText", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRange.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Number
})], SlRange.prototype, "min", 2);
__decorateClass([n$6({
  type: Number
})], SlRange.prototype, "max", 2);
__decorateClass([n$6({
  type: Number
})], SlRange.prototype, "step", 2);
__decorateClass([n$6()], SlRange.prototype, "tooltip", 2);
__decorateClass([n$6({
  attribute: false
})], SlRange.prototype, "tooltipFormatter", 2);
__decorateClass([n$6({
  reflect: true
})], SlRange.prototype, "form", 2);
__decorateClass([defaultValue()], SlRange.prototype, "defaultValue", 2);
__decorateClass([t$2({
  passive: true
})], SlRange.prototype, "handleThumbDragStart", 1);
__decorateClass([watch("value", {
  waitUntilFirstUpdate: true
})], SlRange.prototype, "handleValueChange", 1);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlRange.prototype, "handleDisabledChange", 1);
__decorateClass([watch("hasTooltip", {
  waitUntilFirstUpdate: true
})], SlRange.prototype, "syncRange", 1);

var tagName$y = "sl-range";
SlRange.define("sl-range");
o$8({
  tagName: tagName$y,
  elementClass: SlRange,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlRange"
});

// src/components/radio-group/radio-group.styles.ts
var radio_group_styles_default = i$7`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`;

// src/components/button-group/button-group.styles.ts
var button_group_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;

var SlButtonGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.disableRole = false;
    this.label = "";
  }
  handleFocus(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
  }
  handleBlur(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
  }
  handleMouseOver(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
  }
  handleMouseOut(event) {
    const button = findButton(event.target);
    button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
  }
  handleSlotChange() {
    const slottedElements = [...this.defaultSlot.assignedElements({
      flatten: true
    })];
    slottedElements.forEach(el => {
      const index = slottedElements.indexOf(el);
      const button = findButton(el);
      if (button) {
        button.toggleAttribute("data-sl-button-group__button", true);
        button.toggleAttribute("data-sl-button-group__button--first", index === 0);
        button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
        button.toggleAttribute("data-sl-button-group__button--radio", button.tagName.toLowerCase() === "sl-radio-button");
      }
    });
  }
  render() {
    return x`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
  }
};
SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
__decorateClass([e$7("slot")], SlButtonGroup.prototype, "defaultSlot", 2);
__decorateClass([r$3()], SlButtonGroup.prototype, "disableRole", 2);
__decorateClass([n$6()], SlButtonGroup.prototype, "label", 2);
function findButton(el) {
  var _a;
  const selector = "sl-button, sl-radio-button";
  return (_a = el.closest(selector)) != null ? _a : el.querySelector(selector);
}

var SlRadioGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this);
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.customValidityMessage = "";
    this.hasButtonGroup = false;
    this.errorMessage = "";
    this.defaultValue = "";
    this.label = "";
    this.helpText = "";
    this.name = "option";
    this.value = "";
    this.size = "medium";
    this.form = "";
    this.required = false;
  }
  /** Gets the validity state object */
  get validity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return customErrorValidityState;
    } else if (isRequiredAndEmpty) {
      return valueMissingValidityState;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (hasCustomValidityMessage) {
      return this.customValidityMessage;
    } else if (isRequiredAndEmpty) {
      return this.validationInput.validationMessage;
    }
    return "";
  }
  connectedCallback() {
    super.connectedCallback();
    this.defaultValue = this.value;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  getAllRadios() {
    return [...this.querySelectorAll("sl-radio, sl-radio-button")];
  }
  handleRadioClick(event) {
    const target = event.target.closest("sl-radio, sl-radio-button");
    const radios = this.getAllRadios();
    const oldValue = this.value;
    if (!target || target.disabled) {
      return;
    }
    this.value = target.value;
    radios.forEach(radio => radio.checked = radio === target);
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleKeyDown(event) {
    var _a;
    if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(event.key)) {
      return;
    }
    const radios = this.getAllRadios().filter(radio => !radio.disabled);
    const checkedRadio = (_a = radios.find(radio => radio.checked)) != null ? _a : radios[0];
    const incr = event.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(event.key) ? -1 : 1;
    const oldValue = this.value;
    let index = radios.indexOf(checkedRadio) + incr;
    if (index < 0) {
      index = radios.length - 1;
    }
    if (index > radios.length - 1) {
      index = 0;
    }
    this.getAllRadios().forEach(radio => {
      radio.checked = false;
      if (!this.hasButtonGroup) {
        radio.setAttribute("tabindex", "-1");
      }
    });
    this.value = radios[index].value;
    radios[index].checked = true;
    if (!this.hasButtonGroup) {
      radios[index].setAttribute("tabindex", "0");
      radios[index].focus();
    } else {
      radios[index].shadowRoot.querySelector("button").focus();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
    event.preventDefault();
  }
  handleLabelClick() {
    this.focus();
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  async syncRadioElements() {
    var _a, _b;
    const radios = this.getAllRadios();
    await Promise.all(
    // Sync the checked state and size
    radios.map(async radio => {
      await radio.updateComplete;
      radio.checked = radio.value === this.value;
      radio.size = this.size;
    }));
    this.hasButtonGroup = radios.some(radio => radio.tagName.toLowerCase() === "sl-radio-button");
    if (radios.length > 0 && !radios.some(radio => radio.checked)) {
      if (this.hasButtonGroup) {
        const buttonRadio = (_a = radios[0].shadowRoot) == null ? void 0 : _a.querySelector("button");
        if (buttonRadio) {
          buttonRadio.setAttribute("tabindex", "0");
        }
      } else {
        radios[0].setAttribute("tabindex", "0");
      }
    }
    if (this.hasButtonGroup) {
      const buttonGroup = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector("sl-button-group");
      if (buttonGroup) {
        buttonGroup.disableRole = true;
      }
    }
  }
  syncRadios() {
    if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
      this.syncRadioElements();
      return;
    }
    if (customElements.get("sl-radio")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio").then(() => this.syncRadios());
    }
    if (customElements.get("sl-radio-button")) {
      this.syncRadioElements();
    } else {
      customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
    }
  }
  updateCheckedRadio() {
    const radios = this.getAllRadios();
    radios.forEach(radio => radio.checked = radio.value === this.value);
    this.formControlController.setValidity(this.validity.valid);
  }
  handleSizeChange() {
    this.syncRadios();
  }
  handleValueChange() {
    if (this.hasUpdated) {
      this.updateCheckedRadio();
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    const isRequiredAndEmpty = this.required && !this.value;
    const hasCustomValidityMessage = this.customValidityMessage !== "";
    if (isRequiredAndEmpty || hasCustomValidityMessage) {
      this.formControlController.emitInvalidEvent();
      return false;
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    const isValid = this.validity.valid;
    this.errorMessage = this.customValidityMessage || isValid ? "" : this.validationInput.validationMessage;
    this.formControlController.setValidity(isValid);
    this.validationInput.hidden = true;
    clearTimeout(this.validationTimeout);
    if (!isValid) {
      this.validationInput.hidden = false;
      this.validationInput.reportValidity();
      this.validationTimeout = setTimeout(() => this.validationInput.hidden = true, 1e4);
    }
    return isValid;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message = "") {
    this.customValidityMessage = message;
    this.errorMessage = message;
    this.validationInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the radio-group. */
  focus(options) {
    const radios = this.getAllRadios();
    const checked = radios.find(radio => radio.checked);
    const firstEnabledRadio = radios.find(radio => !radio.disabled);
    const radioToFocus = checked || firstEnabledRadio;
    if (radioToFocus) {
      radioToFocus.focus(options);
    }
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const defaultSlot = x`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
    return x`
      <fieldset
        part="form-control"
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--radio-group": true,
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? x`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${defaultSlot}
                </sl-button-group>
              ` : defaultSlot}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
  }
};
SlRadioGroup.styles = [component_styles_default, form_control_styles_default, radio_group_styles_default];
SlRadioGroup.dependencies = {
  "sl-button-group": SlButtonGroup
};
__decorateClass([e$7("slot:not([name])")], SlRadioGroup.prototype, "defaultSlot", 2);
__decorateClass([e$7(".radio-group__validation-input")], SlRadioGroup.prototype, "validationInput", 2);
__decorateClass([r$3()], SlRadioGroup.prototype, "hasButtonGroup", 2);
__decorateClass([r$3()], SlRadioGroup.prototype, "errorMessage", 2);
__decorateClass([r$3()], SlRadioGroup.prototype, "defaultValue", 2);
__decorateClass([n$6()], SlRadioGroup.prototype, "label", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlRadioGroup.prototype, "helpText", 2);
__decorateClass([n$6()], SlRadioGroup.prototype, "name", 2);
__decorateClass([n$6({
  reflect: true
})], SlRadioGroup.prototype, "value", 2);
__decorateClass([n$6({
  reflect: true
})], SlRadioGroup.prototype, "size", 2);
__decorateClass([n$6({
  reflect: true
})], SlRadioGroup.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlRadioGroup.prototype, "required", 2);
__decorateClass([watch("size", {
  waitUntilFirstUpdate: true
})], SlRadioGroup.prototype, "handleSizeChange", 1);
__decorateClass([watch("value")], SlRadioGroup.prototype, "handleValueChange", 1);

var tagName$x = "sl-radio-group";
SlRadioGroup.define("sl-radio-group");
o$8({
  tagName: tagName$x,
  elementClass: SlRadioGroup,
  react: React$1,
  events: {
    onSlChange: "sl-change",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlRadioGroup"
});

// src/components/image-comparer/image-comparer.styles.ts
var image_comparer_styles_default = i$7`
  :host {
    --divider-width: 2px;
    --handle-size: 2.5rem;

    display: inline-block;
    position: relative;
  }

  .image-comparer {
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }

  .image-comparer__before,
  .image-comparer__after {
    display: block;
    pointer-events: none;
  }

  .image-comparer__before::slotted(img),
  .image-comparer__after::slotted(img),
  .image-comparer__before::slotted(svg),
  .image-comparer__after::slotted(svg) {
    display: block;
    max-width: 100% !important;
    height: auto;
  }

  .image-comparer__after {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  .image-comparer__divider {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    width: var(--divider-width);
    height: 100%;
    background-color: var(--sl-color-neutral-0);
    translate: calc(var(--divider-width) / -2);
    cursor: ew-resize;
  }

  .image-comparer__handle {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: calc(50% - (var(--handle-size) / 2));
    width: var(--handle-size);
    height: var(--handle-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: var(--sl-border-radius-circle);
    font-size: calc(var(--handle-size) * 0.5);
    color: var(--sl-color-neutral-700);
    cursor: inherit;
    z-index: 10;
  }

  .image-comparer__handle:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;

var SlImageComparer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.position = 50;
  }
  handleDrag(event) {
    const {
      width
    } = this.base.getBoundingClientRect();
    const isRtl = this.localize.dir() === "rtl";
    event.preventDefault();
    drag(this.base, {
      onMove: x => {
        this.position = parseFloat(clamp(x / width * 100, 0, 100).toFixed(2));
        if (isRtl) this.position = 100 - this.position;
      },
      initialEvent: event
    });
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    if (["ArrowLeft", "ArrowRight", "Home", "End"].includes(event.key)) {
      const incr = event.shiftKey ? 10 : 1;
      let newPosition = this.position;
      event.preventDefault();
      if (isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
        newPosition -= incr;
      }
      if (isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
        newPosition += incr;
      }
      if (event.key === "Home") {
        newPosition = 0;
      }
      if (event.key === "End") {
        newPosition = 100;
      }
      newPosition = clamp(newPosition, 0, 100);
      this.position = newPosition;
    }
  }
  handlePositionChange() {
    this.emit("sl-change");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x`
      <div
        part="base"
        id="image-comparer"
        class=${e$3({
      "image-comparer": true,
      "image-comparer--rtl": isRtl
    })}
        @keydown=${this.handleKeyDown}
      >
        <div class="image-comparer__image">
          <div part="before" class="image-comparer__before">
            <slot name="before"></slot>
          </div>

          <div
            part="after"
            class="image-comparer__after"
            style=${o$5({
      clipPath: isRtl ? `inset(0 0 0 ${100 - this.position}%)` : `inset(0 ${100 - this.position}% 0 0)`
    })}
          >
            <slot name="after"></slot>
          </div>
        </div>

        <div
          part="divider"
          class="image-comparer__divider"
          style=${o$5({
      left: isRtl ? `${100 - this.position}%` : `${this.position}%`
    })}
          @mousedown=${this.handleDrag}
          @touchstart=${this.handleDrag}
        >
          <div
            part="handle"
            class="image-comparer__handle"
            role="scrollbar"
            aria-valuenow=${this.position}
            aria-valuemin="0"
            aria-valuemax="100"
            aria-controls="image-comparer"
            tabindex="0"
          >
            <slot name="handle">
              <sl-icon library="system" name="grip-vertical"></sl-icon>
            </slot>
          </div>
        </div>
      </div>
    `;
  }
};
SlImageComparer.styles = [component_styles_default, image_comparer_styles_default];
SlImageComparer.scopedElement = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".image-comparer")], SlImageComparer.prototype, "base", 2);
__decorateClass([e$7(".image-comparer__handle")], SlImageComparer.prototype, "handle", 2);
__decorateClass([n$6({
  type: Number,
  reflect: true
})], SlImageComparer.prototype, "position", 2);
__decorateClass([watch("position", {
  waitUntilFirstUpdate: true
})], SlImageComparer.prototype, "handlePositionChange", 1);

var tagName$w = "sl-image-comparer";
SlImageComparer.define("sl-image-comparer");
o$8({
  tagName: tagName$w,
  elementClass: SlImageComparer,
  react: React$1,
  events: {
    onSlChange: "sl-change"
  },
  displayName: "SlImageComparer"
});

// src/components/include/include.styles.ts
var include_styles_default = i$7`
  :host {
    display: block;
  }
`;

// src/components/include/request.ts
var includeFiles = /* @__PURE__ */new Map();
function requestInclude(src, mode = "cors") {
  const prev = includeFiles.get(src);
  if (prev !== void 0) {
    return Promise.resolve(prev);
  }
  const fileDataPromise = fetch(src, {
    mode
  }).then(async response => {
    const res = {
      ok: response.ok,
      status: response.status,
      html: await response.text()
    };
    includeFiles.set(src, res);
    return res;
  });
  includeFiles.set(src, fileDataPromise);
  return fileDataPromise;
}

var SlInclude = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.mode = "cors";
    this.allowScripts = false;
  }
  executeScript(script) {
    const newScript = document.createElement("script");
    [...script.attributes].forEach(attr => newScript.setAttribute(attr.name, attr.value));
    newScript.textContent = script.textContent;
    script.parentNode.replaceChild(newScript, script);
  }
  async handleSrcChange() {
    try {
      const src = this.src;
      const file = await requestInclude(src, this.mode);
      if (src !== this.src) {
        return;
      }
      if (!file.ok) {
        this.emit("sl-error", {
          detail: {
            status: file.status
          }
        });
        return;
      }
      this.innerHTML = file.html;
      if (this.allowScripts) {
        [...this.querySelectorAll("script")].forEach(script => this.executeScript(script));
      }
      this.emit("sl-load");
    } catch (e) {
      this.emit("sl-error", {
        detail: {
          status: -1
        }
      });
    }
  }
  render() {
    return x`<slot></slot>`;
  }
};
SlInclude.styles = [component_styles_default, include_styles_default];
__decorateClass([n$6()], SlInclude.prototype, "src", 2);
__decorateClass([n$6()], SlInclude.prototype, "mode", 2);
__decorateClass([n$6({
  attribute: "allow-scripts",
  type: Boolean
})], SlInclude.prototype, "allowScripts", 2);
__decorateClass([watch("src")], SlInclude.prototype, "handleSrcChange", 1);

var tagName$v = "sl-include";
SlInclude.define("sl-include");
o$8({
  tagName: tagName$v,
  elementClass: SlInclude,
  react: React$1,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error"
  },
  displayName: "SlInclude"
});

// src/components/menu/menu.styles.ts
var menu_styles_default = i$7`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const composedPath = event.composedPath();
    const target = composedPath.find(el => {
      var _a;
      return menuItemTypes.includes(((_a = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a.call(el, "role")) || "");
    });
    if (!target) return;
    const closestMenu = composedPath.find(el => {
      var _a;
      return ((_a = el == null ? void 0 : el.getAttribute) == null ? void 0 : _a.call(el, "role")) === "menu";
    });
    const clickHasSubmenu = closestMenu !== this;
    if (clickHasSubmenu) return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", {
      detail: {
        item
      }
    });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index++;
        } else if (event.key === "ArrowUp") {
          index--;
        } else if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = items.length - 1;
        }
        if (index < 0) {
          index = items.length - 1;
        }
        if (index > items.length - 1) {
          index = 0;
        }
        this.setCurrentItem(items[index]);
        items[index].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a;
    return item.tagName.toLowerCase() === "sl-menu-item" || ["menuitem", "menuitemcheckbox", "menuitemradio"].includes((_a = item.getAttribute("role")) != null ? _a : "");
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({
      flatten: true
    })].filter(el => {
      if (el.inert || !this.isMenuItem(el)) {
        return false;
      }
      return true;
    });
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find(i => i.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach(i => {
      i.setAttribute("tabindex", i === item ? "0" : "-1");
    });
  }
  render() {
    return x`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass([e$7("slot")], SlMenu.prototype, "defaultSlot", 2);

var tagName$u = "sl-menu";
SlMenu.define("sl-menu");
o$8({
  tagName: tagName$u,
  elementClass: SlMenu,
  react: React$1,
  events: {
    onSlSelect: "sl-select"
  },
  displayName: "SlMenu"
});

// src/components/input/input.styles.ts
var input_styles_default = i$7`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.title = "";
    // make reactive to pass through
    this.__numberInput = Object.assign(document.createElement("input"), {
      type: "number"
    });
    this.__dateInput = Object.assign(document.createElement("input"), {
      type: "date"
    });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a;
    this.__numberInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    event.preventDefault();
    if (this.value !== "") {
      this.value = "";
      this.emit("sl-clear");
      this.emit("sl-input");
      this.emit("sl-change");
    }
    this.input.focus();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return x`
      <div
        part="form-control"
        class=${e$3({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e$3({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${o$6(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o$6(this.placeholder)}
              minlength=${o$6(this.minlength)}
              maxlength=${o$6(this.maxlength)}
              min=${o$6(this.min)}
              max=${o$6(this.max)}
              step=${o$6(this.step)}
              .value=${l(this.value)}
              autocapitalize=${o$6(this.autocapitalize)}
              autocomplete=${o$6(this.autocomplete)}
              autocorrect=${o$6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o$6(this.pattern)}
              enterkeyhint=${o$6(this.enterkeyhint)}
              inputmode=${o$6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${isClearIconVisible ? x`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? x`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? x`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : x`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".input__control")], SlInput.prototype, "input", 2);
__decorateClass([r$3()], SlInput.prototype, "hasFocus", 2);
__decorateClass([n$6()], SlInput.prototype, "title", 2);
__decorateClass([n$6({
  reflect: true
})], SlInput.prototype, "type", 2);
__decorateClass([n$6()], SlInput.prototype, "name", 2);
__decorateClass([n$6()], SlInput.prototype, "value", 2);
__decorateClass([defaultValue()], SlInput.prototype, "defaultValue", 2);
__decorateClass([n$6({
  reflect: true
})], SlInput.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlInput.prototype, "filled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlInput.prototype, "pill", 2);
__decorateClass([n$6()], SlInput.prototype, "label", 2);
__decorateClass([n$6({
  attribute: "help-text"
})], SlInput.prototype, "helpText", 2);
__decorateClass([n$6({
  type: Boolean
})], SlInput.prototype, "clearable", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlInput.prototype, "disabled", 2);
__decorateClass([n$6()], SlInput.prototype, "placeholder", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlInput.prototype, "readonly", 2);
__decorateClass([n$6({
  attribute: "password-toggle",
  type: Boolean
})], SlInput.prototype, "passwordToggle", 2);
__decorateClass([n$6({
  attribute: "password-visible",
  type: Boolean
})], SlInput.prototype, "passwordVisible", 2);
__decorateClass([n$6({
  attribute: "no-spin-buttons",
  type: Boolean
})], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([n$6({
  reflect: true
})], SlInput.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlInput.prototype, "required", 2);
__decorateClass([n$6()], SlInput.prototype, "pattern", 2);
__decorateClass([n$6({
  type: Number
})], SlInput.prototype, "minlength", 2);
__decorateClass([n$6({
  type: Number
})], SlInput.prototype, "maxlength", 2);
__decorateClass([n$6()], SlInput.prototype, "min", 2);
__decorateClass([n$6()], SlInput.prototype, "max", 2);
__decorateClass([n$6()], SlInput.prototype, "step", 2);
__decorateClass([n$6()], SlInput.prototype, "autocapitalize", 2);
__decorateClass([n$6()], SlInput.prototype, "autocorrect", 2);
__decorateClass([n$6()], SlInput.prototype, "autocomplete", 2);
__decorateClass([n$6({
  type: Boolean
})], SlInput.prototype, "autofocus", 2);
__decorateClass([n$6()], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([n$6({
  type: Boolean,
  converter: {
    // Allow "true|false" attribute values but keep the property boolean
    fromAttribute: value => !value || value === "false" ? false : true,
    toAttribute: value => value ? "true" : "false"
  }
})], SlInput.prototype, "spellcheck", 2);
__decorateClass([n$6()], SlInput.prototype, "inputmode", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([watch("step", {
  waitUntilFirstUpdate: true
})], SlInput.prototype, "handleStepChange", 1);
__decorateClass([watch("value", {
  waitUntilFirstUpdate: true
})], SlInput.prototype, "handleValueChange", 1);

var tagName$t = "sl-input";
SlInput.define("sl-input");
o$8({
  tagName: tagName$t,
  elementClass: SlInput,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlClear: "sl-clear",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlInput"
});

// src/components/menu-item/menu-item.styles.ts
var menu_item_styles_default = i$7`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }

  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = (i, t) => {
    const e = i._$AN;
    if (void 0 === e) return false;
    for (const i of e) i._$AO?.(t, false), s(i, t);
    return true;
  },
  o$3 = i => {
    let t, e;
    do {
      if (void 0 === (t = i._$AM)) break;
      e = t._$AN, e.delete(i), i = t;
    } while (0 === e?.size);
  },
  r = i => {
    for (let t; t = i._$AM; i = t) {
      let e = t._$AN;
      if (void 0 === e) t._$AN = e = new Set();else if (e.has(i)) break;
      e.add(i), c(t);
    }
  };
function h$1(i) {
  void 0 !== this._$AN ? (o$3(this), this._$AM = i, r(this)) : this._$AM = i;
}
function n$1(i, t = false, e = 0) {
  const r = this._$AH,
    h = this._$AN;
  if (void 0 !== h && 0 !== h.size) if (t) {
    if (Array.isArray(r)) for (let i = e; i < r.length; i++) s(r[i], false), o$3(r[i]);else null != r && (s(r, false), o$3(r));
  } else s(this, i);
}
const c = i => {
  i.type == t.CHILD && (i._$AP ??= n$1, i._$AQ ??= h$1);
};
class f extends i$3 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i, t, e) {
    super._$AT(i, t, e), r(this), this.isConnected = i._$AU;
  }
  _$AO(i, t = true) {
    i !== this.isConnected && (this.isConnected = i, i ? this.reconnected?.() : this.disconnected?.()), t && (s(this, i), o$3(this));
  }
  setValue(t) {
    if (f$1(this._$Ct)) this._$Ct._$AI(t, this);else {
      const i = [...this._$Ct._$AH];
      i[this._$Ci] = t, this._$Ct._$AI(i, this, 0);
    }
  }
  disconnected() {}
  reconnected() {}
}

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = () => new h();
class h {}
const o$2 = new WeakMap(),
  n = e$4(class extends f {
    render(i) {
      return E;
    }
    update(i, [s]) {
      const e = s !== this.Y;
      return e && void 0 !== this.Y && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = s, this.ht = i.options?.host, this.rt(this.ct = i.element)), E;
    }
    rt(t) {
      if (this.isConnected || (t = void 0), "function" == typeof this.Y) {
        const i = this.ht ?? globalThis;
        let s = o$2.get(i);
        void 0 === s && (s = new WeakMap(), o$2.set(i, s)), void 0 !== s.get(this.Y) && this.Y.call(this.ht, void 0), s.set(this.Y, t), void 0 !== t && this.Y.call(this.ht, t);
      } else this.Y.value = t;
    }
    get lt() {
      return "function" == typeof this.Y ? o$2.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
    }
    disconnected() {
      this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
      this.rt(this.ct);
    }
  });

// src/components/menu-item/submenu-controller.ts
var SubmenuController = class {
  constructor(host, hasSlotController) {
    this.popupRef = e();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    // Set the safe triangle cursor position
    this.handleMouseMove = event => {
      this.host.style.setProperty("--safe-triangle-cursor-x", `${event.clientX}px`);
      this.host.style.setProperty("--safe-triangle-cursor-y", `${event.clientY}px`);
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    // Focus on the first menu-item of a submenu.
    this.handleKeyDown = event => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
      }
    };
    this.handleClick = event => {
      var _a;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (event.target instanceof Element && (event.target.tagName === "sl-menu-item" || ((_a = event.target.role) == null ? void 0 : _a.startsWith("menuitem")))) {
        this.disableSubmenu();
      }
    };
    // Close this submenu on focus outside of the parent or any descendants.
    this.handleFocusOut = event => {
      if (event.relatedTarget && event.relatedTarget instanceof Element && this.host.contains(event.relatedTarget)) {
        return;
      }
      this.disableSubmenu();
    };
    // Prevent the parent menu-item from getting focus on mouse movement on the submenu
    this.handlePopupMouseover = event => {
      event.stopPropagation();
    };
    // Set the safe triangle values for the submenu when the position changes
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
      const menu = submenuSlot == null ? void 0 : submenuSlot.assignedElements({
        flatten: true
      }).filter(el => el.localName === "sl-menu")[0];
      const isRtl = getComputedStyle(this.host).direction === "rtl";
      if (!menu) {
        return;
      }
      const {
        left,
        top,
        width,
        height
      } = menu.getBoundingClientRect();
      this.host.style.setProperty("--safe-triangle-submenu-start-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-start-y", `${top}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-x", `${isRtl ? left + width : left}px`);
      this.host.style.setProperty("--safe-triangle-submenu-end-y", `${top + height}px`);
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.addEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener("mouseover", this.handlePopupMouseover);
        this.popupRef.value.removeEventListener("sl-reposition", this.handlePopupReposition);
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector("slot[name='submenu']");
    if (!submenuSlot) {
      console.error("Cannot activate a submenu if no corresponding menuitem can be found.", this);
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i = 1; i !== menuItems.length; ++i) {
      menuItems[i].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state) {
        this.popupRef.value.active = state;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      window.clearTimeout(this.enableSubmenuTimer);
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    window.clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a;
    if (!((_a = this.host.parentElement) == null ? void 0 : _a.computedStyleMap)) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a2;
      const styleValue = (_a2 = styleMap.get(attr)) != null ? _a2 : new CSSUnitValue(0, "px");
      const unitValue = styleValue instanceof CSSUnitValue ? styleValue : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isRtl = getComputedStyle(this.host).direction === "rtl";
    if (!this.isConnected) {
      return x` <slot name="submenu" hidden></slot> `;
    }
    return x`
      <sl-popup
        ${n(this.popupRef)}
        placement=${isRtl ? "left-start" : "right-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
        auto-size="vertical"
        auto-size-padding="10"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};

var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(this, this.hasSlotController);
    this.handleHostClick = event => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = event => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", {
        bubbles: true,
        composed: false,
        cancelable: false
      });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error('The checked attribute can only be used on menu items with type="checkbox"', this);
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return x`
      <div
        id="anchor"
        part="base"
        class=${e$3({
      "menu-item": true,
      "menu-item--rtl": isRtl,
      "menu-item--checked": this.checked,
      "menu-item--disabled": this.disabled,
      "menu-item--loading": this.loading,
      "menu-item--has-submenu": this.isSubmenu(),
      "menu-item--submenu-expanded": isSubmenuExpanded
    })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${this.handleDefaultSlotChange}></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${isRtl ? "chevron-left" : "chevron-right"} library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${this.loading ? x` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> ` : ""}
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner
};
__decorateClass([e$7("slot:not([name])")], SlMenuItem.prototype, "defaultSlot", 2);
__decorateClass([e$7(".menu-item")], SlMenuItem.prototype, "menuItem", 2);
__decorateClass([n$6()], SlMenuItem.prototype, "type", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlMenuItem.prototype, "checked", 2);
__decorateClass([n$6()], SlMenuItem.prototype, "value", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlMenuItem.prototype, "loading", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlMenuItem.prototype, "disabled", 2);
__decorateClass([watch("checked")], SlMenuItem.prototype, "handleCheckedChange", 1);
__decorateClass([watch("disabled")], SlMenuItem.prototype, "handleDisabledChange", 1);
__decorateClass([watch("type")], SlMenuItem.prototype, "handleTypeChange", 1);

var tagName$s = "sl-menu-item";
SlMenuItem.define("sl-menu-item");
o$8({
  tagName: tagName$s,
  elementClass: SlMenuItem,
  react: React$1,
  events: {},
  displayName: "SlMenuItem"
});

// src/components/menu-label/menu-label.styles.ts
var menu_label_styles_default = i$7`
  :host {
    display: block;
  }

  .menu-label {
    display: inline-block;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-500);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-large);
    user-select: none;
    -webkit-user-select: none;
  }
`;

var SlMenuLabel = class extends ShoelaceElement {
  render() {
    return x` <slot part="base" class="menu-label"></slot> `;
  }
};
SlMenuLabel.styles = [component_styles_default, menu_label_styles_default];

var tagName$r = "sl-menu-label";
SlMenuLabel.define("sl-menu-label");
o$8({
  tagName: tagName$r,
  elementClass: SlMenuLabel,
  react: React$1,
  events: {},
  displayName: "SlMenuLabel"
});

// src/components/option/option.styles.ts
var option_styles_default = i$7`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    // @ts-expect-error - Controller is currently unused
    this.localize = new LocalizeController(this);
    this.isInitialized = false;
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    if (this.isInitialized) {
      customElements.whenDefined("sl-select").then(() => {
        const controller = this.closest("sl-select");
        if (controller) {
          controller.handleDefaultSlotChange();
        }
      });
    } else {
      this.isInitialized = true;
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".option__label")], SlOption.prototype, "defaultSlot", 2);
__decorateClass([r$3()], SlOption.prototype, "current", 2);
__decorateClass([r$3()], SlOption.prototype, "selected", 2);
__decorateClass([r$3()], SlOption.prototype, "hasHover", 2);
__decorateClass([n$6({
  reflect: true
})], SlOption.prototype, "value", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlOption.prototype, "disabled", 2);
__decorateClass([watch("disabled")], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass([watch("selected")], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass([watch("value")], SlOption.prototype, "handleValueChange", 1);

var tagName$q = "sl-option";
SlOption.define("sl-option");
o$8({
  tagName: tagName$q,
  elementClass: SlOption,
  react: React$1,
  events: {},
  displayName: "SlOption"
});

var tagName$p = "sl-popup";
SlPopup.define("sl-popup");
o$8({
  tagName: tagName$p,
  elementClass: SlPopup,
  react: React$1,
  events: {
    onSlReposition: "sl-reposition"
  },
  displayName: "SlPopup"
});

// src/components/divider/divider.styles.ts
var divider_styles_default = i$7`
  :host {
    --color: var(--sl-panel-border-color);
    --width: var(--sl-panel-border-width);
    --spacing: var(--sl-spacing-medium);
  }

  :host(:not([vertical])) {
    display: block;
    border-top: solid var(--width) var(--color);
    margin: var(--spacing) 0;
  }

  :host([vertical]) {
    display: inline-block;
    height: 100%;
    border-left: solid var(--width) var(--color);
    margin: 0 var(--spacing);
  }
`;

var SlDivider = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.vertical = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "separator");
  }
  handleVerticalChange() {
    this.setAttribute("aria-orientation", this.vertical ? "vertical" : "horizontal");
  }
};
SlDivider.styles = [component_styles_default, divider_styles_default];
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDivider.prototype, "vertical", 2);
__decorateClass([watch("vertical")], SlDivider.prototype, "handleVerticalChange", 1);

var tagName$o = "sl-divider";
SlDivider.define("sl-divider");
o$8({
  tagName: tagName$o,
  elementClass: SlDivider,
  react: React$1,
  events: {},
  displayName: "SlDivider"
});

// src/components/drawer/drawer.styles.ts
var drawer_styles_default = i$7`
  :host {
    --size: 25rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .drawer {
    top: 0;
    inset-inline-start: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
  }

  .drawer--contained {
    position: absolute;
    z-index: initial;
  }

  .drawer--fixed {
    position: fixed;
    z-index: var(--sl-z-index-drawer);
  }

  .drawer__panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    z-index: 2;
    max-width: 100%;
    max-height: 100%;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-large);
    overflow: auto;
    pointer-events: all;
  }

  .drawer__panel:focus {
    outline: none;
  }

  .drawer--top .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--end .drawer__panel {
    top: 0;
    inset-inline-end: 0;
    bottom: auto;
    inset-inline-start: auto;
    width: var(--size);
    height: 100%;
  }

  .drawer--bottom .drawer__panel {
    top: auto;
    inset-inline-end: auto;
    bottom: 0;
    inset-inline-start: 0;
    width: 100%;
    height: var(--size);
  }

  .drawer--start .drawer__panel {
    top: 0;
    inset-inline-end: auto;
    bottom: auto;
    inset-inline-start: 0;
    width: var(--size);
    height: 100%;
  }

  .drawer__header {
    display: flex;
  }

  .drawer__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .drawer__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .drawer__header-actions sl-icon-button,
  .drawer__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .drawer__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .drawer__footer {
    text-align: right;
    padding: var(--footer-spacing);
  }

  .drawer__footer ::slotted(sl-button:not(:last-of-type)) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .drawer:not(.drawer--has-footer) .drawer__footer {
    display: none;
  }

  .drawer__overlay {
    display: block;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
    pointer-events: all;
  }

  .drawer--contained .drawer__overlay {
    display: none;
  }

  @media (forced-colors: active) {
    .drawer__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;

// src/internal/active-elements.ts
function* activeElements(activeElement = document.activeElement) {
  if (activeElement === null || activeElement === void 0) return;
  yield activeElement;
  if ("shadowRoot" in activeElement && activeElement.shadowRoot && activeElement.shadowRoot.mode !== "closed") {
    yield* __yieldStar(activeElements(activeElement.shadowRoot.activeElement));
  }
}
function getDeepestActiveElement() {
  return [...activeElements()].pop();
}

// src/internal/tabbable.ts
var computedStyleMap = /* @__PURE__ */new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({
      checkOpacity: false,
      checkVisibilityCSS: true
    });
  }
  const computedStyle = getCachedComputedStyle(el);
  return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const {
    overflowY,
    overflowX
  } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio") {
    const rootNode = el.getRootNode();
    const findRadios = `input[type='radio'][name="${el.getAttribute("name")}"]`;
    const firstChecked = rootNode.querySelector(`${findRadios}:checked`);
    if (firstChecked) {
      return firstChecked === el;
    }
    const firstRadio = rootNode.querySelector(findRadios);
    return firstRadio === el;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  const isNativelyTabbable = ["button", "input", "select", "textarea", "a", "audio", "video", "summary", "iframe"].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a, _b;
  const tabbableElements = getTabbableElements(root);
  const start = (_a = tabbableElements[0]) != null ? _a : null;
  const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return {
    start,
    end
  };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a;
  return ((_a = slotElement.getRootNode({
    composed: true
  })) == null ? void 0 : _a.host) !== root;
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {
        el.assignedElements({
          flatten: true
        }).forEach(assignedEl => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e of el.children) {
      walk(e);
    }
  }
  walk(root);
  return tabbableElements.sort((a, b) => {
    const aTabindex = Number(a.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}

// src/internal/modal.ts
var activeModals = [];
var Modal = class {
  constructor(element) {
    this.tabDirection = "forward";
    this.handleFocusIn = () => {
      if (!this.isActive()) return;
      this.checkFocus();
    };
    this.handleKeyDown = event => {
      var _a;
      if (event.key !== "Tab" || this.isExternalActivated) return;
      if (!this.isActive()) return;
      const currentActiveElement = getDeepestActiveElement();
      this.previousFocus = currentActiveElement;
      if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {
        return;
      }
      if (event.shiftKey) {
        this.tabDirection = "backward";
      } else {
        this.tabDirection = "forward";
      }
      const tabbableElements = getTabbableElements(this.element);
      let currentFocusIndex = tabbableElements.findIndex(el => el === currentActiveElement);
      this.previousFocus = this.currentFocus;
      const addition = this.tabDirection === "forward" ? 1 : -1;
      while (true) {
        if (currentFocusIndex + addition >= tabbableElements.length) {
          currentFocusIndex = 0;
        } else if (currentFocusIndex + addition < 0) {
          currentFocusIndex = tabbableElements.length - 1;
        } else {
          currentFocusIndex += addition;
        }
        this.previousFocus = this.currentFocus;
        const nextFocus = /** @type {HTMLElement} */
        tabbableElements[currentFocusIndex];
        if (this.tabDirection === "backward") {
          if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {
            return;
          }
        }
        if (nextFocus && this.possiblyHasTabbableChildren(nextFocus)) {
          return;
        }
        event.preventDefault();
        this.currentFocus = nextFocus;
        (_a = this.currentFocus) == null ? void 0 : _a.focus({
          preventScroll: false
        });
        const allActiveElements = [...activeElements()];
        if (allActiveElements.includes(this.currentFocus) || !allActiveElements.includes(this.previousFocus)) {
          break;
        }
      }
      setTimeout(() => this.checkFocus());
    };
    this.handleKeyUp = () => {
      this.tabDirection = "forward";
    };
    this.element = element;
    this.elementsWithTabbableControls = ["iframe"];
  }
  /** Activates focus trapping. */
  activate() {
    activeModals.push(this.element);
    document.addEventListener("focusin", this.handleFocusIn);
    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("keyup", this.handleKeyUp);
  }
  /** Deactivates focus trapping. */
  deactivate() {
    activeModals = activeModals.filter(modal => modal !== this.element);
    this.currentFocus = null;
    document.removeEventListener("focusin", this.handleFocusIn);
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("keyup", this.handleKeyUp);
  }
  /** Determines if this modal element is currently active or not. */
  isActive() {
    return activeModals[activeModals.length - 1] === this.element;
  }
  /** Activates external modal behavior and temporarily disables focus trapping. */
  activateExternal() {
    this.isExternalActivated = true;
  }
  /** Deactivates external modal behavior and re-enables focus trapping. */
  deactivateExternal() {
    this.isExternalActivated = false;
  }
  checkFocus() {
    if (this.isActive() && !this.isExternalActivated) {
      const tabbableElements = getTabbableElements(this.element);
      if (!this.element.matches(":focus-within")) {
        const start = tabbableElements[0];
        const end = tabbableElements[tabbableElements.length - 1];
        const target = this.tabDirection === "forward" ? start : end;
        if (typeof (target == null ? void 0 : target.focus) === "function") {
          this.currentFocus = target;
          target.focus({
            preventScroll: false
          });
        }
      }
    }
  }
  possiblyHasTabbableChildren(element) {
    return this.elementsWithTabbableControls.includes(element.tagName.toLowerCase()) || element.hasAttribute("controls");
  }
};

// src/internal/closeActiveElement.ts
var blurActiveElement = elm => {
  var _a;
  const {
    activeElement
  } = document;
  if (activeElement && elm.contains(activeElement)) {
    (_a = document.activeElement) == null ? void 0 : _a.blur();
  }
};

// src/internal/string.ts
function uppercaseFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// src/components/drawer/drawer.component.ts
var SlDrawer = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.placement = "end";
    this.contained = false;
    this.noHeader = false;
    this.handleDocumentKeyDown = event => {
      if (this.contained) {
        return;
      }
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopImmediatePropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.drawer.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unlockBodyScrolling(this);
    this.removeOpenListeners();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: {
        source
      }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "drawer.denyClose", {
        dir: this.localize.dir()
      });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a;
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      if (!this.contained) {
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => this.requestClose("keyboard");
      }
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a;
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      if (!this.contained) {
        this.modal.activate();
        lockBodyScrolling(this);
      }
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      this.drawer.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", {
          cancelable: true
        });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({
              preventScroll: true
            });
          } else {
            this.panel.focus({
              preventScroll: true
            });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, `drawer.show${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "drawer.overlay.show", {
        dir: this.localize.dir()
      });
      await Promise.all([animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options), animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)]);
      this.emit("sl-after-show");
    } else {
      blurActiveElement(this);
      this.emit("sl-hide");
      this.removeOpenListeners();
      if (!this.contained) {
        this.modal.deactivate();
        unlockBodyScrolling(this);
      }
      await Promise.all([stopAnimations(this.drawer), stopAnimations(this.overlay)]);
      const panelAnimation = getAnimation(this, `drawer.hide${uppercaseFirstLetter(this.placement)}`, {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "drawer.overlay.hide", {
        dir: this.localize.dir()
      });
      await Promise.all([animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
        this.overlay.hidden = true;
      }), animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
        this.panel.hidden = true;
      })]);
      this.drawer.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  handleNoModalChange() {
    if (this.open && !this.contained) {
      this.modal.activate();
      lockBodyScrolling(this);
    }
    if (this.open && this.contained) {
      this.modal.deactivate();
      unlockBodyScrolling(this);
    }
  }
  /** Shows the drawer. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the drawer */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      drawer: true,
      "drawer--open": this.open,
      "drawer--top": this.placement === "top",
      "drawer--end": this.placement === "end",
      "drawer--bottom": this.placement === "bottom",
      "drawer--start": this.placement === "start",
      "drawer--contained": this.contained,
      "drawer--fixed": !this.contained,
      "drawer--rtl": this.localize.dir() === "rtl",
      "drawer--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="drawer__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="drawer__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$6(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$6(!this.noHeader ? "title" : void 0)}
          tabindex="0"
        >
          ${!this.noHeader ? x`
                <header part="header" class="drawer__header">
                  <h2 part="title" class="drawer__title" id="title">
                    <!-- If there's no label, use an invisible character to prevent the header from collapsing -->
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="drawer__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="drawer__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click=${() => this.requestClose("close-button")}
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}

          <slot part="body" class="drawer__body"></slot>

          <footer part="footer" class="drawer__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDrawer.styles = [component_styles_default, drawer_styles_default];
SlDrawer.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([e$7(".drawer")], SlDrawer.prototype, "drawer", 2);
__decorateClass([e$7(".drawer__panel")], SlDrawer.prototype, "panel", 2);
__decorateClass([e$7(".drawer__overlay")], SlDrawer.prototype, "overlay", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDrawer.prototype, "open", 2);
__decorateClass([n$6({
  reflect: true
})], SlDrawer.prototype, "label", 2);
__decorateClass([n$6({
  reflect: true
})], SlDrawer.prototype, "placement", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDrawer.prototype, "contained", 2);
__decorateClass([n$6({
  attribute: "no-header",
  type: Boolean,
  reflect: true
})], SlDrawer.prototype, "noHeader", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlDrawer.prototype, "handleOpenChange", 1);
__decorateClass([watch("contained", {
  waitUntilFirstUpdate: true
})], SlDrawer.prototype, "handleNoModalChange", 1);
setDefaultAnimation("drawer.showTop", {
  keyframes: [{
    opacity: 0,
    translate: "0 -100%"
  }, {
    opacity: 1,
    translate: "0 0"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.hideTop", {
  keyframes: [{
    opacity: 1,
    translate: "0 0"
  }, {
    opacity: 0,
    translate: "0 -100%"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.showEnd", {
  keyframes: [{
    opacity: 0,
    translate: "100%"
  }, {
    opacity: 1,
    translate: "0"
  }],
  rtlKeyframes: [{
    opacity: 0,
    translate: "-100%"
  }, {
    opacity: 1,
    translate: "0"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.hideEnd", {
  keyframes: [{
    opacity: 1,
    translate: "0"
  }, {
    opacity: 0,
    translate: "100%"
  }],
  rtlKeyframes: [{
    opacity: 1,
    translate: "0"
  }, {
    opacity: 0,
    translate: "-100%"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.showBottom", {
  keyframes: [{
    opacity: 0,
    translate: "0 100%"
  }, {
    opacity: 1,
    translate: "0 0"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.hideBottom", {
  keyframes: [{
    opacity: 1,
    translate: "0 0"
  }, {
    opacity: 0,
    translate: "0 100%"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.showStart", {
  keyframes: [{
    opacity: 0,
    translate: "-100%"
  }, {
    opacity: 1,
    translate: "0"
  }],
  rtlKeyframes: [{
    opacity: 0,
    translate: "100%"
  }, {
    opacity: 1,
    translate: "0"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.hideStart", {
  keyframes: [{
    opacity: 1,
    translate: "0"
  }, {
    opacity: 0,
    translate: "-100%"
  }],
  rtlKeyframes: [{
    opacity: 1,
    translate: "0"
  }, {
    opacity: 0,
    translate: "100%"
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("drawer.denyClose", {
  keyframes: [{
    scale: 1
  }, {
    scale: 1.01
  }, {
    scale: 1
  }],
  options: {
    duration: 250
  }
});
setDefaultAnimation("drawer.overlay.show", {
  keyframes: [{
    opacity: 0
  }, {
    opacity: 1
  }],
  options: {
    duration: 250
  }
});
setDefaultAnimation("drawer.overlay.hide", {
  keyframes: [{
    opacity: 1
  }, {
    opacity: 0
  }],
  options: {
    duration: 250
  }
});

var tagName$n = "sl-drawer";
SlDrawer.define("sl-drawer");
o$8({
  tagName: tagName$n,
  elementClass: SlDrawer,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInitialFocus: "sl-initial-focus",
    onSlRequestClose: "sl-request-close"
  },
  displayName: "SlDrawer"
});

// src/components/dropdown/dropdown.styles.ts
var dropdown_styles_default = i$7`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.sync = void 0;
    this.handleKeyDown = event => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = event => {
      var _a;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a = document.activeElement) == null ? void 0 : _a.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        const computeClosestContaining = (element, tagName) => {
          if (!element) return null;
          const closest = element.closest(tagName);
          if (closest) return closest;
          const rootNode = element.getRootNode();
          if (rootNode instanceof ShadowRoot) {
            return computeClosestContaining(rootNode.host, tagName);
          }
          return null;
        };
        setTimeout(() => {
          var _a2;
          const activeElement = ((_a2 = this.containingElement) == null ? void 0 : _a2.getRootNode()) instanceof ShadowRoot ? getDeepestActiveElement() : document.activeElement;
          if (!this.containingElement || computeClosestContaining(activeElement, this.containingElement.tagName.toLowerCase()) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = event => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = event => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({
      flatten: true
    })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({
      flatten: true
    }).find(el => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({
      flatten: true
    });
    const accessibleTrigger = assignedElements.find(el => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        // Shoelace buttons have to update the internal button so it's announced correctly by screen readers
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const {
        keyframes,
        options
      } = getAnimation(this, "dropdown.show", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const {
        keyframes,
        options
      } = getAnimation(this, "dropdown.hide", {
        dir: this.localize.dir()
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return x`
      <sl-popup
        part="base"
        exportparts="popup:base__popup"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${o$6(this.sync ? this.sync : void 0)}
        class=${e$3({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = {
  "sl-popup": SlPopup
};
__decorateClass([e$7(".dropdown")], SlDropdown.prototype, "popup", 2);
__decorateClass([e$7(".dropdown__trigger")], SlDropdown.prototype, "trigger", 2);
__decorateClass([e$7(".dropdown__panel")], SlDropdown.prototype, "panel", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDropdown.prototype, "open", 2);
__decorateClass([n$6({
  reflect: true
})], SlDropdown.prototype, "placement", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDropdown.prototype, "disabled", 2);
__decorateClass([n$6({
  attribute: "stay-open-on-select",
  type: Boolean,
  reflect: true
})], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([n$6({
  attribute: false
})], SlDropdown.prototype, "containingElement", 2);
__decorateClass([n$6({
  type: Number
})], SlDropdown.prototype, "distance", 2);
__decorateClass([n$6({
  type: Number
})], SlDropdown.prototype, "skidding", 2);
__decorateClass([n$6({
  type: Boolean
})], SlDropdown.prototype, "hoist", 2);
__decorateClass([n$6({
  reflect: true
})], SlDropdown.prototype, "sync", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [{
    opacity: 0,
    scale: 0.9
  }, {
    opacity: 1,
    scale: 1
  }],
  options: {
    duration: 100,
    easing: "ease"
  }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [{
    opacity: 1,
    scale: 1
  }, {
    opacity: 0,
    scale: 0.9
  }],
  options: {
    duration: 100,
    easing: "ease"
  }
});

var tagName$m = "sl-dropdown";
SlDropdown.define("sl-dropdown");
o$8({
  tagName: tagName$m,
  elementClass: SlDropdown,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide"
  },
  displayName: "SlDropdown"
});

var SlFormatDate = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.date = /* @__PURE__ */new Date();
    this.hourFormat = "auto";
  }
  render() {
    const date = new Date(this.date);
    const hour12 = this.hourFormat === "auto" ? void 0 : this.hourFormat === "12";
    if (isNaN(date.getMilliseconds())) {
      return void 0;
    }
    return x`
      <time datetime=${date.toISOString()}>
        ${this.localize.date(date, {
      weekday: this.weekday,
      era: this.era,
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second,
      timeZoneName: this.timeZoneName,
      timeZone: this.timeZone,
      hour12
    })}
      </time>
    `;
  }
};
__decorateClass([n$6()], SlFormatDate.prototype, "date", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "weekday", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "era", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "year", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "month", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "day", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "hour", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "minute", 2);
__decorateClass([n$6()], SlFormatDate.prototype, "second", 2);
__decorateClass([n$6({
  attribute: "time-zone-name"
})], SlFormatDate.prototype, "timeZoneName", 2);
__decorateClass([n$6({
  attribute: "time-zone"
})], SlFormatDate.prototype, "timeZone", 2);
__decorateClass([n$6({
  attribute: "hour-format"
})], SlFormatDate.prototype, "hourFormat", 2);

var tagName$l = "sl-format-date";
SlFormatDate.define("sl-format-date");
o$8({
  tagName: tagName$l,
  elementClass: SlFormatDate,
  react: React$1,
  events: {},
  displayName: "SlFormatDate"
});

var SlFormatBytes = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.value = 0;
    this.unit = "byte";
    this.display = "short";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    const bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
    const bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
    const prefix = this.unit === "bit" ? bitPrefixes : bytePrefixes;
    const index = Math.max(0, Math.min(Math.floor(Math.log10(this.value) / 3), prefix.length - 1));
    const unit = prefix[index] + this.unit;
    const valueToFormat = parseFloat((this.value / Math.pow(1e3, index)).toPrecision(3));
    return this.localize.number(valueToFormat, {
      style: "unit",
      unit,
      unitDisplay: this.display
    });
  }
};
__decorateClass([n$6({
  type: Number
})], SlFormatBytes.prototype, "value", 2);
__decorateClass([n$6()], SlFormatBytes.prototype, "unit", 2);
__decorateClass([n$6()], SlFormatBytes.prototype, "display", 2);

var tagName$k = "sl-format-bytes";
SlFormatBytes.define("sl-format-bytes");
o$8({
  tagName: tagName$k,
  elementClass: SlFormatBytes,
  react: React$1,
  events: {},
  displayName: "SlFormatBytes"
});

var SlFormatNumber = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.value = 0;
    this.type = "decimal";
    this.noGrouping = false;
    this.currency = "USD";
    this.currencyDisplay = "symbol";
  }
  render() {
    if (isNaN(this.value)) {
      return "";
    }
    return this.localize.number(this.value, {
      style: this.type,
      currency: this.currency,
      currencyDisplay: this.currencyDisplay,
      useGrouping: !this.noGrouping,
      minimumIntegerDigits: this.minimumIntegerDigits,
      minimumFractionDigits: this.minimumFractionDigits,
      maximumFractionDigits: this.maximumFractionDigits,
      minimumSignificantDigits: this.minimumSignificantDigits,
      maximumSignificantDigits: this.maximumSignificantDigits
    });
  }
};
__decorateClass([n$6({
  type: Number
})], SlFormatNumber.prototype, "value", 2);
__decorateClass([n$6()], SlFormatNumber.prototype, "type", 2);
__decorateClass([n$6({
  attribute: "no-grouping",
  type: Boolean
})], SlFormatNumber.prototype, "noGrouping", 2);
__decorateClass([n$6()], SlFormatNumber.prototype, "currency", 2);
__decorateClass([n$6({
  attribute: "currency-display"
})], SlFormatNumber.prototype, "currencyDisplay", 2);
__decorateClass([n$6({
  attribute: "minimum-integer-digits",
  type: Number
})], SlFormatNumber.prototype, "minimumIntegerDigits", 2);
__decorateClass([n$6({
  attribute: "minimum-fraction-digits",
  type: Number
})], SlFormatNumber.prototype, "minimumFractionDigits", 2);
__decorateClass([n$6({
  attribute: "maximum-fraction-digits",
  type: Number
})], SlFormatNumber.prototype, "maximumFractionDigits", 2);
__decorateClass([n$6({
  attribute: "minimum-significant-digits",
  type: Number
})], SlFormatNumber.prototype, "minimumSignificantDigits", 2);
__decorateClass([n$6({
  attribute: "maximum-significant-digits",
  type: Number
})], SlFormatNumber.prototype, "maximumSignificantDigits", 2);

var tagName$j = "sl-format-number";
SlFormatNumber.define("sl-format-number");
o$8({
  tagName: tagName$j,
  elementClass: SlFormatNumber,
  react: React$1,
  events: {},
  displayName: "SlFormatNumber"
});

var tagName$i = "sl-icon";
SlIcon.define("sl-icon");
o$8({
  tagName: tagName$i,
  elementClass: SlIcon,
  react: React$1,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error"
  },
  displayName: "SlIcon"
});

var tagName$h = "sl-icon-button";
SlIconButton.define("sl-icon-button");
o$8({
  tagName: tagName$h,
  elementClass: SlIconButton,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus"
  },
  displayName: "SlIconButton"
});

var tagName$g = "sl-button-group";
SlButtonGroup.define("sl-button-group");
o$8({
  tagName: tagName$g,
  elementClass: SlButtonGroup,
  react: React$1,
  events: {},
  displayName: "SlButtonGroup"
});

// src/components/carousel/autoplay-controller.ts
var AutoplayController = class {
  constructor(host, tickCallback) {
    this.timerId = 0;
    this.activeInteractions = 0;
    this.paused = false;
    this.stopped = true;
    this.pause = () => {
      if (!this.activeInteractions++) {
        this.paused = true;
        this.host.requestUpdate();
      }
    };
    this.resume = () => {
      if (! --this.activeInteractions) {
        this.paused = false;
        this.host.requestUpdate();
      }
    };
    host.addController(this);
    this.host = host;
    this.tickCallback = tickCallback;
  }
  hostConnected() {
    this.host.addEventListener("mouseenter", this.pause);
    this.host.addEventListener("mouseleave", this.resume);
    this.host.addEventListener("focusin", this.pause);
    this.host.addEventListener("focusout", this.resume);
    this.host.addEventListener("touchstart", this.pause, {
      passive: true
    });
    this.host.addEventListener("touchend", this.resume);
  }
  hostDisconnected() {
    this.stop();
    this.host.removeEventListener("mouseenter", this.pause);
    this.host.removeEventListener("mouseleave", this.resume);
    this.host.removeEventListener("focusin", this.pause);
    this.host.removeEventListener("focusout", this.resume);
    this.host.removeEventListener("touchstart", this.pause);
    this.host.removeEventListener("touchend", this.resume);
  }
  start(interval) {
    this.stop();
    this.stopped = false;
    this.timerId = window.setInterval(() => {
      if (!this.paused) {
        this.tickCallback();
      }
    }, interval);
  }
  stop() {
    clearInterval(this.timerId);
    this.stopped = true;
    this.host.requestUpdate();
  }
};

// src/components/carousel/carousel.styles.ts
var carousel_styles_default = i$7`
  :host {
    --slide-gap: var(--sl-spacing-medium, 1rem);
    --aspect-ratio: 16 / 9;
    --scroll-hint: 0px;

    display: flex;
  }

  .carousel {
    display: grid;
    grid-template-columns: min-content 1fr min-content;
    grid-template-rows: 1fr min-content;
    grid-template-areas:
      '. slides .'
      '. pagination .';
    gap: var(--sl-spacing-medium);
    align-items: center;
    min-height: 100%;
    min-width: 100%;
    position: relative;
  }

  .carousel__pagination {
    grid-area: pagination;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: var(--sl-spacing-small);
  }

  .carousel__slides {
    grid-area: slides;

    display: grid;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-items: center;
    overflow: auto;
    overscroll-behavior-x: contain;
    scrollbar-width: none;
    aspect-ratio: calc(var(--aspect-ratio) * var(--slides-per-page));
    border-radius: var(--sl-border-radius-small);

    --slide-size: calc((100% - (var(--slides-per-page) - 1) * var(--slide-gap)) / var(--slides-per-page));
  }

  @media (prefers-reduced-motion) {
    :where(.carousel__slides) {
      scroll-behavior: auto;
    }
  }

  .carousel__slides--horizontal {
    grid-auto-flow: column;
    grid-auto-columns: var(--slide-size);
    grid-auto-rows: 100%;
    column-gap: var(--slide-gap);
    scroll-snap-type: x mandatory;
    scroll-padding-inline: var(--scroll-hint);
    padding-inline: var(--scroll-hint);
    overflow-y: hidden;
  }

  .carousel__slides--vertical {
    grid-auto-flow: row;
    grid-auto-columns: 100%;
    grid-auto-rows: var(--slide-size);
    row-gap: var(--slide-gap);
    scroll-snap-type: y mandatory;
    scroll-padding-block: var(--scroll-hint);
    padding-block: var(--scroll-hint);
    overflow-x: hidden;
  }

  .carousel__slides--dragging {
  }

  :host([vertical]) ::slotted(sl-carousel-item) {
    height: 100%;
  }

  .carousel__slides::-webkit-scrollbar {
    display: none;
  }

  .carousel__navigation {
    grid-area: navigation;
    display: contents;
    font-size: var(--sl-font-size-x-large);
  }

  .carousel__navigation-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-small);
    font-size: inherit;
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-medium) color;
    appearance: none;
  }

  .carousel__navigation-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .carousel__navigation-button--disabled::part(base) {
    pointer-events: none;
  }

  .carousel__navigation-button--previous {
    grid-column: 1;
    grid-row: 1;
  }

  .carousel__navigation-button--next {
    grid-column: 3;
    grid-row: 1;
  }

  .carousel__pagination-item {
    display: block;
    cursor: pointer;
    background: none;
    border: 0;
    border-radius: var(--sl-border-radius-circle);
    width: var(--sl-spacing-small);
    height: var(--sl-spacing-small);
    background-color: var(--sl-color-neutral-300);
    padding: 0;
    margin: 0;
  }

  .carousel__pagination-item--active {
    background-color: var(--sl-color-neutral-700);
    transform: scale(1.2);
  }

  /* Focus styles */
  .carousel__slides:focus-visible,
  .carousel__navigation-button:focus-visible,
  .carousel__pagination-item:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }
`;

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o$1(o, f) {
  if (void 0 !== o) {
    let i = 0;
    for (const t of o) yield f(t, i++);
  }
}

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function* o(o, t, e = 1) {
  const i = void 0 === t ? 0 : o;
  t ??= o;
  for (let o = i; e > 0 ? o < t : t < o; o += e) yield o;
}

var SlCarousel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.loop = false;
    this.navigation = false;
    this.pagination = false;
    this.autoplay = false;
    this.autoplayInterval = 3e3;
    this.slidesPerPage = 1;
    this.slidesPerMove = 1;
    this.orientation = "horizontal";
    this.mouseDragging = false;
    this.activeSlide = 0;
    this.scrolling = false;
    this.dragging = false;
    this.autoplayController = new AutoplayController(this, () => this.next());
    this.dragStartPosition = [-1, -1];
    this.localize = new LocalizeController(this);
    this.pendingSlideChange = false;
    this.handleMouseDrag = event => {
      if (!this.dragging) {
        this.scrollContainer.style.setProperty("scroll-snap-type", "none");
        this.dragging = true;
        this.dragStartPosition = [event.clientX, event.clientY];
      }
      this.scrollContainer.scrollBy({
        left: -event.movementX,
        top: -event.movementY,
        behavior: "instant"
      });
    };
    this.handleMouseDragEnd = () => {
      const scrollContainer = this.scrollContainer;
      document.removeEventListener("pointermove", this.handleMouseDrag, {
        capture: true
      });
      const startLeft = scrollContainer.scrollLeft;
      const startTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("scroll-snap-type");
      scrollContainer.style.setProperty("overflow", "hidden");
      const finalLeft = scrollContainer.scrollLeft;
      const finalTop = scrollContainer.scrollTop;
      scrollContainer.style.removeProperty("overflow");
      scrollContainer.style.setProperty("scroll-snap-type", "none");
      scrollContainer.scrollTo({
        left: startLeft,
        top: startTop,
        behavior: "instant"
      });
      requestAnimationFrame(async () => {
        if (startLeft !== finalLeft || startTop !== finalTop) {
          scrollContainer.scrollTo({
            left: finalLeft,
            top: finalTop,
            behavior: prefersReducedMotion() ? "auto" : "smooth"
          });
          await waitForEvent(scrollContainer, "scrollend");
        }
        scrollContainer.style.removeProperty("scroll-snap-type");
        this.dragging = false;
        this.dragStartPosition = [-1, -1];
        this.handleScrollEnd();
      });
    };
    this.handleSlotChange = mutations => {
      const needsInitialization = mutations.some(mutation => [...mutation.addedNodes, ...mutation.removedNodes].some(el => this.isCarouselItem(el) && !el.hasAttribute("data-clone")));
      if (needsInitialization) {
        this.initializeSlides();
      }
      this.requestUpdate();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "region");
    this.setAttribute("aria-label", this.localize.term("carousel"));
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
  }
  firstUpdated() {
    this.initializeSlides();
    this.mutationObserver = new MutationObserver(this.handleSlotChange);
    this.mutationObserver.observe(this, {
      childList: true,
      subtree: true
    });
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("slidesPerMove") || changedProperties.has("slidesPerPage")) {
      this.slidesPerMove = Math.min(this.slidesPerMove, this.slidesPerPage);
    }
  }
  getPageCount() {
    const slidesCount = this.getSlides().length;
    const {
      slidesPerPage,
      slidesPerMove,
      loop
    } = this;
    const pages = loop ? slidesCount / slidesPerMove : (slidesCount - slidesPerPage) / slidesPerMove + 1;
    return Math.ceil(pages);
  }
  getCurrentPage() {
    return Math.ceil(this.activeSlide / this.slidesPerMove);
  }
  canScrollNext() {
    return this.loop || this.getCurrentPage() < this.getPageCount() - 1;
  }
  canScrollPrev() {
    return this.loop || this.getCurrentPage() > 0;
  }
  /** @internal Gets all carousel items. */
  getSlides({
    excludeClones = true
  } = {}) {
    return [...this.children].filter(el => this.isCarouselItem(el) && (!excludeClones || !el.hasAttribute("data-clone")));
  }
  handleClick(event) {
    if (this.dragging && this.dragStartPosition[0] > 0 && this.dragStartPosition[1] > 0) {
      const deltaX = Math.abs(this.dragStartPosition[0] - event.clientX);
      const deltaY = Math.abs(this.dragStartPosition[1] - event.clientY);
      const delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      if (delta >= 10) {
        event.preventDefault();
      }
    }
  }
  handleKeyDown(event) {
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const target = event.target;
      const isRtl = this.localize.dir() === "rtl";
      const isFocusInPagination = target.closest('[part~="pagination-item"]') !== null;
      const isNext = event.key === "ArrowDown" || !isRtl && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft";
      const isPrevious = event.key === "ArrowUp" || !isRtl && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight";
      event.preventDefault();
      if (isPrevious) {
        this.previous();
      }
      if (isNext) {
        this.next();
      }
      if (event.key === "Home") {
        this.goToSlide(0);
      }
      if (event.key === "End") {
        this.goToSlide(this.getSlides().length - 1);
      }
      if (isFocusInPagination) {
        this.updateComplete.then(() => {
          var _a;
          const activePaginationItem = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector('[part~="pagination-item--active"]');
          if (activePaginationItem) {
            activePaginationItem.focus();
          }
        });
      }
    }
  }
  handleMouseDragStart(event) {
    const canDrag = this.mouseDragging && event.button === 0;
    if (canDrag) {
      event.preventDefault();
      document.addEventListener("pointermove", this.handleMouseDrag, {
        capture: true,
        passive: true
      });
      document.addEventListener("pointerup", this.handleMouseDragEnd, {
        capture: true,
        once: true
      });
    }
  }
  handleScroll() {
    this.scrolling = true;
    if (!this.pendingSlideChange) {
      this.synchronizeSlides();
    }
  }
  /** @internal Synchronizes the slides with the IntersectionObserver API. */
  synchronizeSlides() {
    const io = new IntersectionObserver(entries => {
      io.disconnect();
      for (const entry of entries) {
        const slide = entry.target;
        slide.toggleAttribute("inert", !entry.isIntersecting);
        slide.classList.toggle("--in-view", entry.isIntersecting);
        slide.setAttribute("aria-hidden", entry.isIntersecting ? "false" : "true");
      }
      const firstIntersecting = entries.find(entry => entry.isIntersecting);
      if (!firstIntersecting) {
        return;
      }
      const slidesWithClones = this.getSlides({
        excludeClones: false
      });
      const slidesCount = this.getSlides().length;
      const slideIndex = slidesWithClones.indexOf(firstIntersecting.target);
      const normalizedIndex = this.loop ? slideIndex - this.slidesPerPage : slideIndex;
      this.activeSlide = (Math.ceil(normalizedIndex / this.slidesPerMove) * this.slidesPerMove + slidesCount) % slidesCount;
      if (!this.scrolling) {
        if (this.loop && firstIntersecting.target.hasAttribute("data-clone")) {
          const clonePosition = Number(firstIntersecting.target.getAttribute("data-clone"));
          this.goToSlide(clonePosition, "instant");
        }
      }
    }, {
      root: this.scrollContainer,
      threshold: 0.6
    });
    this.getSlides({
      excludeClones: false
    }).forEach(slide => {
      io.observe(slide);
    });
  }
  handleScrollEnd() {
    if (!this.scrolling || this.dragging) return;
    this.scrolling = false;
    this.pendingSlideChange = false;
    this.synchronizeSlides();
  }
  isCarouselItem(node) {
    return node instanceof Element && node.tagName.toLowerCase() === "sl-carousel-item";
  }
  initializeSlides() {
    this.getSlides({
      excludeClones: false
    }).forEach((slide, index) => {
      slide.classList.remove("--in-view");
      slide.classList.remove("--is-active");
      slide.setAttribute("role", "group");
      slide.setAttribute("aria-label", this.localize.term("slideNum", index + 1));
      if (this.pagination) {
        slide.setAttribute("id", `slide-${index + 1}`);
        slide.setAttribute("role", "tabpanel");
        slide.removeAttribute("aria-label");
        slide.setAttribute("aria-labelledby", `tab-${index + 1}`);
      }
      if (slide.hasAttribute("data-clone")) {
        slide.remove();
      }
    });
    this.updateSlidesSnap();
    if (this.loop) {
      this.createClones();
    }
    this.goToSlide(this.activeSlide, "auto");
    this.synchronizeSlides();
  }
  createClones() {
    const slides = this.getSlides();
    const slidesPerPage = this.slidesPerPage;
    const lastSlides = slides.slice(-slidesPerPage);
    const firstSlides = slides.slice(0, slidesPerPage);
    lastSlides.reverse().forEach((slide, i) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(slides.length - i - 1));
      this.prepend(clone);
    });
    firstSlides.forEach((slide, i) => {
      const clone = slide.cloneNode(true);
      clone.setAttribute("data-clone", String(i));
      this.append(clone);
    });
  }
  handleSlideChange() {
    const slides = this.getSlides();
    slides.forEach((slide, i) => {
      slide.classList.toggle("--is-active", i === this.activeSlide);
    });
    if (this.hasUpdated) {
      this.emit("sl-slide-change", {
        detail: {
          index: this.activeSlide,
          slide: slides[this.activeSlide]
        }
      });
    }
  }
  updateSlidesSnap() {
    const slides = this.getSlides();
    const slidesPerMove = this.slidesPerMove;
    slides.forEach((slide, i) => {
      const shouldSnap = (i + slidesPerMove) % slidesPerMove === 0;
      if (shouldSnap) {
        slide.style.removeProperty("scroll-snap-align");
      } else {
        slide.style.setProperty("scroll-snap-align", "none");
      }
    });
  }
  handleAutoplayChange() {
    this.autoplayController.stop();
    if (this.autoplay) {
      this.autoplayController.start(this.autoplayInterval);
    }
  }
  /**
   * Move the carousel backward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  previous(behavior = "smooth") {
    this.goToSlide(this.activeSlide - this.slidesPerMove, behavior);
  }
  /**
   * Move the carousel forward by `slides-per-move` slides.
   *
   * @param behavior - The behavior used for scrolling.
   */
  next(behavior = "smooth") {
    this.goToSlide(this.activeSlide + this.slidesPerMove, behavior);
  }
  /**
   * Scrolls the carousel to the slide specified by `index`.
   *
   * @param index - The slide index.
   * @param behavior - The behavior used for scrolling.
   */
  goToSlide(index, behavior = "smooth") {
    const {
      slidesPerPage,
      loop
    } = this;
    const slides = this.getSlides();
    const slidesWithClones = this.getSlides({
      excludeClones: false
    });
    if (!slides.length) {
      return;
    }
    const newActiveSlide = loop ? (index + slides.length) % slides.length : clamp(index, 0, slides.length - slidesPerPage);
    this.activeSlide = newActiveSlide;
    const isRtl = this.localize.dir() === "rtl";
    const nextSlideIndex = clamp(index + (loop ? slidesPerPage : 0) + (isRtl ? slidesPerPage - 1 : 0), 0, slidesWithClones.length - 1);
    const nextSlide = slidesWithClones[nextSlideIndex];
    this.scrollToSlide(nextSlide, prefersReducedMotion() ? "auto" : behavior);
  }
  scrollToSlide(slide, behavior = "smooth") {
    this.pendingSlideChange = true;
    window.requestAnimationFrame(() => {
      if (!this.scrollContainer) {
        return;
      }
      const scrollContainer = this.scrollContainer;
      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      const nextSlideRect = slide.getBoundingClientRect();
      const nextLeft = nextSlideRect.left - scrollContainerRect.left;
      const nextTop = nextSlideRect.top - scrollContainerRect.top;
      if (nextLeft || nextTop) {
        this.pendingSlideChange = true;
        scrollContainer.scrollTo({
          left: nextLeft + scrollContainer.scrollLeft,
          top: nextTop + scrollContainer.scrollTop,
          behavior
        });
      } else {
        this.pendingSlideChange = false;
      }
    });
  }
  render() {
    const {
      slidesPerMove,
      scrolling
    } = this;
    const pagesCount = this.getPageCount();
    const currentPage = this.getCurrentPage();
    const prevEnabled = this.canScrollPrev();
    const nextEnabled = this.canScrollNext();
    const isLtr = this.localize.dir() === "ltr";
    return x`
      <div part="base" class="carousel">
        <div
          id="scroll-container"
          part="scroll-container"
          class="${e$3({
      carousel__slides: true,
      "carousel__slides--horizontal": this.orientation === "horizontal",
      "carousel__slides--vertical": this.orientation === "vertical",
      "carousel__slides--dragging": this.dragging
    })}"
          style="--slides-per-page: ${this.slidesPerPage};"
          aria-busy="${scrolling ? "true" : "false"}"
          aria-atomic="true"
          tabindex="0"
          @keydown=${this.handleKeyDown}
          @mousedown="${this.handleMouseDragStart}"
          @scroll="${this.handleScroll}"
          @scrollend=${this.handleScrollEnd}
          @click=${this.handleClick}
        >
          <slot></slot>
        </div>

        ${this.navigation ? x`
              <div part="navigation" class="carousel__navigation">
                <button
                  part="navigation-button navigation-button--previous"
                  class="${e$3({
      "carousel__navigation-button": true,
      "carousel__navigation-button--previous": true,
      "carousel__navigation-button--disabled": !prevEnabled
    })}"
                  aria-label="${this.localize.term("previousSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${prevEnabled ? "false" : "true"}"
                  @click=${prevEnabled ? () => this.previous() : null}
                >
                  <slot name="previous-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-left" : "chevron-right"}"></sl-icon>
                  </slot>
                </button>

                <button
                  part="navigation-button navigation-button--next"
                  class=${e$3({
      "carousel__navigation-button": true,
      "carousel__navigation-button--next": true,
      "carousel__navigation-button--disabled": !nextEnabled
    })}
                  aria-label="${this.localize.term("nextSlide")}"
                  aria-controls="scroll-container"
                  aria-disabled="${nextEnabled ? "false" : "true"}"
                  @click=${nextEnabled ? () => this.next() : null}
                >
                  <slot name="next-icon">
                    <sl-icon library="system" name="${isLtr ? "chevron-right" : "chevron-left"}"></sl-icon>
                  </slot>
                </button>
              </div>
            ` : ""}
        ${this.pagination ? x`
              <div part="pagination" role="tablist" class="carousel__pagination">
                ${o$1(o(pagesCount), index => {
      const isActive = index === currentPage;
      return x`
                    <button
                      part="pagination-item ${isActive ? "pagination-item--active" : ""}"
                      class="${e$3({
        "carousel__pagination-item": true,
        "carousel__pagination-item--active": isActive
      })}"
                      role="tab"
                      id="tab-${index + 1}"
                      aria-controls="slide-${index + 1}"
                      aria-selected="${isActive ? "true" : "false"}"
                      aria-label="${isActive ? this.localize.term("slideNum", index + 1) : this.localize.term("goToSlide", index + 1, pagesCount)}"
                      tabindex=${isActive ? "0" : "-1"}
                      @click=${() => this.goToSlide(index * slidesPerMove)}
                      @keydown=${this.handleKeyDown}
                    ></button>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlCarousel.styles = [component_styles_default, carousel_styles_default];
SlCarousel.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCarousel.prototype, "loop", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCarousel.prototype, "navigation", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCarousel.prototype, "pagination", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCarousel.prototype, "autoplay", 2);
__decorateClass([n$6({
  type: Number,
  attribute: "autoplay-interval"
})], SlCarousel.prototype, "autoplayInterval", 2);
__decorateClass([n$6({
  type: Number,
  attribute: "slides-per-page"
})], SlCarousel.prototype, "slidesPerPage", 2);
__decorateClass([n$6({
  type: Number,
  attribute: "slides-per-move"
})], SlCarousel.prototype, "slidesPerMove", 2);
__decorateClass([n$6()], SlCarousel.prototype, "orientation", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true,
  attribute: "mouse-dragging"
})], SlCarousel.prototype, "mouseDragging", 2);
__decorateClass([e$7(".carousel__slides")], SlCarousel.prototype, "scrollContainer", 2);
__decorateClass([e$7(".carousel__pagination")], SlCarousel.prototype, "paginationContainer", 2);
__decorateClass([r$3()], SlCarousel.prototype, "activeSlide", 2);
__decorateClass([r$3()], SlCarousel.prototype, "scrolling", 2);
__decorateClass([r$3()], SlCarousel.prototype, "dragging", 2);
__decorateClass([t$2({
  passive: true
})], SlCarousel.prototype, "handleScroll", 1);
__decorateClass([watch("loop", {
  waitUntilFirstUpdate: true
}), watch("slidesPerPage", {
  waitUntilFirstUpdate: true
})], SlCarousel.prototype, "initializeSlides", 1);
__decorateClass([watch("activeSlide")], SlCarousel.prototype, "handleSlideChange", 1);
__decorateClass([watch("slidesPerMove")], SlCarousel.prototype, "updateSlidesSnap", 1);
__decorateClass([watch("autoplay")], SlCarousel.prototype, "handleAutoplayChange", 1);

var tagName$f = "sl-carousel";
SlCarousel.define("sl-carousel");
o$8({
  tagName: tagName$f,
  elementClass: SlCarousel,
  react: React$1,
  events: {
    onSlSlideChange: "sl-slide-change"
  },
  displayName: "SlCarousel"
});

// src/components/carousel-item/carousel-item.styles.ts
var carousel_item_styles_default = i$7`
  :host {
    --aspect-ratio: inherit;

    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    width: 100%;
    max-height: 100%;
    aspect-ratio: var(--aspect-ratio);
    scroll-snap-align: start;
    scroll-snap-stop: always;
  }

  ::slotted(img) {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
`;

var SlCarouselItem = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
  }
  render() {
    return x` <slot></slot> `;
  }
};
SlCarouselItem.styles = [component_styles_default, carousel_item_styles_default];

var tagName$e = "sl-carousel-item";
SlCarouselItem.define("sl-carousel-item");
o$8({
  tagName: tagName$e,
  elementClass: SlCarouselItem,
  react: React$1,
  events: {},
  displayName: "SlCarouselItem"
});

var tagName$d = "sl-checkbox";
SlCheckbox.define("sl-checkbox");
o$8({
  tagName: tagName$d,
  elementClass: SlCheckbox,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlCheckbox"
});

// src/components/color-picker/color-picker.styles.ts
var color_picker_styles_default = i$7`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? i$2`a` : i$2`button`;
    return u`
      <${tag}
        part="base"
        class=${e$3({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${o$6(isLink ? void 0 : this.disabled)}
        type=${o$6(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${o$6(isLink ? void 0 : this.name)}
        value=${o$6(isLink ? void 0 : this.value)}
        href=${o$6(isLink && !this.disabled ? this.href : void 0)}
        target=${o$6(isLink ? this.target : void 0)}
        download=${o$6(isLink ? this.download : void 0)}
        rel=${o$6(isLink ? this.rel : void 0)}
        role=${o$6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? u` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? u`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([e$7(".button")], SlButton.prototype, "button", 2);
__decorateClass([r$3()], SlButton.prototype, "hasFocus", 2);
__decorateClass([r$3()], SlButton.prototype, "invalid", 2);
__decorateClass([n$6()], SlButton.prototype, "title", 2);
__decorateClass([n$6({
  reflect: true
})], SlButton.prototype, "variant", 2);
__decorateClass([n$6({
  reflect: true
})], SlButton.prototype, "size", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "caret", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "loading", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "outline", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "pill", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlButton.prototype, "circle", 2);
__decorateClass([n$6()], SlButton.prototype, "type", 2);
__decorateClass([n$6()], SlButton.prototype, "name", 2);
__decorateClass([n$6()], SlButton.prototype, "value", 2);
__decorateClass([n$6()], SlButton.prototype, "href", 2);
__decorateClass([n$6()], SlButton.prototype, "target", 2);
__decorateClass([n$6()], SlButton.prototype, "rel", 2);
__decorateClass([n$6()], SlButton.prototype, "download", 2);
__decorateClass([n$6()], SlButton.prototype, "form", 2);
__decorateClass([n$6({
  attribute: "formaction"
})], SlButton.prototype, "formAction", 2);
__decorateClass([n$6({
  attribute: "formenctype"
})], SlButton.prototype, "formEnctype", 2);
__decorateClass([n$6({
  attribute: "formmethod"
})], SlButton.prototype, "formMethod", 2);
__decorateClass([n$6({
  attribute: "formnovalidate",
  type: Boolean
})], SlButton.prototype, "formNoValidate", 2);
__decorateClass([n$6({
  attribute: "formtarget"
})], SlButton.prototype, "formTarget", 2);
__decorateClass([watch("disabled", {
  waitUntilFirstUpdate: true
})], SlButton.prototype, "handleDisabledChange", 1);

/**
 * Take input from [0, n] and return it as [0, 1]
 * @hidden
 */
function bound01(n, max) {
  if (isOnePointZero(n)) {
    n = '100%';
  }
  const isPercent = isPercentage(n);
  n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
  // Automatically convert percentage into number
  if (isPercent) {
    n = parseInt(String(n * max), 10) / 100;
  }
  // Handle floating point rounding errors
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }
  // Convert into [0, 1] range if it isn't already
  if (max === 360) {
    // If n is a hue given in degrees,
    // wrap around out-of-range values into [0, 360] range
    // then convert into [0, 1].
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
  } else {
    // If n not a hue given in degrees
    // Convert into [0, 1] range if it isn't already.
    n = n % max / parseFloat(String(max));
  }
  return n;
}
/**
 * Force a number between 0 and 1
 * @hidden
 */
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
/**
 * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
 * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
 * @hidden
 */
function isOnePointZero(n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
}
/**
 * Check to see if string passed in is a percentage
 * @hidden
 */
function isPercentage(n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
}
/**
 * Return a valid alpha value [0,1] with all invalid values being set to 1
 * @hidden
 */
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
/**
 * Replace a decimal with it's percentage value
 * @hidden
 */
function convertToPercentage(n) {
  if (Number(n) <= 1) {
    return `${Number(n) * 100}%`;
  }
  return n;
}
/**
 * Force a hex value to have 2 characters
 * @hidden
 */
function pad2(c) {
  return c.length === 1 ? '0' + c : String(c);
}

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
/**
 * Handle bounds / percentage checking to conform to CSS color spec
 * <http://www.w3.org/TR/css3-color/>
 * *Assumes:* r, g, b in [0, 255] or [0, 1]
 * *Returns:* { r, g, b } in [0, 255]
 */
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
/**
 * Converts an RGB color value to HSL.
 * *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
 * *Returns:* { h, s, l } in [0,1]
 */
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;
  if (max === min) {
    s = 0;
    h = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l
  };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * (6 * t);
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
/**
 * Converts an HSL color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */
function hslToRgb(h, s, l) {
  let r;
  let g;
  let b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    // achromatic
    g = l;
    b = l;
    r = l;
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
/**
 * Converts an RGB color value to HSV
 *
 * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
 * *Returns:* { h, s, v } in [0,1]
 */
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  const v = max;
  const d = max - min;
  const s = max === 0 ? 0 : d / max;
  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v
  };
}
/**
 * Converts an HSV color value to RGB.
 *
 * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
 * *Returns:* { r, g, b } in the set [0, 255]
 */
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
/**
 * Converts an RGB color to hex
 *
 * *Assumes:* r, g, and b are contained in the set [0, 255]
 * *Returns:* a 3 or 6 character hex
 */
function rgbToHex(r, g, b, allow3Char) {
  const hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  // Return a 3 character hex if possible
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join('');
}
/**
 * Converts an RGBA color plus alpha transparency to hex
 *
 * *Assumes:* r, g, b are contained in the set [0, 255] and a in [0, 1]
 * *Returns:* a 4 or 8 character rgba hex
 */
// eslint-disable-next-line max-params
function rgbaToHex(r, g, b, a, allow4Char) {
  const hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  // Return a 4 character hex if possible
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join('');
}
/**
 * Converts CMYK to RBG
 * Assumes c, m, y, k are in the set [0, 100]
 */
function cmykToRgb(c, m, y, k) {
  const cConv = c / 100;
  const mConv = m / 100;
  const yConv = y / 100;
  const kConv = k / 100;
  const r = 255 * (1 - cConv) * (1 - kConv);
  const g = 255 * (1 - mConv) * (1 - kConv);
  const b = 255 * (1 - yConv) * (1 - kConv);
  return {
    r,
    g,
    b
  };
}
function rgbToCmyk(r, g, b) {
  let c = 1 - r / 255;
  let m = 1 - g / 255;
  let y = 1 - b / 255;
  let k = Math.min(c, m, y);
  if (k === 1) {
    c = 0;
    m = 0;
    y = 0;
  } else {
    c = (c - k) / (1 - k) * 100;
    m = (m - k) / (1 - k) * 100;
    y = (y - k) / (1 - k) * 100;
  }
  k *= 100;
  return {
    c: Math.round(c),
    m: Math.round(m),
    y: Math.round(y),
    k: Math.round(k)
  };
}
/** Converts a decimal to a hex value */
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
/** Converts a hex value to a decimal */
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
/** Parse a base-16 hex value into a base-10 integer */
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 0xff00) >> 8,
    b: color & 0xff
  };
}

// https://github.com/bahamas10/css-color-names/blob/master/css-color-names.json
/**
 * @hidden
 */
const names = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkgrey: '#a9a9a9',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkslategrey: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dimgrey: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  goldenrod: '#daa520',
  gold: '#ffd700',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  grey: '#808080',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavenderblush: '#fff0f5',
  lavender: '#e6e6fa',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgray: '#d3d3d3',
  lightgreen: '#90ee90',
  lightgrey: '#d3d3d3',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightslategrey: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370db',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#db7093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  slategrey: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

/**
 * Given a string or object, convert that input to RGB
 *
 * Possible string inputs:
 * ```
 * "red"
 * "#f00" or "f00"
 * "#ff0000" or "ff0000"
 * "#ff000000" or "ff000000"
 * "rgb 255 0 0" or "rgb (255, 0, 0)"
 * "rgb 1.0 0 0" or "rgb (1, 0, 0)"
 * "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
 * "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
 * "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
 * "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
 * "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
 * "cmyk(0, 20, 0, 0)" or "cmyk 0 20 0 0"
 * ```
 */
function inputToRGB(color) {
  let rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  let a = 1;
  let s = null;
  let v = null;
  let l = null;
  let ok = false;
  let format = false;
  if (typeof color === 'string') {
    color = stringInputToObject(color);
  }
  if (typeof color === 'object') {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = 'hsv';
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = 'hsl';
    } else if (isValidCSSUnit(color.c) && isValidCSSUnit(color.m) && isValidCSSUnit(color.y) && isValidCSSUnit(color.k)) {
      rgb = cmykToRgb(color.c, color.m, color.y, color.k);
      ok = true;
      format = 'cmyk';
    }
    if (Object.prototype.hasOwnProperty.call(color, 'a')) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
// <http://www.w3.org/TR/css3-values/#integers>
const CSS_INTEGER = '[-\\+]?\\d+%?';
// <http://www.w3.org/TR/css3-values/#number-value>
const CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
const CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';
// Actual matching.
// Parentheses and commas are optional, but not required.
// Whitespace can take the place of commas or opening paren
// eslint-disable-next-line prettier/prettier
const PERMISSIVE_MATCH3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
const PERMISSIVE_MATCH4 =
// eslint-disable-next-line prettier/prettier
'[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
const matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
  rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
  hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
  hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
  hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
  hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
  cmyk: new RegExp('cmyk' + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
/**
 * Permissive string parsing.  Take in a number of formats, and output an object
 * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}` or `{c, m, y, k}` or `{c, m, y, k, a}`
 */
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  let named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === 'transparent') {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: 'name'
    };
  }
  // Try to match string input using regular expressions.
  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
  // Just return an object and let the conversion functions handle that.
  // This way the result will be the same whether the tinycolor is initialized with string or object.
  let match = matchers.rgb.exec(color);
  if (match) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  match = matchers.cmyk.exec(color);
  if (match) {
    return {
      c: match[1],
      m: match[2],
      y: match[3],
      k: match[4]
    };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? 'name' : 'hex8'
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? 'name' : 'hex'
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? 'name' : 'hex8'
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? 'name' : 'hex'
    };
  }
  return false;
}
/**
 * Check to see if it looks like a CSS unit
 * (see `matchers` above for definition).
 */
function isValidCSSUnit(color) {
  if (typeof color === 'number') {
    return !Number.isNaN(color);
  }
  return matchers.CSS_UNIT.test(color);
}

class TinyColor {
  constructor(color = '', opts = {}) {
    // If input is already a tinycolor, return itself
    if (color instanceof TinyColor) {
      // eslint-disable-next-line no-constructor-return
      return color;
    }
    if (typeof color === 'number') {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    const rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = opts.format ?? rgb.format;
    this.gradientType = opts.gradientType;
    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return !this.isDark();
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   */
  getBrightness() {
    // http://www.w3.org/TR/AERT#color-contrast
    const rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  }
  /**
   * Returns the perceived luminance of a color, from 0-1.
   */
  getLuminance() {
    // http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
    const rgb = this.toRgb();
    let R;
    let G;
    let B;
    const RsRGB = rgb.r / 255;
    const GsRGB = rgb.g / 255;
    const BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R = RsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B = BsRGB / 12.92;
    } else {
      // eslint-disable-next-line prefer-exponentiation-operator
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  }
  /**
   * Returns the alpha value of a color, from 0-1.
   */
  getAlpha() {
    return this.a;
  }
  /**
   * Sets the alpha value on the current color.
   *
   * @param alpha - The new alpha value. The accepted range is 0-1.
   */
  setAlpha(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  }
  /**
   * Returns whether the color is monochrome.
   */
  isMonochrome() {
    const {
      s
    } = this.toHsl();
    return s === 0;
  }
  /**
   * Returns the object as a HSVA object.
   */
  toHsv() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this.a
    };
  }
  /**
   * Returns the hsva values interpolated into a string with the following format:
   * "hsva(xxx, xxx, xxx, xx)".
   */
  toHsvString() {
    const hsv = rgbToHsv(this.r, this.g, this.b);
    const h = Math.round(hsv.h * 360);
    const s = Math.round(hsv.s * 100);
    const v = Math.round(hsv.v * 100);
    return this.a === 1 ? `hsv(${h}, ${s}%, ${v}%)` : `hsva(${h}, ${s}%, ${v}%, ${this.roundA})`;
  }
  /**
   * Returns the object as a HSLA object.
   */
  toHsl() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this.a
    };
  }
  /**
   * Returns the hsla values interpolated into a string with the following format:
   * "hsla(xxx, xxx, xxx, xx)".
   */
  toHslString() {
    const hsl = rgbToHsl(this.r, this.g, this.b);
    const h = Math.round(hsl.h * 360);
    const s = Math.round(hsl.s * 100);
    const l = Math.round(hsl.l * 100);
    return this.a === 1 ? `hsl(${h}, ${s}%, ${l}%)` : `hsla(${h}, ${s}%, ${l}%, ${this.roundA})`;
  }
  /**
   * Returns the hex value of the color.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHex(allow3Char = false) {
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  }
  /**
   * Returns the hex value of the color -with a # prefixed.
   * @param allow3Char will shorten hex value to 3 char if possible
   */
  toHexString(allow3Char = false) {
    return '#' + this.toHex(allow3Char);
  }
  /**
   * Returns the hex 8 value of the color.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8(allow4Char = false) {
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  }
  /**
   * Returns the hex 8 value of the color -with a # prefixed.
   * @param allow4Char will shorten hex value to 4 char if possible
   */
  toHex8String(allow4Char = false) {
    return '#' + this.toHex8(allow4Char);
  }
  /**
   * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
   * @param allowShortChar will shorten hex value to 3 or 4 char if possible
   */
  toHexShortString(allowShortChar = false) {
    return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
  }
  /**
   * Returns the object as a RGBA object.
   */
  toRgb() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA values interpolated into a string with the following format:
   * "RGBA(xxx, xxx, xxx, xx)".
   */
  toRgbString() {
    const r = Math.round(this.r);
    const g = Math.round(this.g);
    const b = Math.round(this.b);
    return this.a === 1 ? `rgb(${r}, ${g}, ${b})` : `rgba(${r}, ${g}, ${b}, ${this.roundA})`;
  }
  /**
   * Returns the object as a RGBA object.
   */
  toPercentageRgb() {
    const fmt = x => `${Math.round(bound01(x, 255) * 100)}%`;
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  }
  /**
   * Returns the RGBA relative values interpolated into a string
   */
  toPercentageRgbString() {
    const rnd = x => Math.round(bound01(x, 255) * 100);
    return this.a === 1 ? `rgb(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%)` : `rgba(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%, ${this.roundA})`;
  }
  toCmyk() {
    return {
      ...rgbToCmyk(this.r, this.g, this.b)
    };
  }
  toCmykString() {
    const {
      c,
      m,
      y,
      k
    } = rgbToCmyk(this.r, this.g, this.b);
    return `cmyk(${c}, ${m}, ${y}, ${k})`;
  }
  /**
   * The 'real' name of the color -if there is one.
   */
  toName() {
    if (this.a === 0) {
      return 'transparent';
    }
    if (this.a < 1) {
      return false;
    }
    const hex = '#' + rgbToHex(this.r, this.g, this.b, false);
    for (const [key, value] of Object.entries(names)) {
      if (hex === value) {
        return key;
      }
    }
    return false;
  }
  toString(format) {
    const formatSet = Boolean(format);
    format = format ?? this.format;
    let formattedString = false;
    const hasAlpha = this.a < 1 && this.a >= 0;
    const needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith('hex') || format === 'name');
    if (needsAlphaFormat) {
      // Special case for "transparent", all other non-alpha formats
      // will return rgba when there is transparency.
      if (format === 'name' && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === 'rgb') {
      formattedString = this.toRgbString();
    }
    if (format === 'prgb') {
      formattedString = this.toPercentageRgbString();
    }
    if (format === 'hex' || format === 'hex6') {
      formattedString = this.toHexString();
    }
    if (format === 'hex3') {
      formattedString = this.toHexString(true);
    }
    if (format === 'hex4') {
      formattedString = this.toHex8String(true);
    }
    if (format === 'hex8') {
      formattedString = this.toHex8String();
    }
    if (format === 'name') {
      formattedString = this.toName();
    }
    if (format === 'hsl') {
      formattedString = this.toHslString();
    }
    if (format === 'hsv') {
      formattedString = this.toHsvString();
    }
    if (format === 'cmyk') {
      formattedString = this.toCmykString();
    }
    return formattedString || this.toHexString();
  }
  toNumber() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  }
  clone() {
    return new TinyColor(this.toString());
  }
  /**
   * Lighten the color a given amount. Providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  lighten(amount = 10) {
    const hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  }
  /**
   * Brighten the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  brighten(amount = 10) {
    const rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor(rgb);
  }
  /**
   * Darken the color a given amount, from 0 to 100.
   * Providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  darken(amount = 10) {
    const hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor(hsl);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   * @param amount - valid between 1-100
   */
  tint(amount = 10) {
    return this.mix('white', amount);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   * @param amount - valid between 1-100
   */
  shade(amount = 10) {
    return this.mix('black', amount);
  }
  /**
   * Desaturate the color a given amount, from 0 to 100.
   * Providing 100 will is the same as calling greyscale
   * @param amount - valid between 1-100
   */
  desaturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  }
  /**
   * Saturate the color a given amount, from 0 to 100.
   * @param amount - valid between 1-100
   */
  saturate(amount = 10) {
    const hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor(hsl);
  }
  /**
   * Completely desaturates a color into greyscale.
   * Same as calling `desaturate(100)`
   */
  greyscale() {
    return this.desaturate(100);
  }
  /**
   * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
   * Values outside of this range will be wrapped into this range.
   */
  spin(amount) {
    const hsl = this.toHsl();
    const hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor(hsl);
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(color, amount = 50) {
    const rgb1 = this.toRgb();
    const rgb2 = new TinyColor(color).toRgb();
    const p = amount / 100;
    const rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return new TinyColor(rgba);
  }
  analogous(results = 6, slices = 30) {
    const hsl = this.toHsl();
    const part = 360 / slices;
    const ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor(hsl));
    }
    return ret;
  }
  /**
   * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
   */
  complement() {
    const hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor(hsl);
  }
  monochromatic(results = 6) {
    const hsv = this.toHsv();
    const {
      h
    } = hsv;
    const {
      s
    } = hsv;
    let {
      v
    } = hsv;
    const res = [];
    const modification = 1 / results;
    while (results--) {
      res.push(new TinyColor({
        h,
        s,
        v
      }));
      v = (v + modification) % 1;
    }
    return res;
  }
  splitcomplement() {
    const hsl = this.toHsl();
    const {
      h
    } = hsl;
    return [this, new TinyColor({
      h: (h + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), new TinyColor({
      h: (h + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }
  /**
   * Compute how the color would appear on a background
   */
  onBackground(background) {
    const fg = this.toRgb();
    const bg = new TinyColor(background).toRgb();
    const alpha = fg.a + bg.a * (1 - fg.a);
    return new TinyColor({
      r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
      g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
      b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
      a: alpha
    });
  }
  /**
   * Alias for `polyad(3)`
   */
  triad() {
    return this.polyad(3);
  }
  /**
   * Alias for `polyad(4)`
   */
  tetrad() {
    return this.polyad(4);
  }
  /**
   * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
   * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
   */
  polyad(n) {
    const hsl = this.toHsl();
    const {
      h
    } = hsl;
    const result = [this];
    const increment = 360 / n;
    for (let i = 1; i < n; i++) {
      result.push(new TinyColor({
        h: (h + i * increment) % 360,
        s: hsl.s,
        l: hsl.l
      }));
    }
    return result;
  }
  /**
   * compare color vs current color
   */
  equals(color) {
    const comparedColor = new TinyColor(color);
    /**
     * RGB and CMYK do not have the same color gamut, so a CMYK conversion will never be 100%.
     * This means we need to compare CMYK to CMYK to ensure accuracy of the equals function.
     */
    if (this.format === 'cmyk' || comparedColor.format === 'cmyk') {
      return this.toCmykString() === comparedColor.toCmykString();
    }
    return this.toRgbString() === comparedColor.toRgbString();
  }
}

var hasEyeDropper = "EyeDropper" in window;
var SlColorPicker = class extends ShoelaceElement {
  constructor() {
    super();
    this.formControlController = new FormControlController(this);
    this.isSafeValue = false;
    this.localize = new LocalizeController(this);
    this.hasFocus = false;
    this.isDraggingGridHandle = false;
    this.isEmpty = false;
    this.inputValue = "";
    this.hue = 0;
    this.saturation = 100;
    this.brightness = 100;
    this.alpha = 100;
    this.value = "";
    this.defaultValue = "";
    this.label = "";
    this.format = "hex";
    this.inline = false;
    this.size = "medium";
    this.noFormatToggle = false;
    this.name = "";
    this.disabled = false;
    this.hoist = false;
    this.opacity = false;
    this.uppercase = false;
    this.swatches = "";
    this.form = "";
    this.required = false;
    this.handleFocusIn = () => {
      this.hasFocus = true;
      this.emit("sl-focus");
    };
    this.handleFocusOut = () => {
      this.hasFocus = false;
      this.emit("sl-blur");
    };
    this.addEventListener("focusin", this.handleFocusIn);
    this.addEventListener("focusout", this.handleFocusOut);
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.input.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  handleCopy() {
    this.input.select();
    document.execCommand("copy");
    this.previewButton.focus();
    this.previewButton.classList.add("color-picker__preview-color--copied");
    this.previewButton.addEventListener("animationend", () => {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    });
  }
  handleFormatToggle() {
    const formats = ["hex", "rgb", "hsl", "hsv"];
    const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
    this.format = formats[nextIndex];
    this.setColor(this.value);
    this.emit("sl-change");
    this.emit("sl-input");
  }
  handleAlphaDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha");
    const handle = container.querySelector(".color-picker__slider-handle");
    const {
      width
    } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: x => {
        this.alpha = clamp(x / width * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleHueDrag(event) {
    const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue");
    const handle = container.querySelector(".color-picker__slider-handle");
    const {
      width
    } = container.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    drag(container, {
      onMove: x => {
        this.hue = clamp(x / width * 360, 0, 360);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleGridDrag(event) {
    const grid = this.shadowRoot.querySelector(".color-picker__grid");
    const handle = grid.querySelector(".color-picker__grid-handle");
    const {
      width,
      height
    } = grid.getBoundingClientRect();
    let initialValue = this.value;
    let currentValue = this.value;
    handle.focus();
    event.preventDefault();
    this.isDraggingGridHandle = true;
    drag(grid, {
      onMove: (x, y) => {
        this.saturation = clamp(x / width * 100, 0, 100);
        this.brightness = clamp(100 - y / height * 100, 0, 100);
        this.syncValues();
        if (this.value !== currentValue) {
          currentValue = this.value;
          this.emit("sl-input");
        }
      },
      onStop: () => {
        this.isDraggingGridHandle = false;
        if (this.value !== initialValue) {
          initialValue = this.value;
          this.emit("sl-change");
        }
      },
      initialEvent: event
    });
  }
  handleAlphaKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.alpha = clamp(this.alpha - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.alpha = clamp(this.alpha + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.alpha = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.alpha = 100;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleHueKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.hue = clamp(this.hue - increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.hue = clamp(this.hue + increment, 0, 360);
      this.syncValues();
    }
    if (event.key === "Home") {
      event.preventDefault();
      this.hue = 0;
      this.syncValues();
    }
    if (event.key === "End") {
      event.preventDefault();
      this.hue = 360;
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleGridKeyDown(event) {
    const increment = event.shiftKey ? 10 : 1;
    const oldValue = this.value;
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      this.saturation = clamp(this.saturation - increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      this.saturation = clamp(this.saturation + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this.brightness = clamp(this.brightness + increment, 0, 100);
      this.syncValues();
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      this.brightness = clamp(this.brightness - increment, 0, 100);
      this.syncValues();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputChange(event) {
    const target = event.target;
    const oldValue = this.value;
    event.stopPropagation();
    if (this.input.value) {
      this.setColor(target.value);
      target.value = this.value;
    } else {
      this.value = "";
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
      this.emit("sl-input");
    }
  }
  handleInputInput(event) {
    this.formControlController.updateValidity();
    event.stopPropagation();
  }
  handleInputKeyDown(event) {
    if (event.key === "Enter") {
      const oldValue = this.value;
      if (this.input.value) {
        this.setColor(this.input.value);
        this.input.value = this.value;
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
        setTimeout(() => this.input.select());
      } else {
        this.hue = 0;
      }
    }
  }
  handleInputInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleTouchMove(event) {
    event.preventDefault();
  }
  parseColor(colorString) {
    const color = new TinyColor(colorString);
    if (!color.isValid) {
      return null;
    }
    const hslColor = color.toHsl();
    const hsl = {
      h: hslColor.h,
      s: hslColor.s * 100,
      l: hslColor.l * 100,
      a: hslColor.a
    };
    const rgb = color.toRgb();
    const hex = color.toHexString();
    const hexa = color.toHex8String();
    const hsvColor = color.toHsv();
    const hsv = {
      h: hsvColor.h,
      s: hsvColor.s * 100,
      v: hsvColor.v * 100,
      a: hsvColor.a
    };
    return {
      hsl: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        string: this.setLetterCase(`hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`)
      },
      hsla: {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        string: this.setLetterCase(`hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`)
      },
      hsv: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        string: this.setLetterCase(`hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`)
      },
      hsva: {
        h: hsv.h,
        s: hsv.s,
        v: hsv.v,
        a: hsv.a,
        string: this.setLetterCase(`hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`)
      },
      rgb: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        string: this.setLetterCase(`rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`)
      },
      rgba: {
        r: rgb.r,
        g: rgb.g,
        b: rgb.b,
        a: rgb.a,
        string: this.setLetterCase(`rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`)
      },
      hex: this.setLetterCase(hex),
      hexa: this.setLetterCase(hexa)
    };
  }
  setColor(colorString) {
    const newColor = this.parseColor(colorString);
    if (newColor === null) {
      return false;
    }
    this.hue = newColor.hsva.h;
    this.saturation = newColor.hsva.s;
    this.brightness = newColor.hsva.v;
    this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
    this.syncValues();
    return true;
  }
  setLetterCase(string) {
    if (typeof string !== "string") {
      return "";
    }
    return this.uppercase ? string.toUpperCase() : string.toLowerCase();
  }
  async syncValues() {
    const currentColor = this.parseColor(`hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`);
    if (currentColor === null) {
      return;
    }
    if (this.format === "hsl") {
      this.inputValue = this.opacity ? currentColor.hsla.string : currentColor.hsl.string;
    } else if (this.format === "rgb") {
      this.inputValue = this.opacity ? currentColor.rgba.string : currentColor.rgb.string;
    } else if (this.format === "hsv") {
      this.inputValue = this.opacity ? currentColor.hsva.string : currentColor.hsv.string;
    } else {
      this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
    }
    this.isSafeValue = true;
    this.value = this.inputValue;
    await this.updateComplete;
    this.isSafeValue = false;
  }
  handleAfterHide() {
    this.previewButton.classList.remove("color-picker__preview-color--copied");
  }
  handleEyeDropper() {
    if (!hasEyeDropper) {
      return;
    }
    const eyeDropper = new EyeDropper();
    eyeDropper.open().then(colorSelectionResult => {
      const oldValue = this.value;
      this.setColor(colorSelectionResult.sRGBHex);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }).catch(() => {});
  }
  selectSwatch(color) {
    const oldValue = this.value;
    if (!this.disabled) {
      this.setColor(color);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
  }
  /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
  getHexString(hue, saturation, brightness, alpha = 100) {
    const color = new TinyColor(`hsva(${hue}, ${saturation}%, ${brightness}%, ${alpha / 100})`);
    if (!color.isValid) {
      return "";
    }
    return color.toHex8String();
  }
  // Prevents nested components from leaking events
  stopNestedEventPropagation(event) {
    event.stopImmediatePropagation();
  }
  handleFormatChange() {
    this.syncValues();
  }
  handleOpacityChange() {
    this.alpha = 100;
  }
  handleValueChange(oldValue, newValue) {
    this.isEmpty = !newValue;
    if (!newValue) {
      this.hue = 0;
      this.saturation = 0;
      this.brightness = 100;
      this.alpha = 100;
    }
    if (!this.isSafeValue) {
      const newColor = this.parseColor(newValue);
      if (newColor !== null) {
        this.inputValue = this.value;
        this.hue = newColor.hsva.h;
        this.saturation = newColor.hsva.s;
        this.brightness = newColor.hsva.v;
        this.alpha = newColor.hsva.a * 100;
        this.syncValues();
      } else {
        this.inputValue = oldValue != null ? oldValue : "";
      }
    }
  }
  /** Sets focus on the color picker. */
  focus(options) {
    if (this.inline) {
      this.base.focus(options);
    } else {
      this.trigger.focus(options);
    }
  }
  /** Removes focus from the color picker. */
  blur() {
    var _a;
    const elementToBlur = this.inline ? this.base : this.trigger;
    if (this.hasFocus) {
      elementToBlur.focus({
        preventScroll: true
      });
      elementToBlur.blur();
    }
    if ((_a = this.dropdown) == null ? void 0 : _a.open) {
      this.dropdown.hide();
    }
  }
  /** Returns the current value as a string in the specified format. */
  getFormattedValue(format = "hex") {
    const currentColor = this.parseColor(`hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`);
    if (currentColor === null) {
      return "";
    }
    switch (format) {
      case "hex":
        return currentColor.hex;
      case "hexa":
        return currentColor.hexa;
      case "rgb":
        return currentColor.rgb.string;
      case "rgba":
        return currentColor.rgba.string;
      case "hsl":
        return currentColor.hsl.string;
      case "hsla":
        return currentColor.hsla.string;
      case "hsv":
        return currentColor.hsv.string;
      case "hsva":
        return currentColor.hsva.string;
      default:
        return "";
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (!this.inline && !this.validity.valid) {
      this.dropdown.show();
      this.addEventListener("sl-after-show", () => this.input.reportValidity(), {
        once: true
      });
      if (!this.disabled) {
        this.formControlController.emitInvalidEvent();
      }
      return false;
    }
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const gridHandleX = this.saturation;
    const gridHandleY = 100 - this.brightness;
    const swatches = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter(color => color.trim() !== "");
    const colorPicker = x`
      <div
        part="base"
        class=${e$3({
      "color-picker": true,
      "color-picker--inline": this.inline,
      "color-picker--disabled": this.disabled,
      "color-picker--focused": this.hasFocus
    })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? x`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${o$5({
      backgroundColor: this.getHexString(this.hue, 100, 100)
    })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${e$3({
      "color-picker__grid-handle": true,
      "color-picker__grid-handle--dragging": this.isDraggingGridHandle
    })}
            style=${o$5({
      top: `${gridHandleY}%`,
      left: `${gridHandleX}%`,
      backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            role="application"
            aria-label="HSV"
            tabindex=${o$6(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${o$5({
      left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
    })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${o$6(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? x`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${o$5({
      backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
    })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${o$5({
      left: `${this.alpha}%`
    })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${o$6(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${o$5({
      "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${!this.noFormatToggle ? x`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                ` : ""}
            ${hasEyeDropper ? x`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${swatches.length > 0 ? x`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map(swatch => {
      const parsedColor = this.parseColor(swatch);
      if (!parsedColor) {
        console.error(`Unable to parse swatch color: "${swatch}"`, this);
        return "";
      }
      return x`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${o$6(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${event => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${o$5({
        backgroundColor: parsedColor.hexa
      })}
                      ></div>
                    </div>
                  `;
    })}
              </div>
            ` : ""}
      </div>
    `;
    if (this.inline) {
      return colorPicker;
    }
    return x`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containingElement=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${e$3({
      "color-dropdown__trigger": true,
      "color-dropdown__trigger--disabled": this.disabled,
      "color-dropdown__trigger--small": this.size === "small",
      "color-dropdown__trigger--medium": this.size === "medium",
      "color-dropdown__trigger--large": this.size === "large",
      "color-dropdown__trigger--empty": this.isEmpty,
      "color-dropdown__trigger--focused": this.hasFocus,
      "color-picker__transparent-bg": true
    })}
          style=${o$5({
      color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
    })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker}
      </sl-dropdown>
    `;
  }
};
SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
SlColorPicker.dependencies = {
  "sl-button-group": SlButtonGroup,
  "sl-button": SlButton,
  "sl-dropdown": SlDropdown,
  "sl-icon": SlIcon,
  "sl-input": SlInput,
  "sl-visually-hidden": SlVisuallyHidden
};
__decorateClass([e$7('[part~="base"]')], SlColorPicker.prototype, "base", 2);
__decorateClass([e$7('[part~="input"]')], SlColorPicker.prototype, "input", 2);
__decorateClass([e$7(".color-dropdown")], SlColorPicker.prototype, "dropdown", 2);
__decorateClass([e$7('[part~="preview"]')], SlColorPicker.prototype, "previewButton", 2);
__decorateClass([e$7('[part~="trigger"]')], SlColorPicker.prototype, "trigger", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "hasFocus", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "isDraggingGridHandle", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "isEmpty", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "inputValue", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "hue", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "saturation", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "brightness", 2);
__decorateClass([r$3()], SlColorPicker.prototype, "alpha", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "value", 2);
__decorateClass([defaultValue()], SlColorPicker.prototype, "defaultValue", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "label", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "format", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlColorPicker.prototype, "inline", 2);
__decorateClass([n$6({
  reflect: true
})], SlColorPicker.prototype, "size", 2);
__decorateClass([n$6({
  attribute: "no-format-toggle",
  type: Boolean
})], SlColorPicker.prototype, "noFormatToggle", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "name", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlColorPicker.prototype, "disabled", 2);
__decorateClass([n$6({
  type: Boolean
})], SlColorPicker.prototype, "hoist", 2);
__decorateClass([n$6({
  type: Boolean
})], SlColorPicker.prototype, "opacity", 2);
__decorateClass([n$6({
  type: Boolean
})], SlColorPicker.prototype, "uppercase", 2);
__decorateClass([n$6()], SlColorPicker.prototype, "swatches", 2);
__decorateClass([n$6({
  reflect: true
})], SlColorPicker.prototype, "form", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlColorPicker.prototype, "required", 2);
__decorateClass([t$2({
  passive: false
})], SlColorPicker.prototype, "handleTouchMove", 1);
__decorateClass([watch("format", {
  waitUntilFirstUpdate: true
})], SlColorPicker.prototype, "handleFormatChange", 1);
__decorateClass([watch("opacity", {
  waitUntilFirstUpdate: true
})], SlColorPicker.prototype, "handleOpacityChange", 1);
__decorateClass([watch("value")], SlColorPicker.prototype, "handleValueChange", 1);

var tagName$c = "sl-color-picker";
SlColorPicker.define("sl-color-picker");
o$8({
  tagName: tagName$c,
  elementClass: SlColorPicker,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlChange: "sl-change",
    onSlFocus: "sl-focus",
    onSlInput: "sl-input",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlColorPicker"
});

// src/components/copy-button/copy-button.styles.ts
var copy_button_styles_default = i$7`
  :host {
    --error-color: var(--sl-color-danger-600);
    --success-color: var(--sl-color-success-600);

    display: inline-block;
  }

  .copy-button__button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
  }

  .copy-button--success .copy-button__button {
    color: var(--success-color);
  }

  .copy-button--error .copy-button__button {
    color: var(--error-color);
  }

  .copy-button__button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .copy-button__button[disabled] {
    opacity: 0.5;
    cursor: not-allowed !important;
  }

  slot {
    display: inline-flex;
  }
`;

var SlCopyButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.isCopying = false;
    this.status = "rest";
    this.value = "";
    this.from = "";
    this.disabled = false;
    this.copyLabel = "";
    this.successLabel = "";
    this.errorLabel = "";
    this.feedbackDuration = 1e3;
    this.tooltipPlacement = "top";
    this.hoist = false;
  }
  async handleCopy() {
    if (this.disabled || this.isCopying) {
      return;
    }
    this.isCopying = true;
    let valueToCopy = this.value;
    if (this.from) {
      const root = this.getRootNode();
      const isProperty = this.from.includes(".");
      const isAttribute = this.from.includes("[") && this.from.includes("]");
      let id = this.from;
      let field = "";
      if (isProperty) {
        [id, field] = this.from.trim().split(".");
      } else if (isAttribute) {
        [id, field] = this.from.trim().replace(/\]$/, "").split("[");
      }
      const target = "getElementById" in root ? root.getElementById(id) : null;
      if (target) {
        if (isAttribute) {
          valueToCopy = target.getAttribute(field) || "";
        } else if (isProperty) {
          valueToCopy = target[field] || "";
        } else {
          valueToCopy = target.textContent || "";
        }
      } else {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
    if (!valueToCopy) {
      this.showStatus("error");
      this.emit("sl-error");
    } else {
      try {
        await navigator.clipboard.writeText(valueToCopy);
        this.showStatus("success");
        this.emit("sl-copy", {
          detail: {
            value: valueToCopy
          }
        });
      } catch (error) {
        this.showStatus("error");
        this.emit("sl-error");
      }
    }
  }
  async showStatus(status) {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    const successLabel = this.successLabel || this.localize.term("copied");
    const errorLabel = this.errorLabel || this.localize.term("error");
    const iconToShow = status === "success" ? this.successIcon : this.errorIcon;
    const showAnimation = getAnimation(this, "copy.in", {
      dir: "ltr"
    });
    const hideAnimation = getAnimation(this, "copy.out", {
      dir: "ltr"
    });
    this.tooltip.content = status === "success" ? successLabel : errorLabel;
    await this.copyIcon.animate(hideAnimation.keyframes, hideAnimation.options).finished;
    this.copyIcon.hidden = true;
    this.status = status;
    iconToShow.hidden = false;
    await iconToShow.animate(showAnimation.keyframes, showAnimation.options).finished;
    setTimeout(async () => {
      await iconToShow.animate(hideAnimation.keyframes, hideAnimation.options).finished;
      iconToShow.hidden = true;
      this.status = "rest";
      this.copyIcon.hidden = false;
      await this.copyIcon.animate(showAnimation.keyframes, showAnimation.options).finished;
      this.tooltip.content = copyLabel;
      this.isCopying = false;
    }, this.feedbackDuration);
  }
  render() {
    const copyLabel = this.copyLabel || this.localize.term("copy");
    return x`
      <sl-tooltip
        class=${e$3({
      "copy-button": true,
      "copy-button--success": this.status === "success",
      "copy-button--error": this.status === "error"
    })}
        content=${copyLabel}
        placement=${this.tooltipPlacement}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        exportparts="
          base:tooltip__base,
          base__popup:tooltip__base__popup,
          base__arrow:tooltip__base__arrow,
          body:tooltip__body
        "
      >
        <button
          class="copy-button__button"
          part="button"
          type="button"
          ?disabled=${this.disabled}
          @click=${this.handleCopy}
        >
          <slot part="copy-icon" name="copy-icon">
            <sl-icon library="system" name="copy"></sl-icon>
          </slot>
          <slot part="success-icon" name="success-icon" hidden>
            <sl-icon library="system" name="check"></sl-icon>
          </slot>
          <slot part="error-icon" name="error-icon" hidden>
            <sl-icon library="system" name="x-lg"></sl-icon>
          </slot>
        </button>
      </sl-tooltip>
    `;
  }
};
SlCopyButton.styles = [component_styles_default, copy_button_styles_default];
SlCopyButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-tooltip": SlTooltip
};
__decorateClass([e$7('slot[name="copy-icon"]')], SlCopyButton.prototype, "copyIcon", 2);
__decorateClass([e$7('slot[name="success-icon"]')], SlCopyButton.prototype, "successIcon", 2);
__decorateClass([e$7('slot[name="error-icon"]')], SlCopyButton.prototype, "errorIcon", 2);
__decorateClass([e$7("sl-tooltip")], SlCopyButton.prototype, "tooltip", 2);
__decorateClass([r$3()], SlCopyButton.prototype, "isCopying", 2);
__decorateClass([r$3()], SlCopyButton.prototype, "status", 2);
__decorateClass([n$6()], SlCopyButton.prototype, "value", 2);
__decorateClass([n$6()], SlCopyButton.prototype, "from", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlCopyButton.prototype, "disabled", 2);
__decorateClass([n$6({
  attribute: "copy-label"
})], SlCopyButton.prototype, "copyLabel", 2);
__decorateClass([n$6({
  attribute: "success-label"
})], SlCopyButton.prototype, "successLabel", 2);
__decorateClass([n$6({
  attribute: "error-label"
})], SlCopyButton.prototype, "errorLabel", 2);
__decorateClass([n$6({
  attribute: "feedback-duration",
  type: Number
})], SlCopyButton.prototype, "feedbackDuration", 2);
__decorateClass([n$6({
  attribute: "tooltip-placement"
})], SlCopyButton.prototype, "tooltipPlacement", 2);
__decorateClass([n$6({
  type: Boolean
})], SlCopyButton.prototype, "hoist", 2);
setDefaultAnimation("copy.in", {
  keyframes: [{
    scale: ".25",
    opacity: ".25"
  }, {
    scale: "1",
    opacity: "1"
  }],
  options: {
    duration: 100
  }
});
setDefaultAnimation("copy.out", {
  keyframes: [{
    scale: "1",
    opacity: "1"
  }, {
    scale: ".25",
    opacity: "0"
  }],
  options: {
    duration: 100
  }
});

var tagName$b = "sl-copy-button";
SlCopyButton.define("sl-copy-button");
o$8({
  tagName: tagName$b,
  elementClass: SlCopyButton,
  react: React$1,
  events: {
    onSlCopy: "sl-copy",
    onSlError: "sl-error"
  },
  displayName: "SlCopyButton"
});

// src/components/details/details.styles.ts
var details_styles_default = i$7`
  :host {
    display: block;
  }

  .details {
    border: solid 1px var(--sl-color-neutral-200);
    border-radius: var(--sl-border-radius-medium);
    background-color: var(--sl-color-neutral-0);
    overflow-anchor: none;
  }

  .details--disabled {
    opacity: 0.5;
  }

  .details__header {
    display: flex;
    align-items: center;
    border-radius: inherit;
    padding: var(--sl-spacing-medium);
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
  }

  .details__header::-webkit-details-marker {
    display: none;
  }

  .details__header:focus {
    outline: none;
  }

  .details__header:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(1px + var(--sl-focus-ring-offset));
  }

  .details--disabled .details__header {
    cursor: not-allowed;
  }

  .details--disabled .details__header:focus-visible {
    outline: none;
    box-shadow: none;
  }

  .details__summary {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
  }

  .details__summary-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
  }

  .details--open .details__summary-icon {
    rotate: 90deg;
  }

  .details--open.details--rtl .details__summary-icon {
    rotate: -90deg;
  }

  .details--open slot[name='expand-icon'],
  .details:not(.details--open) slot[name='collapse-icon'] {
    display: none;
  }

  .details__body {
    overflow: hidden;
  }

  .details__content {
    display: block;
    padding: var(--sl-spacing-medium);
  }
`;

var SlDetails = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.open = false;
    this.disabled = false;
  }
  firstUpdated() {
    this.body.style.height = this.open ? "auto" : "0";
    if (this.open) {
      this.details.open = true;
    }
    this.detailsObserver = new MutationObserver(changes => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName === "open") {
          if (this.details.open) {
            this.show();
          } else {
            this.hide();
          }
        }
      }
    });
    this.detailsObserver.observe(this.details, {
      attributes: true
    });
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.detailsObserver) == null ? void 0 : _a.disconnect();
  }
  handleSummaryClick(event) {
    event.preventDefault();
    if (!this.disabled) {
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
      this.header.focus();
    }
  }
  handleSummaryKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      if (this.open) {
        this.hide();
      } else {
        this.show();
      }
    }
    if (event.key === "ArrowUp" || event.key === "ArrowLeft") {
      event.preventDefault();
      this.hide();
    }
    if (event.key === "ArrowDown" || event.key === "ArrowRight") {
      event.preventDefault();
      this.show();
    }
  }
  async handleOpenChange() {
    if (this.open) {
      this.details.open = true;
      const slShow = this.emit("sl-show", {
        cancelable: true
      });
      if (slShow.defaultPrevented) {
        this.open = false;
        this.details.open = false;
        return;
      }
      await stopAnimations(this.body);
      const {
        keyframes,
        options
      } = getAnimation(this, "details.show", {
        dir: this.localize.dir()
      });
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.emit("sl-after-show");
    } else {
      const slHide = this.emit("sl-hide", {
        cancelable: true
      });
      if (slHide.defaultPrevented) {
        this.details.open = true;
        this.open = true;
        return;
      }
      await stopAnimations(this.body);
      const {
        keyframes,
        options
      } = getAnimation(this, "details.hide", {
        dir: this.localize.dir()
      });
      await animateTo(this.body, shimKeyframesHeightAuto(keyframes, this.body.scrollHeight), options);
      this.body.style.height = "auto";
      this.details.open = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the details. */
  async show() {
    if (this.open || this.disabled) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the details */
  async hide() {
    if (!this.open || this.disabled) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x`
      <details
        part="base"
        class=${e$3({
      details: true,
      "details--open": this.open,
      "details--disabled": this.disabled,
      "details--rtl": isRtl
    })}
      >
        <summary
          part="header"
          id="header"
          class="details__header"
          role="button"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="content"
          aria-disabled=${this.disabled ? "true" : "false"}
          tabindex=${this.disabled ? "-1" : "0"}
          @click=${this.handleSummaryClick}
          @keydown=${this.handleSummaryKeyDown}
        >
          <slot name="summary" part="summary" class="details__summary">${this.summary}</slot>

          <span part="summary-icon" class="details__summary-icon">
            <slot name="expand-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
            <slot name="collapse-icon">
              <sl-icon library="system" name=${isRtl ? "chevron-left" : "chevron-right"}></sl-icon>
            </slot>
          </span>
        </summary>

        <div class="details__body" role="region" aria-labelledby="header">
          <slot part="content" id="content" class="details__content"></slot>
        </div>
      </details>
    `;
  }
};
SlDetails.styles = [component_styles_default, details_styles_default];
SlDetails.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".details")], SlDetails.prototype, "details", 2);
__decorateClass([e$7(".details__header")], SlDetails.prototype, "header", 2);
__decorateClass([e$7(".details__body")], SlDetails.prototype, "body", 2);
__decorateClass([e$7(".details__expand-icon-slot")], SlDetails.prototype, "expandIconSlot", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDetails.prototype, "open", 2);
__decorateClass([n$6()], SlDetails.prototype, "summary", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDetails.prototype, "disabled", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlDetails.prototype, "handleOpenChange", 1);
setDefaultAnimation("details.show", {
  keyframes: [{
    height: "0",
    opacity: "0"
  }, {
    height: "auto",
    opacity: "1"
  }],
  options: {
    duration: 250,
    easing: "linear"
  }
});
setDefaultAnimation("details.hide", {
  keyframes: [{
    height: "auto",
    opacity: "1"
  }, {
    height: "0",
    opacity: "0"
  }],
  options: {
    duration: 250,
    easing: "linear"
  }
});

var tagName$a = "sl-details";
SlDetails.define("sl-details");
var reactWrapper = o$8({
  tagName: tagName$a,
  elementClass: SlDetails,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide"
  },
  displayName: "SlDetails"
});
var details_default = reactWrapper;

// src/components/dialog/dialog.styles.ts
var dialog_styles_default = i$7`
  :host {
    --width: 31rem;
    --header-spacing: var(--sl-spacing-large);
    --body-spacing: var(--sl-spacing-large);
    --footer-spacing: var(--sl-spacing-large);

    display: contents;
  }

  .dialog {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: var(--sl-z-index-dialog);
  }

  .dialog__panel {
    display: flex;
    flex-direction: column;
    z-index: 2;
    width: var(--width);
    max-width: calc(100% - var(--sl-spacing-2x-large));
    max-height: calc(100% - var(--sl-spacing-2x-large));
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    box-shadow: var(--sl-shadow-x-large);
  }

  .dialog__panel:focus {
    outline: none;
  }

  /* Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone) */
  @media screen and (max-width: 420px) {
    .dialog__panel {
      max-height: 80vh;
    }
  }

  .dialog--open .dialog__panel {
    display: flex;
    opacity: 1;
  }

  .dialog__header {
    flex: 0 0 auto;
    display: flex;
  }

  .dialog__title {
    flex: 1 1 auto;
    font: inherit;
    font-size: var(--sl-font-size-large);
    line-height: var(--sl-line-height-dense);
    padding: var(--header-spacing);
    margin: 0;
  }

  .dialog__header-actions {
    flex-shrink: 0;
    display: flex;
    flex-wrap: wrap;
    justify-content: end;
    gap: var(--sl-spacing-2x-small);
    padding: 0 var(--header-spacing);
  }

  .dialog__header-actions sl-icon-button,
  .dialog__header-actions ::slotted(sl-icon-button) {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
  }

  .dialog__body {
    flex: 1 1 auto;
    display: block;
    padding: var(--body-spacing);
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .dialog__footer {
    flex: 0 0 auto;
    text-align: right;
    padding: var(--footer-spacing);
  }

  .dialog__footer ::slotted(sl-button:not(:first-of-type)) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  .dialog:not(.dialog--has-footer) .dialog__footer {
    display: none;
  }

  .dialog__overlay {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--sl-overlay-background-color);
  }

  @media (forced-colors: active) {
    .dialog__panel {
      border: solid 1px var(--sl-color-neutral-0);
    }
  }
`;

var SlDialog = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer");
    this.localize = new LocalizeController(this);
    this.modal = new Modal(this);
    this.open = false;
    this.label = "";
    this.noHeader = false;
    this.handleDocumentKeyDown = event => {
      if (event.key === "Escape" && this.modal.isActive() && this.open) {
        event.stopPropagation();
        this.requestClose("keyboard");
      }
    };
  }
  firstUpdated() {
    this.dialog.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.modal.activate();
      lockBodyScrolling(this);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.modal.deactivate();
    unlockBodyScrolling(this);
    this.removeOpenListeners();
  }
  requestClose(source) {
    const slRequestClose = this.emit("sl-request-close", {
      cancelable: true,
      detail: {
        source
      }
    });
    if (slRequestClose.defaultPrevented) {
      const animation = getAnimation(this, "dialog.denyClose", {
        dir: this.localize.dir()
      });
      animateTo(this.panel, animation.keyframes, animation.options);
      return;
    }
    this.hide();
  }
  addOpenListeners() {
    var _a;
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => this.requestClose("keyboard");
    } else {
      document.addEventListener("keydown", this.handleDocumentKeyDown);
    }
  }
  removeOpenListeners() {
    var _a;
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      this.originalTrigger = document.activeElement;
      this.modal.activate();
      lockBodyScrolling(this);
      const autoFocusTarget = this.querySelector("[autofocus]");
      if (autoFocusTarget) {
        autoFocusTarget.removeAttribute("autofocus");
      }
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      this.dialog.hidden = false;
      requestAnimationFrame(() => {
        const slInitialFocus = this.emit("sl-initial-focus", {
          cancelable: true
        });
        if (!slInitialFocus.defaultPrevented) {
          if (autoFocusTarget) {
            autoFocusTarget.focus({
              preventScroll: true
            });
          } else {
            this.panel.focus({
              preventScroll: true
            });
          }
        }
        if (autoFocusTarget) {
          autoFocusTarget.setAttribute("autofocus", "");
        }
      });
      const panelAnimation = getAnimation(this, "dialog.show", {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "dialog.overlay.show", {
        dir: this.localize.dir()
      });
      await Promise.all([animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options), animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options)]);
      this.emit("sl-after-show");
    } else {
      blurActiveElement(this);
      this.emit("sl-hide");
      this.removeOpenListeners();
      this.modal.deactivate();
      await Promise.all([stopAnimations(this.dialog), stopAnimations(this.overlay)]);
      const panelAnimation = getAnimation(this, "dialog.hide", {
        dir: this.localize.dir()
      });
      const overlayAnimation = getAnimation(this, "dialog.overlay.hide", {
        dir: this.localize.dir()
      });
      await Promise.all([animateTo(this.overlay, overlayAnimation.keyframes, overlayAnimation.options).then(() => {
        this.overlay.hidden = true;
      }), animateTo(this.panel, panelAnimation.keyframes, panelAnimation.options).then(() => {
        this.panel.hidden = true;
      })]);
      this.dialog.hidden = true;
      this.overlay.hidden = false;
      this.panel.hidden = false;
      unlockBodyScrolling(this);
      const trigger = this.originalTrigger;
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        setTimeout(() => trigger.focus());
      }
      this.emit("sl-after-hide");
    }
  }
  /** Shows the dialog. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dialog */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      dialog: true,
      "dialog--open": this.open,
      "dialog--has-footer": this.hasSlotController.test("footer")
    })}
      >
        <div part="overlay" class="dialog__overlay" @click=${() => this.requestClose("overlay")} tabindex="-1"></div>

        <div
          part="panel"
          class="dialog__panel"
          role="dialog"
          aria-modal="true"
          aria-hidden=${this.open ? "false" : "true"}
          aria-label=${o$6(this.noHeader ? this.label : void 0)}
          aria-labelledby=${o$6(!this.noHeader ? "title" : void 0)}
          tabindex="-1"
        >
          ${!this.noHeader ? x`
                <header part="header" class="dialog__header">
                  <h2 part="title" class="dialog__title" id="title">
                    <slot name="label"> ${this.label.length > 0 ? this.label : String.fromCharCode(65279)} </slot>
                  </h2>
                  <div part="header-actions" class="dialog__header-actions">
                    <slot name="header-actions"></slot>
                    <sl-icon-button
                      part="close-button"
                      exportparts="base:close-button__base"
                      class="dialog__close"
                      name="x-lg"
                      label=${this.localize.term("close")}
                      library="system"
                      @click="${() => this.requestClose("close-button")}"
                    ></sl-icon-button>
                  </div>
                </header>
              ` : ""}
          ${""}
          <div part="body" class="dialog__body" tabindex="-1"><slot></slot></div>

          <footer part="footer" class="dialog__footer">
            <slot name="footer"></slot>
          </footer>
        </div>
      </div>
    `;
  }
};
SlDialog.styles = [component_styles_default, dialog_styles_default];
SlDialog.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([e$7(".dialog")], SlDialog.prototype, "dialog", 2);
__decorateClass([e$7(".dialog__panel")], SlDialog.prototype, "panel", 2);
__decorateClass([e$7(".dialog__overlay")], SlDialog.prototype, "overlay", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlDialog.prototype, "open", 2);
__decorateClass([n$6({
  reflect: true
})], SlDialog.prototype, "label", 2);
__decorateClass([n$6({
  attribute: "no-header",
  type: Boolean,
  reflect: true
})], SlDialog.prototype, "noHeader", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], SlDialog.prototype, "handleOpenChange", 1);
setDefaultAnimation("dialog.show", {
  keyframes: [{
    opacity: 0,
    scale: 0.8
  }, {
    opacity: 1,
    scale: 1
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("dialog.hide", {
  keyframes: [{
    opacity: 1,
    scale: 1
  }, {
    opacity: 0,
    scale: 0.8
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("dialog.denyClose", {
  keyframes: [{
    scale: 1
  }, {
    scale: 1.02
  }, {
    scale: 1
  }],
  options: {
    duration: 250
  }
});
setDefaultAnimation("dialog.overlay.show", {
  keyframes: [{
    opacity: 0
  }, {
    opacity: 1
  }],
  options: {
    duration: 250
  }
});
setDefaultAnimation("dialog.overlay.hide", {
  keyframes: [{
    opacity: 1
  }, {
    opacity: 0
  }],
  options: {
    duration: 250
  }
});

var tagName$9 = "sl-dialog";
SlDialog.define("sl-dialog");
o$8({
  tagName: tagName$9,
  elementClass: SlDialog,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide",
    onSlInitialFocus: "sl-initial-focus",
    onSlRequestClose: "sl-request-close"
  },
  displayName: "SlDialog"
});

// src/components/animated-image/animated-image.styles.ts
var animated_image_styles_default = i$7`
  :host {
    --control-box-size: 3rem;
    --icon-size: calc(var(--control-box-size) * 0.625);

    display: inline-flex;
    position: relative;
    cursor: pointer;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
  }

  img[aria-hidden='true'] {
    display: none;
  }

  .animated-image__control-box {
    display: flex;
    position: absolute;
    align-items: center;
    justify-content: center;
    top: calc(50% - var(--control-box-size) / 2);
    right: calc(50% - var(--control-box-size) / 2);
    width: var(--control-box-size);
    height: var(--control-box-size);
    font-size: var(--icon-size);
    background: none;
    border: solid 2px currentColor;
    background-color: rgb(0 0 0 /50%);
    border-radius: var(--sl-border-radius-circle);
    color: white;
    pointer-events: none;
    transition: var(--sl-transition-fast) opacity;
  }

  :host([play]:hover) .animated-image__control-box {
    opacity: 1;
  }

  :host([play]:not(:hover)) .animated-image__control-box {
    opacity: 0;
  }

  :host([play]) slot[name='play-icon'],
  :host(:not([play])) slot[name='pause-icon'] {
    display: none;
  }
`;

var SlAnimatedImage = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.isLoaded = false;
  }
  handleClick() {
    this.play = !this.play;
  }
  handleLoad() {
    const canvas = document.createElement("canvas");
    const {
      width,
      height
    } = this.animatedImage;
    canvas.width = width;
    canvas.height = height;
    canvas.getContext("2d").drawImage(this.animatedImage, 0, 0, width, height);
    this.frozenFrame = canvas.toDataURL("image/gif");
    if (!this.isLoaded) {
      this.emit("sl-load");
      this.isLoaded = true;
    }
  }
  handleError() {
    this.emit("sl-error");
  }
  handlePlayChange() {
    if (this.play) {
      this.animatedImage.src = "";
      this.animatedImage.src = this.src;
    }
  }
  handleSrcChange() {
    this.isLoaded = false;
  }
  render() {
    return x`
      <div class="animated-image">
        <img
          class="animated-image__animated"
          src=${this.src}
          alt=${this.alt}
          crossorigin="anonymous"
          aria-hidden=${this.play ? "false" : "true"}
          @click=${this.handleClick}
          @load=${this.handleLoad}
          @error=${this.handleError}
        />

        ${this.isLoaded ? x`
              <img
                class="animated-image__frozen"
                src=${this.frozenFrame}
                alt=${this.alt}
                aria-hidden=${this.play ? "true" : "false"}
                @click=${this.handleClick}
              />

              <div part="control-box" class="animated-image__control-box">
                <slot name="play-icon"><sl-icon name="play-fill" library="system"></sl-icon></slot>
                <slot name="pause-icon"><sl-icon name="pause-fill" library="system"></sl-icon></slot>
              </div>
            ` : ""}
      </div>
    `;
  }
};
SlAnimatedImage.styles = [component_styles_default, animated_image_styles_default];
SlAnimatedImage.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7(".animated-image__animated")], SlAnimatedImage.prototype, "animatedImage", 2);
__decorateClass([r$3()], SlAnimatedImage.prototype, "frozenFrame", 2);
__decorateClass([r$3()], SlAnimatedImage.prototype, "isLoaded", 2);
__decorateClass([n$6()], SlAnimatedImage.prototype, "src", 2);
__decorateClass([n$6()], SlAnimatedImage.prototype, "alt", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlAnimatedImage.prototype, "play", 2);
__decorateClass([watch("play", {
  waitUntilFirstUpdate: true
})], SlAnimatedImage.prototype, "handlePlayChange", 1);
__decorateClass([watch("src")], SlAnimatedImage.prototype, "handleSrcChange", 1);

var tagName$8 = "sl-animated-image";
SlAnimatedImage.define("sl-animated-image");
o$8({
  tagName: tagName$8,
  elementClass: SlAnimatedImage,
  react: React$1,
  events: {
    onSlLoad: "sl-load",
    onSlError: "sl-error"
  },
  displayName: "SlAnimatedImage"
});

const bounce = [{
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.2,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.4,
  easing: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
  transform: 'translate3d(0, -30px, 0) scaleY(1.1)'
}, {
  offset: 0.43,
  easing: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
  transform: 'translate3d(0, -30px, 0) scaleY(1.1)'
}, {
  offset: 0.53,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.7,
  easing: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
  transform: 'translate3d(0, -15px, 0) scaleY(1.05)'
}, {
  offset: 0.8,
  'transition-timing-function': 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  transform: 'translate3d(0, 0, 0) scaleY(0.95)'
}, {
  offset: 0.9,
  transform: 'translate3d(0, -4px, 0) scaleY(1.02)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  transform: 'translate3d(0, 0, 0)'
}];

const flash = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 0.25,
  opacity: '0'
}, {
  offset: 0.5,
  opacity: '1'
}, {
  offset: 0.75,
  opacity: '0'
}, {
  offset: 1,
  opacity: '1'
}];

const headShake = [{
  offset: 0,
  transform: 'translateX(0)'
}, {
  offset: 0.065,
  transform: 'translateX(-6px) rotateY(-9deg)'
}, {
  offset: 0.185,
  transform: 'translateX(5px) rotateY(7deg)'
}, {
  offset: 0.315,
  transform: 'translateX(-3px) rotateY(-5deg)'
}, {
  offset: 0.435,
  transform: 'translateX(2px) rotateY(3deg)'
}, {
  offset: 0.5,
  transform: 'translateX(0)'
}];

const heartBeat = [{
  offset: 0,
  transform: 'scale(1)'
}, {
  offset: 0.14,
  transform: 'scale(1.3)'
}, {
  offset: 0.28,
  transform: 'scale(1)'
}, {
  offset: 0.42,
  transform: 'scale(1.3)'
}, {
  offset: 0.7,
  transform: 'scale(1)'
}];

const jello = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.111,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.222,
  transform: 'skewX(-12.5deg) skewY(-12.5deg)'
}, {
  offset: 0.33299999999999996,
  transform: 'skewX(6.25deg) skewY(6.25deg)'
}, {
  offset: 0.444,
  transform: 'skewX(-3.125deg) skewY(-3.125deg)'
}, {
  offset: 0.555,
  transform: 'skewX(1.5625deg) skewY(1.5625deg)'
}, {
  offset: 0.6659999999999999,
  transform: 'skewX(-0.78125deg) skewY(-0.78125deg)'
}, {
  offset: 0.777,
  transform: 'skewX(0.390625deg) skewY(0.390625deg)'
}, {
  offset: 0.888,
  transform: 'skewX(-0.1953125deg) skewY(-0.1953125deg)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const pulse = [{
  offset: 0,
  transform: 'scale3d(1, 1, 1)'
}, {
  offset: 0.5,
  transform: 'scale3d(1.05, 1.05, 1.05)'
}, {
  offset: 1,
  transform: 'scale3d(1, 1, 1)'
}];

const rubberBand = [{
  offset: 0,
  transform: 'scale3d(1, 1, 1)'
}, {
  offset: 0.3,
  transform: 'scale3d(1.25, 0.75, 1)'
}, {
  offset: 0.4,
  transform: 'scale3d(0.75, 1.25, 1)'
}, {
  offset: 0.5,
  transform: 'scale3d(1.15, 0.85, 1)'
}, {
  offset: 0.65,
  transform: 'scale3d(0.95, 1.05, 1)'
}, {
  offset: 0.75,
  transform: 'scale3d(1.05, 0.95, 1)'
}, {
  offset: 1,
  transform: 'scale3d(1, 1, 1)'
}];

const shake = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.1,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.2,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.3,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.4,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.5,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.6,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.7,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.8,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.9,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const shakeX = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.1,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.2,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.3,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.4,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.5,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.6,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.7,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 0.8,
  transform: 'translate3d(10px, 0, 0)'
}, {
  offset: 0.9,
  transform: 'translate3d(-10px, 0, 0)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const shakeY = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.1,
  transform: 'translate3d(0, -10px, 0)'
}, {
  offset: 0.2,
  transform: 'translate3d(0, 10px, 0)'
}, {
  offset: 0.3,
  transform: 'translate3d(0, -10px, 0)'
}, {
  offset: 0.4,
  transform: 'translate3d(0, 10px, 0)'
}, {
  offset: 0.5,
  transform: 'translate3d(0, -10px, 0)'
}, {
  offset: 0.6,
  transform: 'translate3d(0, 10px, 0)'
}, {
  offset: 0.7,
  transform: 'translate3d(0, -10px, 0)'
}, {
  offset: 0.8,
  transform: 'translate3d(0, 10px, 0)'
}, {
  offset: 0.9,
  transform: 'translate3d(0, -10px, 0)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const swing = [{
  offset: 0.2,
  transform: 'rotate3d(0, 0, 1, 15deg)'
}, {
  offset: 0.4,
  transform: 'rotate3d(0, 0, 1, -10deg)'
}, {
  offset: 0.6,
  transform: 'rotate3d(0, 0, 1, 5deg)'
}, {
  offset: 0.8,
  transform: 'rotate3d(0, 0, 1, -5deg)'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, 0deg)'
}];

const tada = [{
  offset: 0,
  transform: 'scale3d(1, 1, 1)'
}, {
  offset: 0.1,
  transform: 'scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.2,
  transform: 'scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.3,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)'
}, {
  offset: 0.4,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.5,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)'
}, {
  offset: 0.6,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.7,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)'
}, {
  offset: 0.8,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.9,
  transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)'
}, {
  offset: 1,
  transform: 'scale3d(1, 1, 1)'
}];

const wobble = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 0.15,
  transform: 'translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)'
}, {
  offset: 0.3,
  transform: 'translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)'
}, {
  offset: 0.45,
  transform: 'translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)'
}, {
  offset: 0.6,
  transform: 'translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)'
}, {
  offset: 0.75,
  transform: 'translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const backInDown = [{
  offset: 0,
  transform: 'translateY(-1200px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 0.8,
  transform: 'translateY(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'scale(1)',
  opacity: '1'
}];

const backInLeft = [{
  offset: 0,
  transform: 'translateX(-2000px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 0.8,
  transform: 'translateX(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'scale(1)',
  opacity: '1'
}];

const backInRight = [{
  offset: 0,
  transform: 'translateX(2000px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 0.8,
  transform: 'translateX(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'scale(1)',
  opacity: '1'
}];

const backInUp = [{
  offset: 0,
  transform: 'translateY(1200px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 0.8,
  transform: 'translateY(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'scale(1)',
  opacity: '1'
}];

const backOutDown = [{
  offset: 0,
  transform: 'scale(1)',
  opacity: '1'
}, {
  offset: 0.2,
  transform: 'translateY(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'translateY(700px) scale(0.7)',
  opacity: '0.7'
}];

const backOutLeft = [{
  offset: 0,
  transform: 'scale(1)',
  opacity: '1'
}, {
  offset: 0.2,
  transform: 'translateX(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'translateX(-2000px) scale(0.7)',
  opacity: '0.7'
}];

const backOutRight = [{
  offset: 0,
  transform: 'scale(1)',
  opacity: '1'
}, {
  offset: 0.2,
  transform: 'translateX(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'translateX(2000px) scale(0.7)',
  opacity: '0.7'
}];

const backOutUp = [{
  offset: 0,
  transform: 'scale(1)',
  opacity: '1'
}, {
  offset: 0.2,
  transform: 'translateY(0px) scale(0.7)',
  opacity: '0.7'
}, {
  offset: 1,
  transform: 'translateY(-700px) scale(0.7)',
  opacity: '0.7'
}];

const bounceIn = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.3, 0.3, 0.3)'
}, {
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.2,
  transform: 'scale3d(1.1, 1.1, 1.1)'
}, {
  offset: 0.2,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.4,
  transform: 'scale3d(0.9, 0.9, 0.9)'
}, {
  offset: 0.4,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'scale3d(1.03, 1.03, 1.03)'
}, {
  offset: 0.6,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.8,
  transform: 'scale3d(0.97, 0.97, 0.97)'
}, {
  offset: 0.8,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'scale3d(1, 1, 1)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}];

const bounceInDown = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, -3000px, 0) scaleY(3)'
}, {
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'translate3d(0, 25px, 0) scaleY(0.9)'
}, {
  offset: 0.6,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.75,
  transform: 'translate3d(0, -10px, 0) scaleY(0.95)'
}, {
  offset: 0.75,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.9,
  transform: 'translate3d(0, 5px, 0) scaleY(0.985)'
}, {
  offset: 0.9,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}];

const bounceInLeft = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-3000px, 0, 0) scaleX(3)'
}, {
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'translate3d(25px, 0, 0) scaleX(1)'
}, {
  offset: 0.6,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.75,
  transform: 'translate3d(-10px, 0, 0) scaleX(0.98)'
}, {
  offset: 0.75,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.9,
  transform: 'translate3d(5px, 0, 0) scaleX(0.995)'
}, {
  offset: 0.9,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}];

const bounceInRight = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(3000px, 0, 0) scaleX(3)'
}, {
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'translate3d(-25px, 0, 0) scaleX(1)'
}, {
  offset: 0.6,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.75,
  transform: 'translate3d(10px, 0, 0) scaleX(0.98)'
}, {
  offset: 0.75,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.9,
  transform: 'translate3d(-5px, 0, 0) scaleX(0.995)'
}, {
  offset: 0.9,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}];

const bounceInUp = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, 3000px, 0) scaleY(5)'
}, {
  offset: 0,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'translate3d(0, -20px, 0) scaleY(0.9)'
}, {
  offset: 0.6,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.75,
  transform: 'translate3d(0, 10px, 0) scaleY(0.95)'
}, {
  offset: 0.75,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 0.9,
  transform: 'translate3d(0, -5px, 0) scaleY(0.985)'
}, {
  offset: 0.9,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)'
}];

const bounceOut = [{
  offset: 0.2,
  transform: 'scale3d(0.9, 0.9, 0.9)'
}, {
  offset: 0.5,
  opacity: '1',
  transform: 'scale3d(1.1, 1.1, 1.1)'
}, {
  offset: 0.55,
  opacity: '1',
  transform: 'scale3d(1.1, 1.1, 1.1)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'scale3d(0.3, 0.3, 0.3)'
}];

const bounceOutDown = [{
  offset: 0.2,
  transform: 'translate3d(0, 10px, 0) scaleY(0.985)'
}, {
  offset: 0.4,
  opacity: '1',
  transform: 'translate3d(0, -20px, 0) scaleY(0.9)'
}, {
  offset: 0.45,
  opacity: '1',
  transform: 'translate3d(0, -20px, 0) scaleY(0.9)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, 2000px, 0) scaleY(3)'
}];

const bounceOutLeft = [{
  offset: 0.2,
  opacity: '1',
  transform: 'translate3d(20px, 0, 0) scaleX(0.9)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(-2000px, 0, 0) scaleX(2)'
}];

const bounceOutRight = [{
  offset: 0.2,
  opacity: '1',
  transform: 'translate3d(-20px, 0, 0) scaleX(0.9)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(2000px, 0, 0) scaleX(2)'
}];

const bounceOutUp = [{
  offset: 0.2,
  transform: 'translate3d(0, -10px, 0) scaleY(0.985)'
}, {
  offset: 0.4,
  opacity: '1',
  transform: 'translate3d(0, 20px, 0) scaleY(0.9)'
}, {
  offset: 0.45,
  opacity: '1',
  transform: 'translate3d(0, 20px, 0) scaleY(0.9)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, -2000px, 0) scaleY(3)'
}];

const fadeIn = [{
  offset: 0,
  opacity: '0'
}, {
  offset: 1,
  opacity: '1'
}];

const fadeInBottomLeft = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-100%, 100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInBottomRight = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(100%, 100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInDown = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, -100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInDownBig = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, -2000px, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInLeft = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-100%, 0, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInLeftBig = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-2000px, 0, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInRight = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(100%, 0, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInRightBig = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(2000px, 0, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInTopLeft = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-100%, -100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInTopRight = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(100%, -100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInUp = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, 100%, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeInUpBig = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(0, 2000px, 0)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const fadeOut = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0'
}];

const fadeOutBottomLeft = [{
  offset: 0,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(-100%, 100%, 0)'
}];

const fadeOutBottomRight = [{
  offset: 0,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(100%, 100%, 0)'
}];

const fadeOutDown = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, 100%, 0)'
}];

const fadeOutDownBig = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, 2000px, 0)'
}];

const fadeOutLeft = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(-100%, 0, 0)'
}];

const fadeOutLeftBig = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(-2000px, 0, 0)'
}];

const fadeOutRight = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(100%, 0, 0)'
}];

const fadeOutRightBig = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(2000px, 0, 0)'
}];

const fadeOutTopLeft = [{
  offset: 0,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(-100%, -100%, 0)'
}];

const fadeOutTopRight = [{
  offset: 0,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(100%, -100%, 0)'
}];

const fadeOutUp = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, -100%, 0)'
}];

const fadeOutUpBig = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(0, -2000px, 0)'
}];

const flip = [{
  offset: 0,
  transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)',
  easing: 'ease-out'
}, {
  offset: 0.4,
  transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -190deg)',
  easing: 'ease-out'
}, {
  offset: 0.5,
  transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px)\n      rotate3d(0, 1, 0, -170deg)',
  easing: 'ease-in'
}, {
  offset: 0.8,
  transform: 'perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0)\n      rotate3d(0, 1, 0, 0deg)',
  easing: 'ease-in'
}, {
  offset: 1,
  transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)',
  easing: 'ease-in'
}];

const flipInX = [{
  offset: 0,
  transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
  easing: 'ease-in',
  opacity: '0'
}, {
  offset: 0.4,
  transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
  easing: 'ease-in'
}, {
  offset: 0.6,
  transform: 'perspective(400px) rotate3d(1, 0, 0, 10deg)',
  opacity: '1'
}, {
  offset: 0.8,
  transform: 'perspective(400px) rotate3d(1, 0, 0, -5deg)'
}, {
  offset: 1,
  transform: 'perspective(400px)'
}];

const flipInY = [{
  offset: 0,
  transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
  easing: 'ease-in',
  opacity: '0'
}, {
  offset: 0.4,
  transform: 'perspective(400px) rotate3d(0, 1, 0, -20deg)',
  easing: 'ease-in'
}, {
  offset: 0.6,
  transform: 'perspective(400px) rotate3d(0, 1, 0, 10deg)',
  opacity: '1'
}, {
  offset: 0.8,
  transform: 'perspective(400px) rotate3d(0, 1, 0, -5deg)'
}, {
  offset: 1,
  transform: 'perspective(400px)'
}];

const flipOutX = [{
  offset: 0,
  transform: 'perspective(400px)'
}, {
  offset: 0.3,
  transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
  opacity: '1'
}, {
  offset: 1,
  transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
  opacity: '0'
}];

const flipOutY = [{
  offset: 0,
  transform: 'perspective(400px)'
}, {
  offset: 0.3,
  transform: 'perspective(400px) rotate3d(0, 1, 0, -15deg)',
  opacity: '1'
}, {
  offset: 1,
  transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
  opacity: '0'
}];

const lightSpeedInLeft = [{
  offset: 0,
  transform: 'translate3d(-100%, 0, 0) skewX(30deg)',
  opacity: '0'
}, {
  offset: 0.6,
  transform: 'skewX(-20deg)',
  opacity: '1'
}, {
  offset: 0.8,
  transform: 'skewX(5deg)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const lightSpeedInRight = [{
  offset: 0,
  transform: 'translate3d(100%, 0, 0) skewX(-30deg)',
  opacity: '0'
}, {
  offset: 0.6,
  transform: 'skewX(20deg)',
  opacity: '1'
}, {
  offset: 0.8,
  transform: 'skewX(-5deg)'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const lightSpeedOutLeft = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'translate3d(-100%, 0, 0) skewX(-30deg)',
  opacity: '0'
}];

const lightSpeedOutRight = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'translate3d(100%, 0, 0) skewX(30deg)',
  opacity: '0'
}];

const rotateIn = [{
  offset: 0,
  transform: 'rotate3d(0, 0, 1, -200deg)',
  opacity: '0'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)',
  opacity: '1'
}];

const rotateInDownLeft = [{
  offset: 0,
  transform: 'rotate3d(0, 0, 1, -45deg)',
  opacity: '0'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)',
  opacity: '1'
}];

const rotateInDownRight = [{
  offset: 0,
  transform: 'rotate3d(0, 0, 1, 45deg)',
  opacity: '0'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)',
  opacity: '1'
}];

const rotateInUpLeft = [{
  offset: 0,
  transform: 'rotate3d(0, 0, 1, 45deg)',
  opacity: '0'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)',
  opacity: '1'
}];

const rotateInUpRight = [{
  offset: 0,
  transform: 'rotate3d(0, 0, 1, -90deg)',
  opacity: '0'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)',
  opacity: '1'
}];

const rotateOut = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, 200deg)',
  opacity: '0'
}];

const rotateOutDownLeft = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, 45deg)',
  opacity: '0'
}];

const rotateOutDownRight = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, -45deg)',
  opacity: '0'
}];

const rotateOutUpLeft = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, -45deg)',
  opacity: '0'
}];

const rotateOutUpRight = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  transform: 'rotate3d(0, 0, 1, 90deg)',
  opacity: '0'
}];

const slideInDown = [{
  offset: 0,
  transform: 'translate3d(0, -100%, 0)',
  visibility: 'visible'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const slideInLeft = [{
  offset: 0,
  transform: 'translate3d(-100%, 0, 0)',
  visibility: 'visible'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const slideInRight = [{
  offset: 0,
  transform: 'translate3d(100%, 0, 0)',
  visibility: 'visible'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const slideInUp = [{
  offset: 0,
  transform: 'translate3d(0, 100%, 0)',
  visibility: 'visible'
}, {
  offset: 1,
  transform: 'translate3d(0, 0, 0)'
}];

const slideOutDown = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  visibility: 'hidden',
  transform: 'translate3d(0, 100%, 0)'
}];

const slideOutLeft = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  visibility: 'hidden',
  transform: 'translate3d(-100%, 0, 0)'
}];

const slideOutRight = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  visibility: 'hidden',
  transform: 'translate3d(100%, 0, 0)'
}];

const slideOutUp = [{
  offset: 0,
  transform: 'translate3d(0, 0, 0)'
}, {
  offset: 1,
  visibility: 'hidden',
  transform: 'translate3d(0, -100%, 0)'
}];

const hinge = [{
  offset: 0,
  easing: 'ease-in-out'
}, {
  offset: 0.2,
  transform: 'rotate3d(0, 0, 1, 80deg)',
  easing: 'ease-in-out'
}, {
  offset: 0.4,
  transform: 'rotate3d(0, 0, 1, 60deg)',
  easing: 'ease-in-out',
  opacity: '1'
}, {
  offset: 0.6,
  transform: 'rotate3d(0, 0, 1, 80deg)',
  easing: 'ease-in-out'
}, {
  offset: 0.8,
  transform: 'rotate3d(0, 0, 1, 60deg)',
  easing: 'ease-in-out',
  opacity: '1'
}, {
  offset: 1,
  transform: 'translate3d(0, 700px, 0)',
  opacity: '0'
}];

const jackInTheBox = [{
  offset: 0,
  opacity: '0',
  transform: 'scale(0.1) rotate(30deg)',
  'transform-origin': 'center bottom'
}, {
  offset: 0.5,
  transform: 'rotate(-10deg)'
}, {
  offset: 0.7,
  transform: 'rotate(3deg)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'scale(1)'
}];

const rollIn = [{
  offset: 0,
  opacity: '0',
  transform: 'translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)'
}, {
  offset: 1,
  opacity: '1',
  transform: 'translate3d(0, 0, 0)'
}];

const rollOut = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 1,
  opacity: '0',
  transform: 'translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)'
}];

const zoomIn = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.3, 0.3, 0.3)'
}, {
  offset: 0.5,
  opacity: '1'
}];

const zoomInDown = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const zoomInLeft = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const zoomInRight = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const zoomInUp = [{
  offset: 0,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 0.6,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const zoomOut = [{
  offset: 0,
  opacity: '1'
}, {
  offset: 0.5,
  opacity: '0',
  transform: 'scale3d(0.3, 0.3, 0.3)'
}, {
  offset: 1,
  opacity: '0'
}];

const zoomOutDown = [{
  offset: 0.4,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const zoomOutLeft = [{
  offset: 0.4,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'scale(0.1) translate3d(-2000px, 0, 0)'
}];

const zoomOutRight = [{
  offset: 0.4,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'scale(0.1) translate3d(2000px, 0, 0)'
}];

const zoomOutUp = [{
  offset: 0.4,
  opacity: '1',
  transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
  easing: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)'
}, {
  offset: 1,
  opacity: '0',
  transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)',
  easing: 'cubic-bezier(0.175, 0.885, 0.32, 1)'
}];

const easings = {
  linear: 'linear',
  ease: 'ease',
  easeIn: 'ease-in',
  easeOut: 'ease-out',
  easeInOut: 'ease-in-out',
  easeInSine: 'cubic-bezier(0.47, 0, 0.745, 0.715)',
  easeOutSine: 'cubic-bezier(0.39, 0.575, 0.565, 1)',
  easeInOutSine: 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',
  easeInQuad: 'cubic-bezier(0.55, 0.085, 0.68, 0.53)',
  easeOutQuad: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
  easeInOutQuad: 'cubic-bezier(0.455, 0.03, 0.515, 0.955)',
  easeInCubic: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
  easeOutCubic: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
  easeInOutCubic: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
  easeInQuart: 'cubic-bezier(0.895, 0.03, 0.685, 0.22)',
  easeOutQuart: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
  easeInOutQuart: 'cubic-bezier(0.77, 0, 0.175, 1)',
  easeInQuint: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
  easeOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)',
  easeInOutQuint: 'cubic-bezier(0.86, 0, 0.07, 1)',
  easeInExpo: 'cubic-bezier(0.95, 0.05, 0.795, 0.035)',
  easeOutExpo: 'cubic-bezier(0.19, 1, 0.22, 1)',
  easeInOutExpo: 'cubic-bezier(1, 0, 0, 1)',
  easeInCirc: 'cubic-bezier(0.6, 0.04, 0.98, 0.335)',
  easeOutCirc: 'cubic-bezier(0.075, 0.82, 0.165, 1)',
  easeInOutCirc: 'cubic-bezier(0.785, 0.135, 0.15, 0.86)',
  easeInBack: 'cubic-bezier(0.6, -0.28, 0.735, 0.045)',
  easeOutBack: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  easeInOutBack: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'
};

var animations = /*#__PURE__*/Object.freeze({
	__proto__: null,
	backInDown: backInDown,
	backInLeft: backInLeft,
	backInRight: backInRight,
	backInUp: backInUp,
	backOutDown: backOutDown,
	backOutLeft: backOutLeft,
	backOutRight: backOutRight,
	backOutUp: backOutUp,
	bounce: bounce,
	bounceIn: bounceIn,
	bounceInDown: bounceInDown,
	bounceInLeft: bounceInLeft,
	bounceInRight: bounceInRight,
	bounceInUp: bounceInUp,
	bounceOut: bounceOut,
	bounceOutDown: bounceOutDown,
	bounceOutLeft: bounceOutLeft,
	bounceOutRight: bounceOutRight,
	bounceOutUp: bounceOutUp,
	easings: easings,
	fadeIn: fadeIn,
	fadeInBottomLeft: fadeInBottomLeft,
	fadeInBottomRight: fadeInBottomRight,
	fadeInDown: fadeInDown,
	fadeInDownBig: fadeInDownBig,
	fadeInLeft: fadeInLeft,
	fadeInLeftBig: fadeInLeftBig,
	fadeInRight: fadeInRight,
	fadeInRightBig: fadeInRightBig,
	fadeInTopLeft: fadeInTopLeft,
	fadeInTopRight: fadeInTopRight,
	fadeInUp: fadeInUp,
	fadeInUpBig: fadeInUpBig,
	fadeOut: fadeOut,
	fadeOutBottomLeft: fadeOutBottomLeft,
	fadeOutBottomRight: fadeOutBottomRight,
	fadeOutDown: fadeOutDown,
	fadeOutDownBig: fadeOutDownBig,
	fadeOutLeft: fadeOutLeft,
	fadeOutLeftBig: fadeOutLeftBig,
	fadeOutRight: fadeOutRight,
	fadeOutRightBig: fadeOutRightBig,
	fadeOutTopLeft: fadeOutTopLeft,
	fadeOutTopRight: fadeOutTopRight,
	fadeOutUp: fadeOutUp,
	fadeOutUpBig: fadeOutUpBig,
	flash: flash,
	flip: flip,
	flipInX: flipInX,
	flipInY: flipInY,
	flipOutX: flipOutX,
	flipOutY: flipOutY,
	headShake: headShake,
	heartBeat: heartBeat,
	hinge: hinge,
	jackInTheBox: jackInTheBox,
	jello: jello,
	lightSpeedInLeft: lightSpeedInLeft,
	lightSpeedInRight: lightSpeedInRight,
	lightSpeedOutLeft: lightSpeedOutLeft,
	lightSpeedOutRight: lightSpeedOutRight,
	pulse: pulse,
	rollIn: rollIn,
	rollOut: rollOut,
	rotateIn: rotateIn,
	rotateInDownLeft: rotateInDownLeft,
	rotateInDownRight: rotateInDownRight,
	rotateInUpLeft: rotateInUpLeft,
	rotateInUpRight: rotateInUpRight,
	rotateOut: rotateOut,
	rotateOutDownLeft: rotateOutDownLeft,
	rotateOutDownRight: rotateOutDownRight,
	rotateOutUpLeft: rotateOutUpLeft,
	rotateOutUpRight: rotateOutUpRight,
	rubberBand: rubberBand,
	shake: shake,
	shakeX: shakeX,
	shakeY: shakeY,
	slideInDown: slideInDown,
	slideInLeft: slideInLeft,
	slideInRight: slideInRight,
	slideInUp: slideInUp,
	slideOutDown: slideOutDown,
	slideOutLeft: slideOutLeft,
	slideOutRight: slideOutRight,
	slideOutUp: slideOutUp,
	swing: swing,
	tada: tada,
	wobble: wobble,
	zoomIn: zoomIn,
	zoomInDown: zoomInDown,
	zoomInLeft: zoomInLeft,
	zoomInRight: zoomInRight,
	zoomInUp: zoomInUp,
	zoomOut: zoomOut,
	zoomOutDown: zoomOutDown,
	zoomOutLeft: zoomOutLeft,
	zoomOutRight: zoomOutRight,
	zoomOutUp: zoomOutUp
});

// src/components/animation/animation.styles.ts
var animation_styles_default = i$7`
  :host {
    display: contents;
  }
`;

var SlAnimation = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasStarted = false;
    this.name = "none";
    this.play = false;
    this.delay = 0;
    this.direction = "normal";
    this.duration = 1e3;
    this.easing = "linear";
    this.endDelay = 0;
    this.fill = "auto";
    this.iterations = Infinity;
    this.iterationStart = 0;
    this.playbackRate = 1;
    this.handleAnimationFinish = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-finish");
    };
    this.handleAnimationCancel = () => {
      this.play = false;
      this.hasStarted = false;
      this.emit("sl-cancel");
    };
  }
  /** Gets and sets the current animation time. */
  get currentTime() {
    var _a, _b;
    return (_b = (_a = this.animation) == null ? void 0 : _a.currentTime) != null ? _b : 0;
  }
  set currentTime(time) {
    if (this.animation) {
      this.animation.currentTime = time;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.createAnimation();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.destroyAnimation();
  }
  handleSlotChange() {
    this.destroyAnimation();
    this.createAnimation();
  }
  async createAnimation() {
    var _a, _b;
    const easing = (_a = easings[this.easing]) != null ? _a : this.easing;
    const keyframes = (_b = this.keyframes) != null ? _b : animations[this.name];
    const slot = await this.defaultSlot;
    const element = slot.assignedElements()[0];
    if (!element || !keyframes) {
      return false;
    }
    this.destroyAnimation();
    this.animation = element.animate(keyframes, {
      delay: this.delay,
      direction: this.direction,
      duration: this.duration,
      easing,
      endDelay: this.endDelay,
      fill: this.fill,
      iterationStart: this.iterationStart,
      iterations: this.iterations
    });
    this.animation.playbackRate = this.playbackRate;
    this.animation.addEventListener("cancel", this.handleAnimationCancel);
    this.animation.addEventListener("finish", this.handleAnimationFinish);
    if (this.play) {
      this.hasStarted = true;
      this.emit("sl-start");
    } else {
      this.animation.pause();
    }
    return true;
  }
  destroyAnimation() {
    if (this.animation) {
      this.animation.cancel();
      this.animation.removeEventListener("cancel", this.handleAnimationCancel);
      this.animation.removeEventListener("finish", this.handleAnimationFinish);
      this.hasStarted = false;
    }
  }
  handleAnimationChange() {
    if (!this.hasUpdated) {
      return;
    }
    this.createAnimation();
  }
  handlePlayChange() {
    if (this.animation) {
      if (this.play && !this.hasStarted) {
        this.hasStarted = true;
        this.emit("sl-start");
      }
      if (this.play) {
        this.animation.play();
      } else {
        this.animation.pause();
      }
      return true;
    }
    return false;
  }
  handlePlaybackRateChange() {
    if (this.animation) {
      this.animation.playbackRate = this.playbackRate;
    }
  }
  /** Clears all keyframe effects caused by this animation and aborts its playback. */
  cancel() {
    var _a;
    (_a = this.animation) == null ? void 0 : _a.cancel();
  }
  /** Sets the playback time to the end of the animation corresponding to the current playback direction. */
  finish() {
    var _a;
    (_a = this.animation) == null ? void 0 : _a.finish();
  }
  render() {
    return x` <slot @slotchange=${this.handleSlotChange}></slot> `;
  }
};
SlAnimation.styles = [component_styles_default, animation_styles_default];
__decorateClass([r$2("slot")], SlAnimation.prototype, "defaultSlot", 2);
__decorateClass([n$6()], SlAnimation.prototype, "name", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlAnimation.prototype, "play", 2);
__decorateClass([n$6({
  type: Number
})], SlAnimation.prototype, "delay", 2);
__decorateClass([n$6()], SlAnimation.prototype, "direction", 2);
__decorateClass([n$6({
  type: Number
})], SlAnimation.prototype, "duration", 2);
__decorateClass([n$6()], SlAnimation.prototype, "easing", 2);
__decorateClass([n$6({
  attribute: "end-delay",
  type: Number
})], SlAnimation.prototype, "endDelay", 2);
__decorateClass([n$6()], SlAnimation.prototype, "fill", 2);
__decorateClass([n$6({
  type: Number
})], SlAnimation.prototype, "iterations", 2);
__decorateClass([n$6({
  attribute: "iteration-start",
  type: Number
})], SlAnimation.prototype, "iterationStart", 2);
__decorateClass([n$6({
  attribute: false
})], SlAnimation.prototype, "keyframes", 2);
__decorateClass([n$6({
  attribute: "playback-rate",
  type: Number
})], SlAnimation.prototype, "playbackRate", 2);
__decorateClass([watch(["name", "delay", "direction", "duration", "easing", "endDelay", "fill", "iterations", "iterationsStart", "keyframes"])], SlAnimation.prototype, "handleAnimationChange", 1);
__decorateClass([watch("play")], SlAnimation.prototype, "handlePlayChange", 1);
__decorateClass([watch("playbackRate")], SlAnimation.prototype, "handlePlaybackRateChange", 1);

var tagName$7 = "sl-animation";
SlAnimation.define("sl-animation");
o$8({
  tagName: tagName$7,
  elementClass: SlAnimation,
  react: React$1,
  events: {
    onSlCancel: "sl-cancel",
    onSlFinish: "sl-finish",
    onSlStart: "sl-start"
  },
  displayName: "SlAnimation"
});

// src/components/avatar/avatar.styles.ts
var avatar_styles_default = i$7`
  :host {
    display: inline-block;

    --size: 3rem;
  }

  .avatar {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: var(--size);
    height: var(--size);
    background-color: var(--sl-color-neutral-400);
    font-family: var(--sl-font-sans);
    font-size: calc(var(--size) * 0.5);
    font-weight: var(--sl-font-weight-normal);
    color: var(--sl-color-neutral-0);
    user-select: none;
    -webkit-user-select: none;
    vertical-align: middle;
  }

  .avatar--circle,
  .avatar--circle .avatar__image {
    border-radius: var(--sl-border-radius-circle);
  }

  .avatar--rounded,
  .avatar--rounded .avatar__image {
    border-radius: var(--sl-border-radius-medium);
  }

  .avatar--square {
    border-radius: 0;
  }

  .avatar__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .avatar__initials {
    line-height: 1;
    text-transform: uppercase;
  }

  .avatar__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    overflow: hidden;
  }
`;

var SlAvatar = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasError = false;
    this.image = "";
    this.label = "";
    this.initials = "";
    this.loading = "eager";
    this.shape = "circle";
  }
  handleImageChange() {
    this.hasError = false;
  }
  handleImageLoadError() {
    this.hasError = true;
    this.emit("sl-error");
  }
  render() {
    const avatarWithImage = x`
      <img
        part="image"
        class="avatar__image"
        src="${this.image}"
        loading="${this.loading}"
        alt=""
        @error="${this.handleImageLoadError}"
      />
    `;
    let avatarWithoutImage = x``;
    if (this.initials) {
      avatarWithoutImage = x`<div part="initials" class="avatar__initials">${this.initials}</div>`;
    } else {
      avatarWithoutImage = x`
        <div part="icon" class="avatar__icon" aria-hidden="true">
          <slot name="icon">
            <sl-icon name="person-fill" library="system"></sl-icon>
          </slot>
        </div>
      `;
    }
    return x`
      <div
        part="base"
        class=${e$3({
      avatar: true,
      "avatar--circle": this.shape === "circle",
      "avatar--rounded": this.shape === "rounded",
      "avatar--square": this.shape === "square"
    })}
        role="img"
        aria-label=${this.label}
      >
        ${this.image && !this.hasError ? avatarWithImage : avatarWithoutImage}
      </div>
    `;
  }
};
SlAvatar.styles = [component_styles_default, avatar_styles_default];
SlAvatar.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([r$3()], SlAvatar.prototype, "hasError", 2);
__decorateClass([n$6()], SlAvatar.prototype, "image", 2);
__decorateClass([n$6()], SlAvatar.prototype, "label", 2);
__decorateClass([n$6()], SlAvatar.prototype, "initials", 2);
__decorateClass([n$6()], SlAvatar.prototype, "loading", 2);
__decorateClass([n$6({
  reflect: true
})], SlAvatar.prototype, "shape", 2);
__decorateClass([watch("image")], SlAvatar.prototype, "handleImageChange", 1);

var tagName$6 = "sl-avatar";
SlAvatar.define("sl-avatar");
o$8({
  tagName: tagName$6,
  elementClass: SlAvatar,
  react: React$1,
  events: {
    onSlError: "sl-error"
  },
  displayName: "SlAvatar"
});

// src/components/breadcrumb/breadcrumb.styles.ts
var breadcrumb_styles_default = i$7`
  .breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }
`;

var SlBreadcrumb = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController(this);
    this.separatorDir = this.localize.dir();
    this.label = "";
  }
  // Generates a clone of the separator element to use for each breadcrumb item
  getSeparator() {
    const separator = this.separatorSlot.assignedElements({
      flatten: true
    })[0];
    const clone = separator.cloneNode(true);
    [clone, ...clone.querySelectorAll("[id]")].forEach(el => el.removeAttribute("id"));
    clone.setAttribute("data-default", "");
    clone.slot = "separator";
    return clone;
  }
  handleSlotChange() {
    const items = [...this.defaultSlot.assignedElements({
      flatten: true
    })].filter(item => item.tagName.toLowerCase() === "sl-breadcrumb-item");
    items.forEach((item, index) => {
      const separator = item.querySelector('[slot="separator"]');
      if (separator === null) {
        item.append(this.getSeparator());
      } else if (separator.hasAttribute("data-default")) {
        separator.replaceWith(this.getSeparator());
      } else ;
      if (index === items.length - 1) {
        item.setAttribute("aria-current", "page");
      } else {
        item.removeAttribute("aria-current");
      }
    });
  }
  render() {
    if (this.separatorDir !== this.localize.dir()) {
      this.separatorDir = this.localize.dir();
      this.updateComplete.then(() => this.handleSlotChange());
    }
    return x`
      <nav part="base" class="breadcrumb" aria-label=${this.label}>
        <slot @slotchange=${this.handleSlotChange}></slot>
      </nav>

      <span hidden aria-hidden="true">
        <slot name="separator">
          <sl-icon name=${this.localize.dir() === "rtl" ? "chevron-left" : "chevron-right"} library="system"></sl-icon>
        </slot>
      </span>
    `;
  }
};
SlBreadcrumb.styles = [component_styles_default, breadcrumb_styles_default];
SlBreadcrumb.dependencies = {
  "sl-icon": SlIcon
};
__decorateClass([e$7("slot")], SlBreadcrumb.prototype, "defaultSlot", 2);
__decorateClass([e$7('slot[name="separator"]')], SlBreadcrumb.prototype, "separatorSlot", 2);
__decorateClass([n$6()], SlBreadcrumb.prototype, "label", 2);

var tagName$5 = "sl-breadcrumb";
SlBreadcrumb.define("sl-breadcrumb");
o$8({
  tagName: tagName$5,
  elementClass: SlBreadcrumb,
  react: React$1,
  events: {},
  displayName: "SlBreadcrumb"
});

var tagName$4 = "sl-button";
SlButton.define("sl-button");
o$8({
  tagName: tagName$4,
  elementClass: SlButton,
  react: React$1,
  events: {
    onSlBlur: "sl-blur",
    onSlFocus: "sl-focus",
    onSlInvalid: "sl-invalid"
  },
  displayName: "SlButton"
});

// src/components/breadcrumb-item/breadcrumb-item.styles.ts
var breadcrumb_item_styles_default = i$7`
  :host {
    display: inline-flex;
  }

  .breadcrumb-item {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-600);
    line-height: var(--sl-line-height-normal);
    white-space: nowrap;
  }

  .breadcrumb-item__label {
    display: inline-block;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    text-decoration: none;
    color: inherit;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: var(--sl-transition-fast) --color;
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label {
    color: var(--sl-color-primary-600);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:hover {
    color: var(--sl-color-primary-500);
  }

  :host(:not(:last-of-type)) .breadcrumb-item__label:active {
    color: var(--sl-color-primary-600);
  }

  .breadcrumb-item__label:focus {
    outline: none;
  }

  .breadcrumb-item__label:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .breadcrumb-item__prefix,
  .breadcrumb-item__suffix {
    display: none;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .breadcrumb-item--has-prefix .breadcrumb-item__prefix {
    display: inline-flex;
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .breadcrumb-item--has-suffix .breadcrumb-item__suffix {
    display: inline-flex;
    margin-inline-start: var(--sl-spacing-x-small);
  }

  :host(:last-of-type) .breadcrumb-item__separator {
    display: none;
  }

  .breadcrumb-item__separator {
    display: inline-flex;
    align-items: center;
    margin: 0 var(--sl-spacing-x-small);
    user-select: none;
    -webkit-user-select: none;
  }
`;

var SlBreadcrumbItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "prefix", "suffix");
    this.renderType = "button";
    this.rel = "noreferrer noopener";
  }
  setRenderType() {
    const hasDropdown = this.defaultSlot.assignedElements({
      flatten: true
    }).filter(i => i.tagName.toLowerCase() === "sl-dropdown").length > 0;
    if (this.href) {
      this.renderType = "link";
      return;
    }
    if (hasDropdown) {
      this.renderType = "dropdown";
      return;
    }
    this.renderType = "button";
  }
  hrefChanged() {
    this.setRenderType();
  }
  handleSlotChange() {
    this.setRenderType();
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      "breadcrumb-item": true,
      "breadcrumb-item--has-prefix": this.hasSlotController.test("prefix"),
      "breadcrumb-item--has-suffix": this.hasSlotController.test("suffix")
    })}
      >
        <span part="prefix" class="breadcrumb-item__prefix">
          <slot name="prefix"></slot>
        </span>

        ${this.renderType === "link" ? x`
              <a
                part="label"
                class="breadcrumb-item__label breadcrumb-item__label--link"
                href="${this.href}"
                target="${o$6(this.target ? this.target : void 0)}"
                rel=${o$6(this.target ? this.rel : void 0)}
              >
                <slot @slotchange=${this.handleSlotChange}></slot>
              </a>
            ` : ""}
        ${this.renderType === "button" ? x`
              <button part="label" type="button" class="breadcrumb-item__label breadcrumb-item__label--button">
                <slot @slotchange=${this.handleSlotChange}></slot>
              </button>
            ` : ""}
        ${this.renderType === "dropdown" ? x`
              <div part="label" class="breadcrumb-item__label breadcrumb-item__label--drop-down">
                <slot @slotchange=${this.handleSlotChange}></slot>
              </div>
            ` : ""}

        <span part="suffix" class="breadcrumb-item__suffix">
          <slot name="suffix"></slot>
        </span>

        <span part="separator" class="breadcrumb-item__separator" aria-hidden="true">
          <slot name="separator"></slot>
        </span>
      </div>
    `;
  }
};
SlBreadcrumbItem.styles = [component_styles_default, breadcrumb_item_styles_default];
__decorateClass([e$7("slot:not([name])")], SlBreadcrumbItem.prototype, "defaultSlot", 2);
__decorateClass([r$3()], SlBreadcrumbItem.prototype, "renderType", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "href", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "target", 2);
__decorateClass([n$6()], SlBreadcrumbItem.prototype, "rel", 2);
__decorateClass([watch("href", {
  waitUntilFirstUpdate: true
})], SlBreadcrumbItem.prototype, "hrefChanged", 1);

var tagName$3 = "sl-breadcrumb-item";
SlBreadcrumbItem.define("sl-breadcrumb-item");
o$8({
  tagName: tagName$3,
  elementClass: SlBreadcrumbItem,
  react: React$1,
  events: {},
  displayName: "SlBreadcrumbItem"
});

// src/components/badge/badge.styles.ts
var badge_styles_default = i$7`
  :host {
    display: inline-flex;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: max(12px, 0.75em);
    font-weight: var(--sl-font-weight-semibold);
    letter-spacing: var(--sl-letter-spacing-normal);
    line-height: 1;
    border-radius: var(--sl-border-radius-small);
    border: solid 1px var(--sl-color-neutral-0);
    white-space: nowrap;
    padding: 0.35em 0.6em;
    user-select: none;
    -webkit-user-select: none;
    cursor: inherit;
  }

  /* Variant modifiers */
  .badge--primary {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--success {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--neutral {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--warning {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .badge--danger {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /* Pill modifier */
  .badge--pill {
    border-radius: var(--sl-border-radius-pill);
  }

  /* Pulse modifier */
  .badge--pulse {
    animation: pulse 1.5s infinite;
  }

  .badge--pulse.badge--primary {
    --pulse-color: var(--sl-color-primary-600);
  }

  .badge--pulse.badge--success {
    --pulse-color: var(--sl-color-success-600);
  }

  .badge--pulse.badge--neutral {
    --pulse-color: var(--sl-color-neutral-600);
  }

  .badge--pulse.badge--warning {
    --pulse-color: var(--sl-color-warning-600);
  }

  .badge--pulse.badge--danger {
    --pulse-color: var(--sl-color-danger-600);
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--pulse-color);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }
`;

var SlBadge = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.variant = "primary";
    this.pill = false;
    this.pulse = false;
  }
  render() {
    return x`
      <span
        part="base"
        class=${e$3({
      badge: true,
      "badge--primary": this.variant === "primary",
      "badge--success": this.variant === "success",
      "badge--neutral": this.variant === "neutral",
      "badge--warning": this.variant === "warning",
      "badge--danger": this.variant === "danger",
      "badge--pill": this.pill,
      "badge--pulse": this.pulse
    })}
        role="status"
      >
        <slot></slot>
      </span>
    `;
  }
};
SlBadge.styles = [component_styles_default, badge_styles_default];
__decorateClass([n$6({
  reflect: true
})], SlBadge.prototype, "variant", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlBadge.prototype, "pill", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], SlBadge.prototype, "pulse", 2);

var tagName$2 = "sl-badge";
SlBadge.define("sl-badge");
o$8({
  tagName: tagName$2,
  elementClass: SlBadge,
  react: React$1,
  events: {},
  displayName: "SlBadge"
});

// src/components/card/card.styles.ts
var card_styles_default = i$7`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;

var SlCard = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      card: true,
      "card--has-footer": this.hasSlotController.test("footer"),
      "card--has-image": this.hasSlotController.test("image"),
      "card--has-header": this.hasSlotController.test("header")
    })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
  }
};
SlCard.styles = [component_styles_default, card_styles_default];

var tagName$1 = "sl-card";
SlCard.define("sl-card");
o$8({
  tagName: tagName$1,
  elementClass: SlCard,
  react: React$1,
  events: {},
  displayName: "SlCard"
});

// src/components/alert/alert.styles.ts
var alert_styles_default = i$7`
  :host {
    display: contents;

    /* For better DX, we'll reset the margin here so the base part can inherit it */
    margin: 0;
  }

  .alert {
    position: relative;
    display: flex;
    align-items: stretch;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-top-width: calc(var(--sl-panel-border-width) * 3);
    border-radius: var(--sl-border-radius-medium);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-normal);
    line-height: 1.6;
    color: var(--sl-color-neutral-700);
    margin: inherit;
    overflow: hidden;
  }

  .alert:not(.alert--has-icon) .alert__icon,
  .alert:not(.alert--closable) .alert__close-button {
    display: none;
  }

  .alert__icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-large);
    padding-inline-start: var(--sl-spacing-large);
  }

  .alert--has-countdown {
    border-bottom: none;
  }

  .alert--primary {
    border-top-color: var(--sl-color-primary-600);
  }

  .alert--primary .alert__icon {
    color: var(--sl-color-primary-600);
  }

  .alert--success {
    border-top-color: var(--sl-color-success-600);
  }

  .alert--success .alert__icon {
    color: var(--sl-color-success-600);
  }

  .alert--neutral {
    border-top-color: var(--sl-color-neutral-600);
  }

  .alert--neutral .alert__icon {
    color: var(--sl-color-neutral-600);
  }

  .alert--warning {
    border-top-color: var(--sl-color-warning-600);
  }

  .alert--warning .alert__icon {
    color: var(--sl-color-warning-600);
  }

  .alert--danger {
    border-top-color: var(--sl-color-danger-600);
  }

  .alert--danger .alert__icon {
    color: var(--sl-color-danger-600);
  }

  .alert__message {
    flex: 1 1 auto;
    display: block;
    padding: var(--sl-spacing-large);
    overflow: hidden;
  }

  .alert__close-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    font-size: var(--sl-font-size-medium);
    margin-inline-end: var(--sl-spacing-medium);
    align-self: center;
  }

  .alert__countdown {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: calc(var(--sl-panel-border-width) * 3);
    background-color: var(--sl-panel-border-color);
    display: flex;
  }

  .alert__countdown--ltr {
    justify-content: flex-end;
  }

  .alert__countdown .alert__countdown-elapsed {
    height: 100%;
    width: 0;
  }

  .alert--primary .alert__countdown-elapsed {
    background-color: var(--sl-color-primary-600);
  }

  .alert--success .alert__countdown-elapsed {
    background-color: var(--sl-color-success-600);
  }

  .alert--neutral .alert__countdown-elapsed {
    background-color: var(--sl-color-neutral-600);
  }

  .alert--warning .alert__countdown-elapsed {
    background-color: var(--sl-color-warning-600);
  }

  .alert--danger .alert__countdown-elapsed {
    background-color: var(--sl-color-danger-600);
  }

  .alert__timer {
    display: none;
  }
`;

var _SlAlert = class _SlAlert extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasSlotController = new HasSlotController(this, "icon", "suffix");
    this.localize = new LocalizeController(this);
    this.open = false;
    this.closable = false;
    this.variant = "primary";
    this.duration = Infinity;
    this.remainingTime = this.duration;
  }
  static get toastStack() {
    if (!this.currentToastStack) {
      this.currentToastStack = Object.assign(document.createElement("div"), {
        className: "sl-toast-stack"
      });
    }
    return this.currentToastStack;
  }
  firstUpdated() {
    this.base.hidden = !this.open;
  }
  restartAutoHide() {
    this.handleCountdownChange();
    clearTimeout(this.autoHideTimeout);
    clearInterval(this.remainingTimeInterval);
    if (this.open && this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(() => this.hide(), this.duration);
      this.remainingTime = this.duration;
      this.remainingTimeInterval = window.setInterval(() => {
        this.remainingTime -= 100;
      }, 100);
    }
  }
  pauseAutoHide() {
    var _a;
    (_a = this.countdownAnimation) == null ? void 0 : _a.pause();
    clearTimeout(this.autoHideTimeout);
    clearInterval(this.remainingTimeInterval);
  }
  resumeAutoHide() {
    var _a;
    if (this.duration < Infinity) {
      this.autoHideTimeout = window.setTimeout(() => this.hide(), this.remainingTime);
      this.remainingTimeInterval = window.setInterval(() => {
        this.remainingTime -= 100;
      }, 100);
      (_a = this.countdownAnimation) == null ? void 0 : _a.play();
    }
  }
  handleCountdownChange() {
    if (this.open && this.duration < Infinity && this.countdown) {
      const {
        countdownElement
      } = this;
      const start = "100%";
      const end = "0";
      this.countdownAnimation = countdownElement.animate([{
        width: start
      }, {
        width: end
      }], {
        duration: this.duration,
        easing: "linear"
      });
    }
  }
  handleCloseClick() {
    this.hide();
  }
  async handleOpenChange() {
    if (this.open) {
      this.emit("sl-show");
      if (this.duration < Infinity) {
        this.restartAutoHide();
      }
      await stopAnimations(this.base);
      this.base.hidden = false;
      const {
        keyframes,
        options
      } = getAnimation(this, "alert.show", {
        dir: this.localize.dir()
      });
      await animateTo(this.base, keyframes, options);
      this.emit("sl-after-show");
    } else {
      blurActiveElement(this);
      this.emit("sl-hide");
      clearTimeout(this.autoHideTimeout);
      clearInterval(this.remainingTimeInterval);
      await stopAnimations(this.base);
      const {
        keyframes,
        options
      } = getAnimation(this, "alert.hide", {
        dir: this.localize.dir()
      });
      await animateTo(this.base, keyframes, options);
      this.base.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  handleDurationChange() {
    this.restartAutoHide();
  }
  /** Shows the alert. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the alert */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Displays the alert as a toast notification. This will move the alert out of its position in the DOM and, when
   * dismissed, it will be removed from the DOM completely. By storing a reference to the alert, you can reuse it by
   * calling this method again. The returned promise will resolve after the alert is hidden.
   */
  async toast() {
    return new Promise(resolve => {
      this.handleCountdownChange();
      if (_SlAlert.toastStack.parentElement === null) {
        document.body.append(_SlAlert.toastStack);
      }
      _SlAlert.toastStack.appendChild(this);
      requestAnimationFrame(() => {
        this.clientWidth;
        this.show();
      });
      this.addEventListener("sl-after-hide", () => {
        _SlAlert.toastStack.removeChild(this);
        resolve();
        if (_SlAlert.toastStack.querySelector("sl-alert") === null) {
          _SlAlert.toastStack.remove();
        }
      }, {
        once: true
      });
    });
  }
  render() {
    return x`
      <div
        part="base"
        class=${e$3({
      alert: true,
      "alert--open": this.open,
      "alert--closable": this.closable,
      "alert--has-countdown": !!this.countdown,
      "alert--has-icon": this.hasSlotController.test("icon"),
      "alert--primary": this.variant === "primary",
      "alert--success": this.variant === "success",
      "alert--neutral": this.variant === "neutral",
      "alert--warning": this.variant === "warning",
      "alert--danger": this.variant === "danger"
    })}
        role="alert"
        aria-hidden=${this.open ? "false" : "true"}
        @mouseenter=${this.pauseAutoHide}
        @mouseleave=${this.resumeAutoHide}
      >
        <div part="icon" class="alert__icon">
          <slot name="icon"></slot>
        </div>

        <div part="message" class="alert__message" aria-live="polite">
          <slot></slot>
        </div>

        ${this.closable ? x`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                class="alert__close-button"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                @click=${this.handleCloseClick}
              ></sl-icon-button>
            ` : ""}

        <div role="timer" class="alert__timer">${this.remainingTime}</div>

        ${this.countdown ? x`
              <div
                class=${e$3({
      alert__countdown: true,
      "alert__countdown--ltr": this.countdown === "ltr"
    })}
              >
                <div class="alert__countdown-elapsed"></div>
              </div>
            ` : ""}
      </div>
    `;
  }
};
_SlAlert.styles = [component_styles_default, alert_styles_default];
_SlAlert.dependencies = {
  "sl-icon-button": SlIconButton
};
__decorateClass([e$7('[part~="base"]')], _SlAlert.prototype, "base", 2);
__decorateClass([e$7(".alert__countdown-elapsed")], _SlAlert.prototype, "countdownElement", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlAlert.prototype, "open", 2);
__decorateClass([n$6({
  type: Boolean,
  reflect: true
})], _SlAlert.prototype, "closable", 2);
__decorateClass([n$6({
  reflect: true
})], _SlAlert.prototype, "variant", 2);
__decorateClass([n$6({
  type: Number
})], _SlAlert.prototype, "duration", 2);
__decorateClass([n$6({
  type: String,
  reflect: true
})], _SlAlert.prototype, "countdown", 2);
__decorateClass([r$3()], _SlAlert.prototype, "remainingTime", 2);
__decorateClass([watch("open", {
  waitUntilFirstUpdate: true
})], _SlAlert.prototype, "handleOpenChange", 1);
__decorateClass([watch("duration")], _SlAlert.prototype, "handleDurationChange", 1);
var SlAlert = _SlAlert;
setDefaultAnimation("alert.show", {
  keyframes: [{
    opacity: 0,
    scale: 0.8
  }, {
    opacity: 1,
    scale: 1
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});
setDefaultAnimation("alert.hide", {
  keyframes: [{
    opacity: 1,
    scale: 1
  }, {
    opacity: 0,
    scale: 0.8
  }],
  options: {
    duration: 250,
    easing: "ease"
  }
});

var tagName = "sl-alert";
SlAlert.define("sl-alert");
o$8({
  tagName,
  elementClass: SlAlert,
  react: React$1,
  events: {
    onSlShow: "sl-show",
    onSlAfterShow: "sl-after-show",
    onSlHide: "sl-hide",
    onSlAfterHide: "sl-after-hide"
  },
  displayName: "SlAlert"
});

// src/internal/scrollend-polyfill.ts
var debounce = (fn, delay) => {
  let timerId = 0;
  return function (...args) {
    window.clearTimeout(timerId);
    timerId = window.setTimeout(() => {
      fn.call(this, ...args);
    }, delay);
  };
};
var decorate = (proto, method, decorateFn) => {
  const superFn = proto[method];
  proto[method] = function (...args) {
    superFn.call(this, ...args);
    decorateFn.call(this, superFn, ...args);
  };
};
(() => {
  if (typeof window === "undefined") {
    return;
  }
  const isSupported = "onscrollend" in window;
  if (!isSupported) {
    const pointers = /* @__PURE__ */new Set();
    const scrollHandlers = /* @__PURE__ */new WeakMap();
    const handlePointerDown = event => {
      for (const touch of event.changedTouches) {
        pointers.add(touch.identifier);
      }
    };
    const handlePointerUp = event => {
      for (const touch of event.changedTouches) {
        pointers.delete(touch.identifier);
      }
    };
    document.addEventListener("touchstart", handlePointerDown, true);
    document.addEventListener("touchend", handlePointerUp, true);
    document.addEventListener("touchcancel", handlePointerUp, true);
    decorate(EventTarget.prototype, "addEventListener", function (addEventListener, type) {
      if (type !== "scrollend") return;
      const handleScrollEnd = debounce(() => {
        if (!pointers.size) {
          this.dispatchEvent(new Event("scrollend"));
        } else {
          handleScrollEnd();
        }
      }, 100);
      addEventListener.call(this, "scroll", handleScrollEnd, {
        passive: true
      });
      scrollHandlers.set(this, handleScrollEnd);
    });
    decorate(EventTarget.prototype, "removeEventListener", function (removeEventListener, type) {
      if (type !== "scrollend") return;
      const scrollHandler = scrollHandlers.get(this);
      if (scrollHandler) {
        removeEventListener.call(this, "scroll", scrollHandler, {
          passive: true
        });
      }
    });
  }
})();

function About() {
  return /*#__PURE__*/React.createElement("div", {
    className: `mt-4 space-y-8`,
    style: {
      maxWidth: "800px"
    }
  }, /*#__PURE__*/React.createElement(details_default, {
    summary: "Section One"
  }, "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."), /*#__PURE__*/React.createElement(details_default, {
    summary: "Section Two"
  }, "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."));
}

var client = {exports: {}};

var reactDomClient_production = {};

var scheduler = {exports: {}};

var scheduler_production = {};

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_production;

function requireScheduler_production () {
	if (hasRequiredScheduler_production) return scheduler_production;
	hasRequiredScheduler_production = 1;
	(function (exports) {

		function push(heap, node) {
		  var index = heap.length;
		  heap.push(node);
		  a: for (; 0 < index;) {
		    var parentIndex = index - 1 >>> 1,
		      parent = heap[parentIndex];
		    if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
		  }
		}
		function peek(heap) {
		  return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
		  if (0 === heap.length) return null;
		  var first = heap[0],
		    last = heap.pop();
		  if (last !== first) {
		    heap[0] = last;
		    a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
		      var leftIndex = 2 * (index + 1) - 1,
		        left = heap[leftIndex],
		        rightIndex = leftIndex + 1,
		        right = heap[rightIndex];
		      if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
		    }
		  }
		  return first;
		}
		function compare(a, b) {
		  var diff = a.sortIndex - b.sortIndex;
		  return 0 !== diff ? diff : a.id - b.id;
		}
		exports.unstable_now = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
		  var localPerformance = performance;
		  exports.unstable_now = function () {
		    return localPerformance.now();
		  };
		} else {
		  var localDate = Date,
		    initialTime = localDate.now();
		  exports.unstable_now = function () {
		    return localDate.now() - initialTime;
		  };
		}
		var taskQueue = [],
		  timerQueue = [],
		  taskIdCounter = 1,
		  currentTask = null,
		  currentPriorityLevel = 3,
		  isPerformingWork = false,
		  isHostCallbackScheduled = false,
		  isHostTimeoutScheduled = false,
		  needsPaint = false,
		  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
		  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
		function advanceTimers(currentTime) {
		  for (var timer = peek(timerQueue); null !== timer;) {
		    if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
		    timer = peek(timerQueue);
		  }
		}
		function handleTimeout(currentTime) {
		  isHostTimeoutScheduled = false;
		  advanceTimers(currentTime);
		  if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());else {
		    var firstTimer = peek(timerQueue);
		    null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		  }
		}
		var isMessageLoopRunning = false,
		  taskTimeoutID = -1,
		  frameInterval = 5,
		  startTime = -1;
		function shouldYieldToHost() {
		  return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
		}
		function performWorkUntilDeadline() {
		  needsPaint = false;
		  if (isMessageLoopRunning) {
		    var currentTime = exports.unstable_now();
		    startTime = currentTime;
		    var hasMoreWork = true;
		    try {
		      a: {
		        isHostCallbackScheduled = !1;
		        isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
		        isPerformingWork = !0;
		        var previousPriorityLevel = currentPriorityLevel;
		        try {
		          b: {
		            advanceTimers(currentTime);
		            for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
		              var callback = currentTask.callback;
		              if ("function" === typeof callback) {
		                currentTask.callback = null;
		                currentPriorityLevel = currentTask.priorityLevel;
		                var continuationCallback = callback(currentTask.expirationTime <= currentTime);
		                currentTime = exports.unstable_now();
		                if ("function" === typeof continuationCallback) {
		                  currentTask.callback = continuationCallback;
		                  advanceTimers(currentTime);
		                  hasMoreWork = !0;
		                  break b;
		                }
		                currentTask === peek(taskQueue) && pop(taskQueue);
		                advanceTimers(currentTime);
		              } else pop(taskQueue);
		              currentTask = peek(taskQueue);
		            }
		            if (null !== currentTask) hasMoreWork = !0;else {
		              var firstTimer = peek(timerQueue);
		              null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		              hasMoreWork = !1;
		            }
		          }
		          break a;
		        } finally {
		          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
		        }
		        hasMoreWork = void 0;
		      }
		    } finally {
		      hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
		    }
		  }
		}
		var schedulePerformWorkUntilDeadline;
		if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function () {
		  localSetImmediate(performWorkUntilDeadline);
		};else if ("undefined" !== typeof MessageChannel) {
		  var channel = new MessageChannel(),
		    port = channel.port2;
		  channel.port1.onmessage = performWorkUntilDeadline;
		  schedulePerformWorkUntilDeadline = function () {
		    port.postMessage(null);
		  };
		} else schedulePerformWorkUntilDeadline = function () {
		  localSetTimeout(performWorkUntilDeadline, 0);
		};
		function requestHostTimeout(callback, ms) {
		  taskTimeoutID = localSetTimeout(function () {
		    callback(exports.unstable_now());
		  }, ms);
		}
		exports.unstable_IdlePriority = 5;
		exports.unstable_ImmediatePriority = 1;
		exports.unstable_LowPriority = 4;
		exports.unstable_NormalPriority = 3;
		exports.unstable_Profiling = null;
		exports.unstable_UserBlockingPriority = 2;
		exports.unstable_cancelCallback = function (task) {
		  task.callback = null;
		};
		exports.unstable_forceFrameRate = function (fps) {
		  0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
		};
		exports.unstable_getCurrentPriorityLevel = function () {
		  return currentPriorityLevel;
		};
		exports.unstable_next = function (eventHandler) {
		  switch (currentPriorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		      var priorityLevel = 3;
		      break;
		    default:
		      priorityLevel = currentPriorityLevel;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_requestPaint = function () {
		  needsPaint = true;
		};
		exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		  switch (priorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		    case 4:
		    case 5:
		      break;
		    default:
		      priorityLevel = 3;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
		  var currentTime = exports.unstable_now();
		  "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
		  switch (priorityLevel) {
		    case 1:
		      var timeout = -1;
		      break;
		    case 2:
		      timeout = 250;
		      break;
		    case 5:
		      timeout = 1073741823;
		      break;
		    case 4:
		      timeout = 1e4;
		      break;
		    default:
		      timeout = 5e3;
		  }
		  timeout = options + timeout;
		  priorityLevel = {
		    id: taskIdCounter++,
		    callback: callback,
		    priorityLevel: priorityLevel,
		    startTime: options,
		    expirationTime: timeout,
		    sortIndex: -1
		  };
		  options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
		  return priorityLevel;
		};
		exports.unstable_shouldYield = shouldYieldToHost;
		exports.unstable_wrapCallback = function (callback) {
		  var parentPriorityLevel = currentPriorityLevel;
		  return function () {
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = parentPriorityLevel;
		    try {
		      return callback.apply(this, arguments);
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		}; 
	} (scheduler_production));
	return scheduler_production;
}

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler.exports;
	hasRequiredScheduler = 1;

	{
	  scheduler.exports = requireScheduler_production();
	}
	return scheduler.exports;
}

/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactDomClient_production;

function requireReactDomClient_production () {
	if (hasRequiredReactDomClient_production) return reactDomClient_production;
	hasRequiredReactDomClient_production = 1;
var Scheduler=requireScheduler(),React=requireReact(),ReactDOM=requireReactDom();function formatProdErrorMessage(code){var url="https://react.dev/errors/"+code;if(1<arguments.length){url+="?args[]="+encodeURIComponent(arguments[1]);for(var i=2;i<arguments.length;i++)url+="&args[]="+encodeURIComponent(arguments[i]);}return "Minified React error #"+code+"; visit "+url+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";}function isValidContainer(node){return !(!node||1!==node.nodeType&&9!==node.nodeType&&11!==node.nodeType);}function getNearestMountedFiber(fiber){var node=fiber,nearestMounted=fiber;if(fiber.alternate)for(;node.return;)node=node.return;else {fiber=node;do node=fiber,0!==(node.flags&4098)&&(nearestMounted=node.return),fiber=node.return;while(fiber);}return 3===node.tag?nearestMounted:null;}function getSuspenseInstanceFromFiber(fiber){if(13===fiber.tag){var suspenseState=fiber.memoizedState;null===suspenseState&&(fiber=fiber.alternate,null!==fiber&&(suspenseState=fiber.memoizedState));if(null!==suspenseState)return suspenseState.dehydrated;}return null;}function getActivityInstanceFromFiber(fiber){if(31===fiber.tag){var activityState=fiber.memoizedState;null===activityState&&(fiber=fiber.alternate,null!==fiber&&(activityState=fiber.memoizedState));if(null!==activityState)return activityState.dehydrated;}return null;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber)throw Error(formatProdErrorMessage(188));}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){alternate=getNearestMountedFiber(fiber);if(null===alternate)throw Error(formatProdErrorMessage(188));return alternate!==fiber?null:fiber;}for(var a=fiber,b=alternate;;){var parentA=a.return;if(null===parentA)break;var parentB=parentA.alternate;if(null===parentB){b=parentA.return;if(null!==b){a=b;continue;}break;}if(parentA.child===parentB.child){for(parentB=parentA.child;parentB;){if(parentB===a)return assertIsMounted(parentA),fiber;if(parentB===b)return assertIsMounted(parentA),alternate;parentB=parentB.sibling;}throw Error(formatProdErrorMessage(188));}if(a.return!==b.return)a=parentA,b=parentB;else {for(var didFindChild=false,child$0=parentA.child;child$0;){if(child$0===a){didFindChild=true;a=parentA;b=parentB;break;}if(child$0===b){didFindChild=true;b=parentA;a=parentB;break;}child$0=child$0.sibling;}if(!didFindChild){for(child$0=parentB.child;child$0;){if(child$0===a){didFindChild=true;a=parentB;b=parentA;break;}if(child$0===b){didFindChild=true;b=parentB;a=parentA;break;}child$0=child$0.sibling;}if(!didFindChild)throw Error(formatProdErrorMessage(189));}}if(a.alternate!==b)throw Error(formatProdErrorMessage(190));}if(3!==a.tag)throw Error(formatProdErrorMessage(188));return a.stateNode.current===a?fiber:alternate;}function findCurrentHostFiberImpl(node){var tag=node.tag;if(5===tag||26===tag||27===tag||6===tag)return node;for(node=node.child;null!==node;){tag=findCurrentHostFiberImpl(node);if(null!==tag)return tag;node=node.sibling;}return null;}var assign=Object.assign,REACT_LEGACY_ELEMENT_TYPE=Symbol.for("react.element"),REACT_ELEMENT_TYPE=Symbol.for("react.transitional.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_CONSUMER_TYPE=Symbol.for("react.consumer"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy");var REACT_ACTIVITY_TYPE=Symbol.for("react.activity");var REACT_MEMO_CACHE_SENTINEL=Symbol.for("react.memo_cache_sentinel");var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;function getIteratorFn(maybeIterable){if(null===maybeIterable||"object"!==typeof maybeIterable)return null;maybeIterable=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable["@@iterator"];return "function"===typeof maybeIterable?maybeIterable:null;}var REACT_CLIENT_REFERENCE=Symbol.for("react.client.reference");function getComponentNameFromType(type){if(null==type)return null;if("function"===typeof type)return type.$$typeof===REACT_CLIENT_REFERENCE?null:type.displayName||type.name||null;if("string"===typeof type)return type;switch(type){case REACT_FRAGMENT_TYPE:return "Fragment";case REACT_PROFILER_TYPE:return "Profiler";case REACT_STRICT_MODE_TYPE:return "StrictMode";case REACT_SUSPENSE_TYPE:return "Suspense";case REACT_SUSPENSE_LIST_TYPE:return "SuspenseList";case REACT_ACTIVITY_TYPE:return "Activity";}if("object"===typeof type)switch(type.$$typeof){case REACT_PORTAL_TYPE:return "Portal";case REACT_CONTEXT_TYPE:return type.displayName||"Context";case REACT_CONSUMER_TYPE:return (type._context.displayName||"Context")+".Consumer";case REACT_FORWARD_REF_TYPE:var innerType=type.render;type=type.displayName;type||(type=innerType.displayName||innerType.name||"",type=""!==type?"ForwardRef("+type+")":"ForwardRef");return type;case REACT_MEMO_TYPE:return innerType=type.displayName||null,null!==innerType?innerType:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:innerType=type._payload;type=type._init;try{return getComponentNameFromType(type(innerType));}catch(x){}}return null;}var isArrayImpl=Array.isArray,ReactSharedInternals=React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ReactDOMSharedInternals=ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,sharedNotPendingObject={pending:false,data:null,method:null,action:null},valueStack=[],index=-1;function createCursor(defaultValue){return {current:defaultValue};}function pop(cursor){0>index||(cursor.current=valueStack[index],valueStack[index]=null,index--);}function push(cursor,value){index++;valueStack[index]=cursor.current;cursor.current=value;}var contextStackCursor=createCursor(null),contextFiberStackCursor=createCursor(null),rootInstanceStackCursor=createCursor(null),hostTransitionProviderCursor=createCursor(null);function pushHostContainer(fiber,nextRootInstance){push(rootInstanceStackCursor,nextRootInstance);push(contextFiberStackCursor,fiber);push(contextStackCursor,null);switch(nextRootInstance.nodeType){case 9:case 11:fiber=(fiber=nextRootInstance.documentElement)?(fiber=fiber.namespaceURI)?getOwnHostContext(fiber):0:0;break;default:if(fiber=nextRootInstance.tagName,nextRootInstance=nextRootInstance.namespaceURI)nextRootInstance=getOwnHostContext(nextRootInstance),fiber=getChildHostContextProd(nextRootInstance,fiber);else switch(fiber){case "svg":fiber=1;break;case "math":fiber=2;break;default:fiber=0;}}pop(contextStackCursor);push(contextStackCursor,fiber);}function popHostContainer(){pop(contextStackCursor);pop(contextFiberStackCursor);pop(rootInstanceStackCursor);}function pushHostContext(fiber){null!==fiber.memoizedState&&push(hostTransitionProviderCursor,fiber);var context=contextStackCursor.current;var JSCompiler_inline_result=getChildHostContextProd(context,fiber.type);context!==JSCompiler_inline_result&&(push(contextFiberStackCursor,fiber),push(contextStackCursor,JSCompiler_inline_result));}function popHostContext(fiber){contextFiberStackCursor.current===fiber&&(pop(contextStackCursor),pop(contextFiberStackCursor));hostTransitionProviderCursor.current===fiber&&(pop(hostTransitionProviderCursor),HostTransitionContext._currentValue=sharedNotPendingObject);}var prefix,suffix;function describeBuiltInComponentFrame(name){if(void 0===prefix)try{throw Error();}catch(x){var match=x.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||"";suffix=-1<x.stack.indexOf("\n    at")?" (<anonymous>)":-1<x.stack.indexOf("@")?"@unknown:0:0":"";}return "\n"+prefix+name+suffix;}var reentry=false;function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return "";reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var RunInRootFrame={DetermineComponentFrameRoot:function(){try{if(construct){var Fake=function(){throw Error();};Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error();}});if("object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(Fake,[]);}catch(x){var control=x;}Reflect.construct(fn,[],Fake);}else {try{Fake.call();}catch(x$1){control=x$1;}fn.call(Fake.prototype);}}else {try{throw Error();}catch(x$2){control=x$2;}(Fake=fn())&&"function"===typeof Fake.catch&&Fake.catch(function(){});}}catch(sample){if(sample&&control&&"string"===typeof sample.stack)return [sample.stack,control.stack];}return [null,null];}};RunInRootFrame.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var namePropDescriptor=Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot,"name");namePropDescriptor&&namePropDescriptor.configurable&&Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var _RunInRootFrame$Deter=RunInRootFrame.DetermineComponentFrameRoot(),sampleStack=_RunInRootFrame$Deter[0],controlStack=_RunInRootFrame$Deter[1];if(sampleStack&&controlStack){var sampleLines=sampleStack.split("\n"),controlLines=controlStack.split("\n");for(namePropDescriptor=RunInRootFrame=0;RunInRootFrame<sampleLines.length&&!sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");)RunInRootFrame++;for(;namePropDescriptor<controlLines.length&&!controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;if(RunInRootFrame===sampleLines.length||namePropDescriptor===controlLines.length)for(RunInRootFrame=sampleLines.length-1,namePropDescriptor=controlLines.length-1;1<=RunInRootFrame&&0<=namePropDescriptor&&sampleLines[RunInRootFrame]!==controlLines[namePropDescriptor];)namePropDescriptor--;for(;1<=RunInRootFrame&&0<=namePropDescriptor;RunInRootFrame--,namePropDescriptor--)if(sampleLines[RunInRootFrame]!==controlLines[namePropDescriptor]){if(1!==RunInRootFrame||1!==namePropDescriptor){do if(RunInRootFrame--,namePropDescriptor--,0>namePropDescriptor||sampleLines[RunInRootFrame]!==controlLines[namePropDescriptor]){var frame="\n"+sampleLines[RunInRootFrame].replace(" at new "," at ");fn.displayName&&frame.includes("<anonymous>")&&(frame=frame.replace("<anonymous>",fn.displayName));return frame;}while(1<=RunInRootFrame&&0<=namePropDescriptor);}break;}}}finally{reentry=false,Error.prepareStackTrace=previousPrepareStackTrace;}return (previousPrepareStackTrace=fn?fn.displayName||fn.name:"")?describeBuiltInComponentFrame(previousPrepareStackTrace):"";}function describeFiber(fiber,childFiber){switch(fiber.tag){case 26:case 27:case 5:return describeBuiltInComponentFrame(fiber.type);case 16:return describeBuiltInComponentFrame("Lazy");case 13:return fiber.child!==childFiber&&null!==childFiber?describeBuiltInComponentFrame("Suspense Fallback"):describeBuiltInComponentFrame("Suspense");case 19:return describeBuiltInComponentFrame("SuspenseList");case 0:case 15:return describeNativeComponentFrame(fiber.type,false);case 11:return describeNativeComponentFrame(fiber.type.render,false);case 1:return describeNativeComponentFrame(fiber.type,true);case 31:return describeBuiltInComponentFrame("Activity");default:return "";}}function getStackByFiberInDevAndProd(workInProgress){try{var info="",previous=null;do info+=describeFiber(workInProgress,previous),previous=workInProgress,workInProgress=workInProgress.return;while(workInProgress);return info;}catch(x){return "\nError generating stack: "+x.message+"\n"+x.stack;}}var hasOwnProperty=Object.prototype.hasOwnProperty,scheduleCallback$3=Scheduler.unstable_scheduleCallback,cancelCallback$1=Scheduler.unstable_cancelCallback,shouldYield=Scheduler.unstable_shouldYield,requestPaint=Scheduler.unstable_requestPaint,now=Scheduler.unstable_now,getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel,ImmediatePriority=Scheduler.unstable_ImmediatePriority,UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,NormalPriority$1=Scheduler.unstable_NormalPriority,LowPriority=Scheduler.unstable_LowPriority,IdlePriority=Scheduler.unstable_IdlePriority,log$1=Scheduler.log,unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue,rendererID=null,injectedHook=null;function setIsStrictModeForDevtools(newIsStrictMode){"function"===typeof log$1&&unstable_setDisableYieldValue(newIsStrictMode);if(injectedHook&&"function"===typeof injectedHook.setStrictMode)try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){}}var clz32=Math.clz32?Math.clz32:clz32Fallback,log=Math.log,LN2=Math.LN2;function clz32Fallback(x){x>>>=0;return 0===x?32:31-(log(x)/LN2|0)|0;}var nextTransitionUpdateLane=256,nextTransitionDeferredLane=262144,nextRetryLane=4194304;function getHighestPriorityLanes(lanes){var pendingSyncLanes=lanes&42;if(0!==pendingSyncLanes)return pendingSyncLanes;switch(lanes&-lanes){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return lanes&261888;case 262144:case 524288:case 1048576:case 2097152:return lanes&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return lanes&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return lanes;}}function getNextLanes(root,wipLanes,rootHasPendingCommit){var pendingLanes=root.pendingLanes;if(0===pendingLanes)return 0;var nextLanes=0,suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes;root=root.warmLanes;var nonIdlePendingLanes=pendingLanes&134217727;0!==nonIdlePendingLanes?(pendingLanes=nonIdlePendingLanes&~suspendedLanes,0!==pendingLanes?nextLanes=getHighestPriorityLanes(pendingLanes):(pingedLanes&=nonIdlePendingLanes,0!==pingedLanes?nextLanes=getHighestPriorityLanes(pingedLanes):rootHasPendingCommit||(rootHasPendingCommit=nonIdlePendingLanes&~root,0!==rootHasPendingCommit&&(nextLanes=getHighestPriorityLanes(rootHasPendingCommit))))):(nonIdlePendingLanes=pendingLanes&~suspendedLanes,0!==nonIdlePendingLanes?nextLanes=getHighestPriorityLanes(nonIdlePendingLanes):0!==pingedLanes?nextLanes=getHighestPriorityLanes(pingedLanes):rootHasPendingCommit||(rootHasPendingCommit=pendingLanes&~root,0!==rootHasPendingCommit&&(nextLanes=getHighestPriorityLanes(rootHasPendingCommit))));return 0===nextLanes?0:0!==wipLanes&&wipLanes!==nextLanes&&0===(wipLanes&suspendedLanes)&&(suspendedLanes=nextLanes&-nextLanes,rootHasPendingCommit=wipLanes&-wipLanes,suspendedLanes>=rootHasPendingCommit||32===suspendedLanes&&0!==(rootHasPendingCommit&4194048))?wipLanes:nextLanes;}function checkIfRootIsPrerendering(root,renderLanes){return 0===(root.pendingLanes&~(root.suspendedLanes&~root.pingedLanes)&renderLanes);}function computeExpirationTime(lane,currentTime){switch(lane){case 1:case 2:case 4:case 8:case 64:return currentTime+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return currentTime+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return  -1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return  -1;default:return  -1;}}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;0===(nextRetryLane&62914560)&&(nextRetryLane=4194304);return lane;}function createLaneMap(initial){for(var laneMap=[],i=0;31>i;i++)laneMap.push(initial);return laneMap;}function markRootUpdated$1(root,updateLane){root.pendingLanes|=updateLane;268435456!==updateLane&&(root.suspendedLanes=0,root.pingedLanes=0,root.warmLanes=0);}function markRootFinished(root,finishedLanes,remainingLanes,spawnedLane,updatedLanes,suspendedRetryLanes){var previouslyPendingLanes=root.pendingLanes;root.pendingLanes=remainingLanes;root.suspendedLanes=0;root.pingedLanes=0;root.warmLanes=0;root.expiredLanes&=remainingLanes;root.entangledLanes&=remainingLanes;root.errorRecoveryDisabledLanes&=remainingLanes;root.shellSuspendCounter=0;var entanglements=root.entanglements,expirationTimes=root.expirationTimes,hiddenUpdates=root.hiddenUpdates;for(remainingLanes=previouslyPendingLanes&~remainingLanes;0<remainingLanes;){var index$7=31-clz32(remainingLanes),lane=1<<index$7;entanglements[index$7]=0;expirationTimes[index$7]=-1;var hiddenUpdatesForLane=hiddenUpdates[index$7];if(null!==hiddenUpdatesForLane)for(hiddenUpdates[index$7]=null,index$7=0;index$7<hiddenUpdatesForLane.length;index$7++){var update=hiddenUpdatesForLane[index$7];null!==update&&(update.lane&=-536870913);}remainingLanes&=~lane;}0!==spawnedLane&&markSpawnedDeferredLane(root,spawnedLane,0);0!==suspendedRetryLanes&&0===updatedLanes&&0!==root.tag&&(root.suspendedLanes|=suspendedRetryLanes&~(previouslyPendingLanes&~finishedLanes));}function markSpawnedDeferredLane(root,spawnedLane,entangledLanes){root.pendingLanes|=spawnedLane;root.suspendedLanes&=~spawnedLane;var spawnedLaneIndex=31-clz32(spawnedLane);root.entangledLanes|=spawnedLane;root.entanglements[spawnedLaneIndex]=root.entanglements[spawnedLaneIndex]|1073741824|entangledLanes&261930;}function markRootEntangled(root,entangledLanes){var rootEntangledLanes=root.entangledLanes|=entangledLanes;for(root=root.entanglements;rootEntangledLanes;){var index$8=31-clz32(rootEntangledLanes),lane=1<<index$8;lane&entangledLanes|root[index$8]&entangledLanes&&(root[index$8]|=entangledLanes);rootEntangledLanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=renderLanes&-renderLanes;renderLane=0!==(renderLane&42)?1:getBumpedLaneForHydrationByLane(renderLane);return 0!==(renderLane&(root.suspendedLanes|renderLanes))?0:renderLane;}function getBumpedLaneForHydrationByLane(lane){switch(lane){case 2:lane=1;break;case 8:lane=4;break;case 32:lane=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:lane=128;break;case 268435456:lane=134217728;break;default:lane=0;}return lane;}function lanesToEventPriority(lanes){lanes&=-lanes;return 2<lanes?8<lanes?0!==(lanes&134217727)?32:268435456:8:2;}function resolveUpdatePriority(){var updatePriority=ReactDOMSharedInternals.p;if(0!==updatePriority)return updatePriority;updatePriority=window.event;return void 0===updatePriority?32:getEventPriority(updatePriority.type);}function runWithPriority(priority,fn){var previousPriority=ReactDOMSharedInternals.p;try{return ReactDOMSharedInternals.p=priority,fn();}finally{ReactDOMSharedInternals.p=previousPriority;}}var randomKey=Math.random().toString(36).slice(2),internalInstanceKey="__reactFiber$"+randomKey,internalPropsKey="__reactProps$"+randomKey,internalContainerInstanceKey="__reactContainer$"+randomKey,internalEventHandlersKey="__reactEvents$"+randomKey,internalEventHandlerListenersKey="__reactListeners$"+randomKey,internalEventHandlesSetKey="__reactHandles$"+randomKey,internalRootNodeResourcesKey="__reactResources$"+randomKey,internalHoistableMarker="__reactMarker$"+randomKey;function detachDeletedInstance(node){delete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst)return targetInst;for(var parentNode=targetNode.parentNode;parentNode;){if(targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey]){parentNode=targetInst.alternate;if(null!==targetInst.child||null!==parentNode&&null!==parentNode.child)for(targetNode=getParentHydrationBoundary(targetNode);null!==targetNode;){if(parentNode=targetNode[internalInstanceKey])return parentNode;targetNode=getParentHydrationBoundary(targetNode);}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}function getInstanceFromNode(node){if(node=node[internalInstanceKey]||node[internalContainerInstanceKey]){var tag=node.tag;if(5===tag||6===tag||13===tag||31===tag||26===tag||27===tag||3===tag)return node;}return null;}function getNodeFromInstance(inst){var tag=inst.tag;if(5===tag||26===tag||27===tag||6===tag)return inst.stateNode;throw Error(formatProdErrorMessage(33));}function getResourcesFromRoot(root){var resources=root[internalRootNodeResourcesKey];resources||(resources=root[internalRootNodeResourcesKey]={hoistableStyles:new Map(),hoistableScripts:new Map()});return resources;}function markNodeAsHoistable(node){node[internalHoistableMarker]=true;}var allNativeEvents=new Set(),registrationNameDependencies={};function registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+"Capture",dependencies);}function registerDirectEvent(registrationName,dependencies){registrationNameDependencies[registrationName]=dependencies;for(registrationName=0;registrationName<dependencies.length;registrationName++)allNativeEvents.add(dependencies[registrationName]);}var VALID_ATTRIBUTE_NAME_REGEX=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),illegalAttributeNameCache={},validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName))return  true;if(hasOwnProperty.call(illegalAttributeNameCache,attributeName))return  false;if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))return validatedAttributeNameCache[attributeName]=true;illegalAttributeNameCache[attributeName]=true;return  false;}function setValueForAttribute(node,name,value){if(isAttributeNameSafe(name))if(null===value)node.removeAttribute(name);else {switch(typeof value){case "undefined":case "function":case "symbol":node.removeAttribute(name);return;case "boolean":var prefix$10=name.toLowerCase().slice(0,5);if("data-"!==prefix$10&&"aria-"!==prefix$10){node.removeAttribute(name);return;}}node.setAttribute(name,""+value);}}function setValueForKnownAttribute(node,name,value){if(null===value)node.removeAttribute(name);else {switch(typeof value){case "undefined":case "function":case "symbol":case "boolean":node.removeAttribute(name);return;}node.setAttribute(name,""+value);}}function setValueForNamespacedAttribute(node,namespace,name,value){if(null===value)node.removeAttribute(name);else {switch(typeof value){case "undefined":case "function":case "symbol":case "boolean":node.removeAttribute(name);return;}node.setAttributeNS(namespace,name,""+value);}}function getToStringValue(value){switch(typeof value){case "bigint":case "boolean":case "number":case "string":case "undefined":return value;case "object":return value;default:return "";}}function isCheckable(elem){var type=elem.type;return (elem=elem.nodeName)&&"input"===elem.toLowerCase()&&("checkbox"===type||"radio"===type);}function trackValueOnNode(node,valueField,currentValue){var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);if(!node.hasOwnProperty(valueField)&&"undefined"!==typeof descriptor&&"function"===typeof descriptor.get&&"function"===typeof descriptor.set){var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){currentValue=""+value;set.call(this,value);}});Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});return {getValue:function(){return currentValue;},setValue:function(value){currentValue=""+value;},stopTracking:function(){node._valueTracker=null;delete node[valueField];}};}}function track(node){if(!node._valueTracker){var valueField=isCheckable(node)?"checked":"value";node._valueTracker=trackValueOnNode(node,valueField,""+node[valueField]);}}function updateValueIfChanged(node){if(!node)return  false;var tracker=node._valueTracker;if(!tracker)return  true;var lastValue=tracker.getValue();var value="";node&&(value=isCheckable(node)?node.checked?"true":"false":node.value);node=value;return node!==lastValue?(tracker.setValue(node),true):false;}function getActiveElement(doc){doc=doc||("undefined"!==typeof document?document:void 0);if("undefined"===typeof doc)return null;try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var escapeSelectorAttributeValueInsideDoubleQuotesRegex=/[\n"\\]/g;function escapeSelectorAttributeValueInsideDoubleQuotes(value){return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex,function(ch){return "\\"+ch.charCodeAt(0).toString(16)+" ";});}function updateInput(element,value,defaultValue,lastDefaultValue,checked,defaultChecked,type,name){element.name="";null!=type&&"function"!==typeof type&&"symbol"!==typeof type&&"boolean"!==typeof type?element.type=type:element.removeAttribute("type");if(null!=value){if("number"===type){if(0===value&&""===element.value||element.value!=value)element.value=""+getToStringValue(value);}else element.value!==""+getToStringValue(value)&&(element.value=""+getToStringValue(value));}else "submit"!==type&&"reset"!==type||element.removeAttribute("value");null!=value?setDefaultValue(element,type,getToStringValue(value)):null!=defaultValue?setDefaultValue(element,type,getToStringValue(defaultValue)):null!=lastDefaultValue&&element.removeAttribute("value");null==checked&&null!=defaultChecked&&(element.defaultChecked=!!defaultChecked);null!=checked&&(element.checked=checked&&"function"!==typeof checked&&"symbol"!==typeof checked);null!=name&&"function"!==typeof name&&"symbol"!==typeof name&&"boolean"!==typeof name?element.name=""+getToStringValue(name):element.removeAttribute("name");}function initInput(element,value,defaultValue,checked,defaultChecked,type,name,isHydrating){null!=type&&"function"!==typeof type&&"symbol"!==typeof type&&"boolean"!==typeof type&&(element.type=type);if(null!=value||null!=defaultValue){if(!("submit"!==type&&"reset"!==type||void 0!==value&&null!==value)){track(element);return;}defaultValue=null!=defaultValue?""+getToStringValue(defaultValue):"";value=null!=value?""+getToStringValue(value):defaultValue;isHydrating||value===element.value||(element.value=value);element.defaultValue=value;}checked=null!=checked?checked:defaultChecked;checked="function"!==typeof checked&&"symbol"!==typeof checked&&!!checked;element.checked=isHydrating?element.checked:!!checked;element.defaultChecked=!!checked;null!=name&&"function"!==typeof name&&"symbol"!==typeof name&&"boolean"!==typeof name&&(element.name=name);track(element);}function setDefaultValue(node,type,value){"number"===type&&getActiveElement(node.ownerDocument)===node||node.defaultValue===""+value||(node.defaultValue=""+value);}function updateOptions(node,multiple,propValue,setDefaultSelected){node=node.options;if(multiple){multiple={};for(var i=0;i<propValue.length;i++)multiple["$"+propValue[i]]=true;for(propValue=0;propValue<node.length;propValue++)i=multiple.hasOwnProperty("$"+node[propValue].value),node[propValue].selected!==i&&(node[propValue].selected=i),i&&setDefaultSelected&&(node[propValue].defaultSelected=true);}else {propValue=""+getToStringValue(propValue);multiple=null;for(i=0;i<node.length;i++){if(node[i].value===propValue){node[i].selected=true;setDefaultSelected&&(node[i].defaultSelected=true);return;}null!==multiple||node[i].disabled||(multiple=node[i]);}null!==multiple&&(multiple.selected=true);}}function updateTextarea(element,value,defaultValue){if(null!=value&&(value=""+getToStringValue(value),value!==element.value&&(element.value=value),null==defaultValue)){element.defaultValue!==value&&(element.defaultValue=value);return;}element.defaultValue=null!=defaultValue?""+getToStringValue(defaultValue):"";}function initTextarea(element,value,defaultValue,children){if(null==value){if(null!=children){if(null!=defaultValue)throw Error(formatProdErrorMessage(92));if(isArrayImpl(children)){if(1<children.length)throw Error(formatProdErrorMessage(93));children=children[0];}defaultValue=children;}null==defaultValue&&(defaultValue="");value=defaultValue;}defaultValue=getToStringValue(value);element.defaultValue=defaultValue;children=element.textContent;children===defaultValue&&""!==children&&null!==children&&(element.value=children);track(element);}function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&3===firstChild.nodeType){firstChild.nodeValue=text;return;}}node.textContent=text;}var unitlessNumbers=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function setValueForStyle(style,styleName,value){var isCustomProperty=0===styleName.indexOf("--");null==value||"boolean"===typeof value||""===value?isCustomProperty?style.setProperty(styleName,""):"float"===styleName?style.cssFloat="":style[styleName]="":isCustomProperty?style.setProperty(styleName,value):"number"!==typeof value||0===value||unitlessNumbers.has(styleName)?"float"===styleName?style.cssFloat=value:style[styleName]=(""+value).trim():style[styleName]=value+"px";}function setValueForStyles(node,styles,prevStyles){if(null!=styles&&"object"!==typeof styles)throw Error(formatProdErrorMessage(62));node=node.style;if(null!=prevStyles){for(var styleName in prevStyles)!prevStyles.hasOwnProperty(styleName)||null!=styles&&styles.hasOwnProperty(styleName)||(0===styleName.indexOf("--")?node.setProperty(styleName,""):"float"===styleName?node.cssFloat="":node[styleName]="");for(var styleName$16 in styles)styleName=styles[styleName$16],styles.hasOwnProperty(styleName$16)&&prevStyles[styleName$16]!==styleName&&setValueForStyle(node,styleName$16,styleName);}else for(var styleName$17 in styles)styles.hasOwnProperty(styleName$17)&&setValueForStyle(node,styleName$17,styles[styleName$17]);}function isCustomElement(tagName){if(-1===tagName.indexOf("-"))return  false;switch(tagName){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return  false;default:return  true;}}var aliases=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function sanitizeURL(url){return isJavaScriptProtocol.test(""+url)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":url;}function noop$1(){}var currentReplayingEvent=null;function getEventTarget(nativeEvent){nativeEvent=nativeEvent.target||nativeEvent.srcElement||window;nativeEvent.correspondingUseElement&&(nativeEvent=nativeEvent.correspondingUseElement);return 3===nativeEvent.nodeType?nativeEvent.parentNode:nativeEvent;}var restoreTarget=null,restoreQueue=null;function restoreStateOfTarget(target){var internalInstance=getInstanceFromNode(target);if(internalInstance&&(target=internalInstance.stateNode)){var props=target[internalPropsKey]||null;a:switch(target=internalInstance.stateNode,internalInstance.type){case "input":updateInput(target,props.value,props.defaultValue,props.defaultValue,props.checked,props.defaultChecked,props.type,props.name);internalInstance=props.name;if("radio"===props.type&&null!=internalInstance){for(props=target;props.parentNode;)props=props.parentNode;props=props.querySelectorAll('input[name="'+escapeSelectorAttributeValueInsideDoubleQuotes(""+internalInstance)+'"][type="radio"]');for(internalInstance=0;internalInstance<props.length;internalInstance++){var otherNode=props[internalInstance];if(otherNode!==target&&otherNode.form===target.form){var otherProps=otherNode[internalPropsKey]||null;if(!otherProps)throw Error(formatProdErrorMessage(90));updateInput(otherNode,otherProps.value,otherProps.defaultValue,otherProps.defaultValue,otherProps.checked,otherProps.defaultChecked,otherProps.type,otherProps.name);}}for(internalInstance=0;internalInstance<props.length;internalInstance++)otherNode=props[internalInstance],otherNode.form===target.form&&updateValueIfChanged(otherNode);}break a;case "textarea":updateTextarea(target,props.value,props.defaultValue);break a;case "select":internalInstance=props.value,null!=internalInstance&&updateOptions(target,!!props.multiple,internalInstance,false);}}}var isInsideEventHandler=false;function batchedUpdates$1(fn,a,b){if(isInsideEventHandler)return fn(a,b);isInsideEventHandler=true;try{var JSCompiler_inline_result=fn(a);return JSCompiler_inline_result;}finally{if(isInsideEventHandler=false,null!==restoreTarget||null!==restoreQueue)if(flushSyncWork$1(),restoreTarget&&(a=restoreTarget,fn=restoreQueue,restoreQueue=restoreTarget=null,restoreStateOfTarget(a),fn))for(a=0;a<fn.length;a++)restoreStateOfTarget(fn[a]);}}function getListener(inst,registrationName){var stateNode=inst.stateNode;if(null===stateNode)return null;var props=stateNode[internalPropsKey]||null;if(null===props)return null;stateNode=props[registrationName];a:switch(registrationName){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(props=!props.disabled)||(inst=inst.type,props=!("button"===inst||"input"===inst||"select"===inst||"textarea"===inst));inst=!props;break a;default:inst=false;}if(inst)return null;if(stateNode&&"function"!==typeof stateNode)throw Error(formatProdErrorMessage(231,registrationName,typeof stateNode));return stateNode;}var canUseDOM=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),passiveBrowserEventsSupported=false;if(canUseDOM)try{var options={};Object.defineProperty(options,"passive",{get:function(){passiveBrowserEventsSupported=!0;}});window.addEventListener("test",options,options);window.removeEventListener("test",options,options);}catch(e){passiveBrowserEventsSupported=false;}var root=null,startText=null,fallbackText=null;function getData(){if(fallbackText)return fallbackText;var start,startValue=startText,startLength=startValue.length,end,endValue="value"in root?root.value:root.textContent,endLength=endValue.length;for(start=0;start<startLength&&startValue[start]===endValue[start];start++);var minEnd=startLength-start;for(end=1;end<=minEnd&&startValue[startLength-end]===endValue[endLength-end];end++);return fallbackText=endValue.slice(start,1<end?1-end:void 0);}function getEventCharCode(nativeEvent){var keyCode=nativeEvent.keyCode;"charCode"in nativeEvent?(nativeEvent=nativeEvent.charCode,0===nativeEvent&&13===keyCode&&(nativeEvent=13)):nativeEvent=keyCode;10===nativeEvent&&(nativeEvent=13);return 32<=nativeEvent||13===nativeEvent?nativeEvent:0;}function functionThatReturnsTrue(){return  true;}function functionThatReturnsFalse(){return  false;}function createSyntheticEvent(Interface){function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var propName in Interface)Interface.hasOwnProperty(propName)&&(reactName=Interface[propName],this[propName]=reactName?reactName(nativeEvent):nativeEvent[propName]);this.isDefaultPrevented=(null!=nativeEvent.defaultPrevented?nativeEvent.defaultPrevented:false===nativeEvent.returnValue)?functionThatReturnsTrue:functionThatReturnsFalse;this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;event&&(event.preventDefault?event.preventDefault():"unknown"!==typeof event.returnValue&&(event.returnValue=false),this.isDefaultPrevented=functionThatReturnsTrue);},stopPropagation:function(){var event=this.nativeEvent;event&&(event.stopPropagation?event.stopPropagation():"unknown"!==typeof event.cancelBubble&&(event.cancelBubble=true),this.isPropagationStopped=functionThatReturnsTrue);},persist:function(){},isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0},SyntheticEvent=createSyntheticEvent(EventInterface),UIEventInterface=assign({},EventInterface,{view:0,detail:0}),SyntheticUIEvent=createSyntheticEvent(UIEventInterface),lastMovementX,lastMovementY,lastMouseEvent,MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){return void 0===event.relatedTarget?event.fromElement===event.srcElement?event.toElement:event.fromElement:event.relatedTarget;},movementX:function(event){if("movementX"in event)return event.movementX;event!==lastMouseEvent&&(lastMouseEvent&&"mousemove"===event.type?(lastMovementX=event.screenX-lastMouseEvent.screenX,lastMovementY=event.screenY-lastMouseEvent.screenY):lastMovementY=lastMovementX=0,lastMouseEvent=event);return lastMovementX;},movementY:function(event){return "movementY"in event?event.movementY:lastMovementY;}}),SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface),DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0}),SyntheticDragEvent=createSyntheticEvent(DragEventInterface),FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0}),SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface),AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0}),SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface),ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return "clipboardData"in event?event.clipboardData:window.clipboardData;}}),SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface),CompositionEventInterface=assign({},EventInterface,{data:0}),SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface),normalizeKey={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},translateToKey={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},modifierKeyToProp={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function modifierStateGetter(keyArg){var nativeEvent=this.nativeEvent;return nativeEvent.getModifierState?nativeEvent.getModifierState(keyArg):(keyArg=modifierKeyToProp[keyArg])?!!nativeEvent[keyArg]:false;}function getEventModifierState(){return modifierStateGetter;}var KeyboardEventInterface=assign({},UIEventInterface,{key:function(nativeEvent){if(nativeEvent.key){var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if("Unidentified"!==key)return key;}return "keypress"===nativeEvent.type?(nativeEvent=getEventCharCode(nativeEvent),13===nativeEvent?"Enter":String.fromCharCode(nativeEvent)):"keydown"===nativeEvent.type||"keyup"===nativeEvent.type?translateToKey[nativeEvent.keyCode]||"Unidentified":"";},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,charCode:function(event){return "keypress"===event.type?getEventCharCode(event):0;},keyCode:function(event){return "keydown"===event.type||"keyup"===event.type?event.keyCode:0;},which:function(event){return "keypress"===event.type?getEventCharCode(event):"keydown"===event.type||"keyup"===event.type?event.keyCode:0;}}),SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface),PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface),TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState}),SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface),TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0}),SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface),WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return "deltaX"in event?event.deltaX:"wheelDeltaX"in event?-event.wheelDeltaX:0;},deltaY:function(event){return "deltaY"in event?event.deltaY:"wheelDeltaY"in event?-event.wheelDeltaY:"wheelDelta"in event?-event.wheelDelta:0;},deltaZ:0,deltaMode:0}),SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface),ToggleEventInterface=assign({},EventInterface,{newState:0,oldState:0}),SyntheticToggleEvent=createSyntheticEvent(ToggleEventInterface),END_KEYCODES=[9,13,27,32],canUseCompositionEvent=canUseDOM&&"CompositionEvent"in window,documentMode=null;canUseDOM&&"documentMode"in document&&(documentMode=document.documentMode);var canUseTextInputEvent=canUseDOM&&"TextEvent"in window&&!documentMode,useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&8<documentMode&&11>=documentMode),SPACEBAR_CHAR=String.fromCharCode(32),hasSpaceKeypress=false;function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case "keyup":return  -1!==END_KEYCODES.indexOf(nativeEvent.keyCode);case "keydown":return 229!==nativeEvent.keyCode;case "keypress":case "mousedown":case "focusout":return  true;default:return  false;}}function getDataFromCustomEvent(nativeEvent){nativeEvent=nativeEvent.detail;return "object"===typeof nativeEvent&&"data"in nativeEvent?nativeEvent.data:null;}var isComposing=false;function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case "compositionend":return getDataFromCustomEvent(nativeEvent);case "keypress":if(32!==nativeEvent.which)return null;hasSpaceKeypress=true;return SPACEBAR_CHAR;case "textInput":return domEventName=nativeEvent.data,domEventName===SPACEBAR_CHAR&&hasSpaceKeypress?null:domEventName;default:return null;}}function getFallbackBeforeInputChars(domEventName,nativeEvent){if(isComposing)return "compositionend"===domEventName||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)?(domEventName=getData(),fallbackText=startText=root=null,isComposing=false,domEventName):null;switch(domEventName){case "paste":return null;case "keypress":if(!(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)||nativeEvent.ctrlKey&&nativeEvent.altKey){if(nativeEvent.char&&1<nativeEvent.char.length)return nativeEvent.char;if(nativeEvent.which)return String.fromCharCode(nativeEvent.which);}return null;case "compositionend":return useFallbackCompositionData&&"ko"!==nativeEvent.locale?null:nativeEvent.data;default:return null;}}var supportedInputTypes={color:true,date:true,datetime:true,"datetime-local":true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return "input"===nodeName?!!supportedInputTypes[elem.type]:"textarea"===nodeName?true:false;}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){restoreTarget?restoreQueue?restoreQueue.push(target):restoreQueue=[target]:restoreTarget=target;inst=accumulateTwoPhaseListeners(inst,"onChange");0<inst.length&&(nativeEvent=new SyntheticEvent("onChange","change",null,nativeEvent,target),dispatchQueue.push({event:nativeEvent,listeners:inst}));}var activeElement$1=null,activeElementInst$1=null;function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode))return targetInst;}function getTargetInstForChangeEvent(domEventName,targetInst){if("change"===domEventName)return targetInst;}var isInputEventSupported=false;if(canUseDOM){var JSCompiler_inline_result$jscomp$286;if(canUseDOM){var isSupported$jscomp$inline_427="oninput"in document;if(!isSupported$jscomp$inline_427){var element$jscomp$inline_428=document.createElement("div");element$jscomp$inline_428.setAttribute("oninput","return;");isSupported$jscomp$inline_427="function"===typeof element$jscomp$inline_428.oninput;}JSCompiler_inline_result$jscomp$286=isSupported$jscomp$inline_427;}else JSCompiler_inline_result$jscomp$286=false;isInputEventSupported=JSCompiler_inline_result$jscomp$286&&(!document.documentMode||9<document.documentMode);}function stopWatchingForValueChange(){activeElement$1&&(activeElement$1.detachEvent("onpropertychange",handlePropertyChange),activeElementInst$1=activeElement$1=null);}function handlePropertyChange(nativeEvent){if("value"===nativeEvent.propertyName&&getInstIfValueChanged(activeElementInst$1)){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst$1,nativeEvent,getEventTarget(nativeEvent));batchedUpdates$1(runEventInBatch,dispatchQueue);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){"focusin"===domEventName?(stopWatchingForValueChange(),activeElement$1=target,activeElementInst$1=targetInst,activeElement$1.attachEvent("onpropertychange",handlePropertyChange)):"focusout"===domEventName&&stopWatchingForValueChange();}function getTargetInstForInputEventPolyfill(domEventName){if("selectionchange"===domEventName||"keyup"===domEventName||"keydown"===domEventName)return getInstIfValueChanged(activeElementInst$1);}function getTargetInstForClickEvent(domEventName,targetInst){if("click"===domEventName)return getInstIfValueChanged(targetInst);}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if("input"===domEventName||"change"===domEventName)return getInstIfValueChanged(targetInst);}function is(x,y){return x===y&&(0!==x||1/x===1/y)||x!==x&&y!==y;}var objectIs="function"===typeof Object.is?Object.is:is;function shallowEqual(objA,objB){if(objectIs(objA,objB))return  true;if("object"!==typeof objA||null===objA||"object"!==typeof objB||null===objB)return  false;var keysA=Object.keys(objA),keysB=Object.keys(objB);if(keysA.length!==keysB.length)return  false;for(keysB=0;keysB<keysA.length;keysB++){var currentKey=keysA[keysB];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey]))return  false;}return  true;}function getLeafNode(node){for(;node&&node.firstChild;)node=node.firstChild;return node;}function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);root=0;for(var nodeEnd;node;){if(3===node.nodeType){nodeEnd=root+node.textContent.length;if(root<=offset&&nodeEnd>=offset)return {node:node,offset:offset-root};root=nodeEnd;}a:{for(;node;){if(node.nextSibling){node=node.nextSibling;break a;}node=node.parentNode;}node=void 0;}node=getLeafNode(node);}}function containsNode(outerNode,innerNode){return outerNode&&innerNode?outerNode===innerNode?true:outerNode&&3===outerNode.nodeType?false:innerNode&&3===innerNode.nodeType?containsNode(outerNode,innerNode.parentNode):"contains"in outerNode?outerNode.contains(innerNode):outerNode.compareDocumentPosition?!!(outerNode.compareDocumentPosition(innerNode)&16):false:false;}function getActiveElementDeep(containerInfo){containerInfo=null!=containerInfo&&null!=containerInfo.ownerDocument&&null!=containerInfo.ownerDocument.defaultView?containerInfo.ownerDocument.defaultView:window;for(var element=getActiveElement(containerInfo.document);element instanceof containerInfo.HTMLIFrameElement;){try{var JSCompiler_inline_result="string"===typeof element.contentWindow.location.href;}catch(err){JSCompiler_inline_result=false;}if(JSCompiler_inline_result)containerInfo=element.contentWindow;else break;element=getActiveElement(containerInfo.document);}return element;}function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&("input"===nodeName&&("text"===elem.type||"search"===elem.type||"tel"===elem.type||"url"===elem.type||"password"===elem.type)||"textarea"===nodeName||"true"===elem.contentEditable);}var skipSelectionChangeEvent=canUseDOM&&"documentMode"in document&&11>=document.documentMode,activeElement=null,activeElementInst=null,lastSelection=null,mouseDown=false;function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:9===nativeEventTarget.nodeType?nativeEventTarget:nativeEventTarget.ownerDocument;mouseDown||null==activeElement||activeElement!==getActiveElement(doc)||(doc=activeElement,"selectionStart"in doc&&hasSelectionCapabilities(doc)?doc={start:doc.selectionStart,end:doc.selectionEnd}:(doc=(doc.ownerDocument&&doc.ownerDocument.defaultView||window).getSelection(),doc={anchorNode:doc.anchorNode,anchorOffset:doc.anchorOffset,focusNode:doc.focusNode,focusOffset:doc.focusOffset}),lastSelection&&shallowEqual(lastSelection,doc)||(lastSelection=doc,doc=accumulateTwoPhaseListeners(activeElementInst,"onSelect"),0<doc.length&&(nativeEvent=new SyntheticEvent("onSelect","select",null,nativeEvent,nativeEventTarget),dispatchQueue.push({event:nativeEvent,listeners:doc}),nativeEvent.target=activeElement)));}function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes["Webkit"+styleProp]="webkit"+eventName;prefixes["Moz"+styleProp]="moz"+eventName;return prefixes;}var vendorPrefixes={animationend:makePrefixMap("Animation","AnimationEnd"),animationiteration:makePrefixMap("Animation","AnimationIteration"),animationstart:makePrefixMap("Animation","AnimationStart"),transitionrun:makePrefixMap("Transition","TransitionRun"),transitionstart:makePrefixMap("Transition","TransitionStart"),transitioncancel:makePrefixMap("Transition","TransitionCancel"),transitionend:makePrefixMap("Transition","TransitionEnd")},prefixedEventNames={},style={};canUseDOM&&(style=document.createElement("div").style,"AnimationEvent"in window||(delete vendorPrefixes.animationend.animation,delete vendorPrefixes.animationiteration.animation,delete vendorPrefixes.animationstart.animation),"TransitionEvent"in window||delete vendorPrefixes.transitionend.transition);function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName])return prefixedEventNames[eventName];if(!vendorPrefixes[eventName])return eventName;var prefixMap=vendorPrefixes[eventName],styleProp;for(styleProp in prefixMap)if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style)return prefixedEventNames[eventName]=prefixMap[styleProp];return eventName;}var ANIMATION_END=getVendorPrefixedEventName("animationend"),ANIMATION_ITERATION=getVendorPrefixedEventName("animationiteration"),ANIMATION_START=getVendorPrefixedEventName("animationstart"),TRANSITION_RUN=getVendorPrefixedEventName("transitionrun"),TRANSITION_START=getVendorPrefixedEventName("transitionstart"),TRANSITION_CANCEL=getVendorPrefixedEventName("transitioncancel"),TRANSITION_END=getVendorPrefixedEventName("transitionend"),topLevelEventsToReactNames=new Map(),simpleEventPluginEvents="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");simpleEventPluginEvents.push("scrollEnd");function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}var reportGlobalError="function"===typeof reportError?reportError:function(error){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var event=new window.ErrorEvent("error",{bubbles:true,cancelable:true,message:"object"===typeof error&&null!==error&&"string"===typeof error.message?String(error.message):String(error),error:error});if(!window.dispatchEvent(event))return;}else if("object"===typeof process&&"function"===typeof process.emit){process.emit("uncaughtException",error);return;}console.error(error);},concurrentQueues=[],concurrentQueuesIndex=0,concurrentlyUpdatedLanes=0;function finishQueueingConcurrentUpdates(){for(var endIndex=concurrentQueuesIndex,i=concurrentlyUpdatedLanes=concurrentQueuesIndex=0;i<endIndex;){var fiber=concurrentQueues[i];concurrentQueues[i++]=null;var queue=concurrentQueues[i];concurrentQueues[i++]=null;var update=concurrentQueues[i];concurrentQueues[i++]=null;var lane=concurrentQueues[i];concurrentQueues[i++]=null;if(null!==queue&&null!==update){var pending=queue.pending;null===pending?update.next=update:(update.next=pending.next,pending.next=update);queue.pending=update;}0!==lane&&markUpdateLaneFromFiberToRoot(fiber,update,lane);}}function enqueueUpdate$1(fiber,queue,update,lane){concurrentQueues[concurrentQueuesIndex++]=fiber;concurrentQueues[concurrentQueuesIndex++]=queue;concurrentQueues[concurrentQueuesIndex++]=update;concurrentQueues[concurrentQueuesIndex++]=lane;concurrentlyUpdatedLanes|=lane;fiber.lanes|=lane;fiber=fiber.alternate;null!==fiber&&(fiber.lanes|=lane);}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){enqueueUpdate$1(fiber,queue,update,lane);return getRootForUpdatedFiber(fiber);}function enqueueConcurrentRenderForLane(fiber,lane){enqueueUpdate$1(fiber,null,null,lane);return getRootForUpdatedFiber(fiber);}function markUpdateLaneFromFiberToRoot(sourceFiber,update,lane){sourceFiber.lanes|=lane;var alternate=sourceFiber.alternate;null!==alternate&&(alternate.lanes|=lane);for(var isHidden=false,parent=sourceFiber.return;null!==parent;)parent.childLanes|=lane,alternate=parent.alternate,null!==alternate&&(alternate.childLanes|=lane),22===parent.tag&&(sourceFiber=parent.stateNode,null===sourceFiber||sourceFiber._visibility&1||(isHidden=true)),sourceFiber=parent,parent=parent.return;return 3===sourceFiber.tag?(parent=sourceFiber.stateNode,isHidden&&null!==update&&(isHidden=31-clz32(lane),sourceFiber=parent.hiddenUpdates,alternate=sourceFiber[isHidden],null===alternate?sourceFiber[isHidden]=[update]:alternate.push(update),update.lane=lane|536870912),parent):null;}function getRootForUpdatedFiber(sourceFiber){if(50<nestedUpdateCount)throw nestedUpdateCount=0,rootWithNestedUpdates=null,Error(formatProdErrorMessage(185));for(var parent=sourceFiber.return;null!==parent;)sourceFiber=parent,parent=sourceFiber.return;return 3===sourceFiber.tag?sourceFiber.stateNode:null;}var emptyContextObject={};function FiberNode(tag,pendingProps,key,mode){this.tag=tag;this.key=key;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.refCleanup=this.ref=null;this.pendingProps=pendingProps;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=mode;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;}function createFiberImplClass(tag,pendingProps,key,mode){return new FiberNode(tag,pendingProps,key,mode);}function shouldConstruct(Component){Component=Component.prototype;return !(!Component||!Component.isReactComponent);}function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;null===workInProgress?(workInProgress=createFiberImplClass(current.tag,pendingProps,current.key,current.mode),workInProgress.elementType=current.elementType,workInProgress.type=current.type,workInProgress.stateNode=current.stateNode,workInProgress.alternate=current,current.alternate=workInProgress):(workInProgress.pendingProps=pendingProps,workInProgress.type=current.type,workInProgress.flags=0,workInProgress.subtreeFlags=0,workInProgress.deletions=null);workInProgress.flags=current.flags&65011712;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;pendingProps=current.dependencies;workInProgress.dependencies=null===pendingProps?null:{lanes:pendingProps.lanes,firstContext:pendingProps.firstContext};workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;workInProgress.refCleanup=current.refCleanup;return workInProgress;}function resetWorkInProgress(workInProgress,renderLanes){workInProgress.flags&=65011714;var current=workInProgress.alternate;null===current?(workInProgress.childLanes=0,workInProgress.lanes=renderLanes,workInProgress.child=null,workInProgress.subtreeFlags=0,workInProgress.memoizedProps=null,workInProgress.memoizedState=null,workInProgress.updateQueue=null,workInProgress.dependencies=null,workInProgress.stateNode=null):(workInProgress.childLanes=current.childLanes,workInProgress.lanes=current.lanes,workInProgress.child=current.child,workInProgress.subtreeFlags=0,workInProgress.deletions=null,workInProgress.memoizedProps=current.memoizedProps,workInProgress.memoizedState=current.memoizedState,workInProgress.updateQueue=current.updateQueue,workInProgress.type=current.type,renderLanes=current.dependencies,workInProgress.dependencies=null===renderLanes?null:{lanes:renderLanes.lanes,firstContext:renderLanes.firstContext});return workInProgress;}function createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes){var fiberTag=0;owner=type;if("function"===typeof type)shouldConstruct(type)&&(fiberTag=1);else if("string"===typeof type)fiberTag=isHostHoistableType(type,pendingProps,contextStackCursor.current)?26:"html"===type||"head"===type||"body"===type?27:5;else a:switch(type){case REACT_ACTIVITY_TYPE:return type=createFiberImplClass(31,pendingProps,key,mode),type.elementType=REACT_ACTIVITY_TYPE,type.lanes=lanes,type;case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=8;mode|=24;break;case REACT_PROFILER_TYPE:return type=createFiberImplClass(12,pendingProps,key,mode|2),type.elementType=REACT_PROFILER_TYPE,type.lanes=lanes,type;case REACT_SUSPENSE_TYPE:return type=createFiberImplClass(13,pendingProps,key,mode),type.elementType=REACT_SUSPENSE_TYPE,type.lanes=lanes,type;case REACT_SUSPENSE_LIST_TYPE:return type=createFiberImplClass(19,pendingProps,key,mode),type.elementType=REACT_SUSPENSE_LIST_TYPE,type.lanes=lanes,type;default:if("object"===typeof type&&null!==type)switch(type.$$typeof){case REACT_CONTEXT_TYPE:fiberTag=10;break a;case REACT_CONSUMER_TYPE:fiberTag=9;break a;case REACT_FORWARD_REF_TYPE:fiberTag=11;break a;case REACT_MEMO_TYPE:fiberTag=14;break a;case REACT_LAZY_TYPE:fiberTag=16;owner=null;break a;}fiberTag=29;pendingProps=Error(formatProdErrorMessage(130,null===type?"null":typeof type,""));owner=null;}key=createFiberImplClass(fiberTag,pendingProps,key,mode);key.elementType=type;key.type=owner;key.lanes=lanes;return key;}function createFiberFromFragment(elements,mode,lanes,key){elements=createFiberImplClass(7,elements,key,mode);elements.lanes=lanes;return elements;}function createFiberFromText(content,mode,lanes){content=createFiberImplClass(6,content,null,mode);content.lanes=lanes;return content;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiberImplClass(18,null,null,0);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){mode=createFiberImplClass(4,null!==portal.children?portal.children:[],portal.key,mode);mode.lanes=lanes;mode.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,implementation:portal.implementation};return mode;}var CapturedStacks=new WeakMap();function createCapturedValueAtFiber(value,source){if("object"===typeof value&&null!==value){var existing=CapturedStacks.get(value);if(void 0!==existing)return existing;source={value:value,source:source,stack:getStackByFiberInDevAndProd(source)};CapturedStacks.set(value,source);return source;}return {value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}var forkStack=[],forkStackIndex=0,treeForkProvider=null,treeForkCount=0,idStack=[],idStackIndex=0,treeContextProvider=null,treeContextId=1,treeContextOverflow="";function pushTreeFork(workInProgress,totalChildren){forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;workInProgress=treeContextOverflow;var baseLength=32-clz32(baseIdWithLeadingBit)-1;baseIdWithLeadingBit&=~(1<<baseLength);index+=1;var length=32-clz32(totalChildren)+baseLength;if(30<length){var numberOfOverflowBits=baseLength-baseLength%5;length=(baseIdWithLeadingBit&(1<<numberOfOverflowBits)-1).toString(32);baseIdWithLeadingBit>>=numberOfOverflowBits;baseLength-=numberOfOverflowBits;treeContextId=1<<32-clz32(totalChildren)+baseLength|index<<baseLength|baseIdWithLeadingBit;treeContextOverflow=length+workInProgress;}else treeContextId=1<<length|index<<baseLength|baseIdWithLeadingBit,treeContextOverflow=workInProgress;}function pushMaterializedTreeId(workInProgress){null!==workInProgress.return&&(pushTreeFork(workInProgress,1),pushTreeId(workInProgress,1,0));}function popTreeContext(workInProgress){for(;workInProgress===treeForkProvider;)treeForkProvider=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null,treeForkCount=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null;for(;workInProgress===treeContextProvider;)treeContextProvider=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextOverflow=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextId=idStack[--idStackIndex],idStack[idStackIndex]=null;}function restoreSuspendedTreeContext(workInProgress,suspendedContext){idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}var hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=false,hydrationErrors=null,rootOrSingletonContext=false,HydrationMismatchException=Error(formatProdErrorMessage(519));function throwOnHydrationMismatch(fiber){var error=Error(formatProdErrorMessage(418,1<arguments.length&&void 0!==arguments[1]&&arguments[1]?"text":"HTML",""));queueHydrationError(createCapturedValueAtFiber(error,fiber));throw HydrationMismatchException;}function prepareToHydrateHostInstance(fiber){var instance=fiber.stateNode,type=fiber.type,props=fiber.memoizedProps;instance[internalInstanceKey]=fiber;instance[internalPropsKey]=props;switch(type){case "dialog":listenToNonDelegatedEvent("cancel",instance);listenToNonDelegatedEvent("close",instance);break;case "iframe":case "object":case "embed":listenToNonDelegatedEvent("load",instance);break;case "video":case "audio":for(type=0;type<mediaEventTypes.length;type++)listenToNonDelegatedEvent(mediaEventTypes[type],instance);break;case "source":listenToNonDelegatedEvent("error",instance);break;case "img":case "image":case "link":listenToNonDelegatedEvent("error",instance);listenToNonDelegatedEvent("load",instance);break;case "details":listenToNonDelegatedEvent("toggle",instance);break;case "input":listenToNonDelegatedEvent("invalid",instance);initInput(instance,props.value,props.defaultValue,props.checked,props.defaultChecked,props.type,props.name,true);break;case "select":listenToNonDelegatedEvent("invalid",instance);break;case "textarea":listenToNonDelegatedEvent("invalid",instance),initTextarea(instance,props.value,props.defaultValue,props.children);}type=props.children;"string"!==typeof type&&"number"!==typeof type&&"bigint"!==typeof type||instance.textContent===""+type||true===props.suppressHydrationWarning||checkForUnmatchedText(instance.textContent,type)?(null!=props.popover&&(listenToNonDelegatedEvent("beforetoggle",instance),listenToNonDelegatedEvent("toggle",instance)),null!=props.onScroll&&listenToNonDelegatedEvent("scroll",instance),null!=props.onScrollEnd&&listenToNonDelegatedEvent("scrollend",instance),null!=props.onClick&&(instance.onclick=noop$1),instance=true):instance=false;instance||throwOnHydrationMismatch(fiber,true);}function popToNextHostParent(fiber){for(hydrationParentFiber=fiber.return;hydrationParentFiber;)switch(hydrationParentFiber.tag){case 5:case 31:case 13:rootOrSingletonContext=false;return;case 27:case 3:rootOrSingletonContext=true;return;default:hydrationParentFiber=hydrationParentFiber.return;}}function popHydrationState(fiber){if(fiber!==hydrationParentFiber)return  false;if(!isHydrating)return popToNextHostParent(fiber),isHydrating=true,false;var tag=fiber.tag,JSCompiler_temp;if(JSCompiler_temp=3!==tag&&27!==tag){if(JSCompiler_temp=5===tag)JSCompiler_temp=fiber.type,JSCompiler_temp=!("form"!==JSCompiler_temp&&"button"!==JSCompiler_temp)||shouldSetTextContent(fiber.type,fiber.memoizedProps);JSCompiler_temp=!JSCompiler_temp;}JSCompiler_temp&&nextHydratableInstance&&throwOnHydrationMismatch(fiber);popToNextHostParent(fiber);if(13===tag){fiber=fiber.memoizedState;fiber=null!==fiber?fiber.dehydrated:null;if(!fiber)throw Error(formatProdErrorMessage(317));nextHydratableInstance=getNextHydratableInstanceAfterHydrationBoundary(fiber);}else if(31===tag){fiber=fiber.memoizedState;fiber=null!==fiber?fiber.dehydrated:null;if(!fiber)throw Error(formatProdErrorMessage(317));nextHydratableInstance=getNextHydratableInstanceAfterHydrationBoundary(fiber);}else 27===tag?(tag=nextHydratableInstance,isSingletonScope(fiber.type)?(fiber=previousHydratableOnEnteringScopedSingleton,previousHydratableOnEnteringScopedSingleton=null,nextHydratableInstance=fiber):nextHydratableInstance=tag):nextHydratableInstance=hydrationParentFiber?getNextHydratable(fiber.stateNode.nextSibling):null;return  true;}function resetHydrationState(){nextHydratableInstance=hydrationParentFiber=null;isHydrating=false;}function upgradeHydrationErrorsToRecoverable(){var queuedErrors=hydrationErrors;null!==queuedErrors&&(null===workInProgressRootRecoverableErrors?workInProgressRootRecoverableErrors=queuedErrors:workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,queuedErrors),hydrationErrors=null);return queuedErrors;}function queueHydrationError(error){null===hydrationErrors?hydrationErrors=[error]:hydrationErrors.push(error);}var valueCursor=createCursor(null),currentlyRenderingFiber$1=null,lastContextDependency=null;function pushProvider(providerFiber,context,nextValue){push(valueCursor,context._currentValue);context._currentValue=nextValue;}function popProvider(context){context._currentValue=valueCursor.current;pop(valueCursor);}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){for(;null!==parent;){var alternate=parent.alternate;(parent.childLanes&renderLanes)!==renderLanes?(parent.childLanes|=renderLanes,null!==alternate&&(alternate.childLanes|=renderLanes)):null!==alternate&&(alternate.childLanes&renderLanes)!==renderLanes&&(alternate.childLanes|=renderLanes);if(parent===propagationRoot)break;parent=parent.return;}}function propagateContextChanges(workInProgress,contexts,renderLanes,forcePropagateEntireTree){var fiber=workInProgress.child;null!==fiber&&(fiber.return=workInProgress);for(;null!==fiber;){var list=fiber.dependencies;if(null!==list){var nextFiber=fiber.child;list=list.firstContext;a:for(;null!==list;){var dependency=list;list=fiber;for(var i=0;i<contexts.length;i++)if(dependency.context===contexts[i]){list.lanes|=renderLanes;dependency=list.alternate;null!==dependency&&(dependency.lanes|=renderLanes);scheduleContextWorkOnParentPath(list.return,renderLanes,workInProgress);forcePropagateEntireTree||(nextFiber=null);break a;}list=dependency.next;}}else if(18===fiber.tag){nextFiber=fiber.return;if(null===nextFiber)throw Error(formatProdErrorMessage(341));nextFiber.lanes|=renderLanes;list=nextFiber.alternate;null!==list&&(list.lanes|=renderLanes);scheduleContextWorkOnParentPath(nextFiber,renderLanes,workInProgress);nextFiber=null;}else nextFiber=fiber.child;if(null!==nextFiber)nextFiber.return=fiber;else for(nextFiber=fiber;null!==nextFiber;){if(nextFiber===workInProgress){nextFiber=null;break;}fiber=nextFiber.sibling;if(null!==fiber){fiber.return=nextFiber.return;nextFiber=fiber;break;}nextFiber=nextFiber.return;}fiber=nextFiber;}}function propagateParentContextChanges(current,workInProgress,renderLanes,forcePropagateEntireTree){current=null;for(var parent=workInProgress,isInsidePropagationBailout=false;null!==parent;){if(!isInsidePropagationBailout)if(0!==(parent.flags&524288))isInsidePropagationBailout=true;else if(0!==(parent.flags&262144))break;if(10===parent.tag){var currentParent=parent.alternate;if(null===currentParent)throw Error(formatProdErrorMessage(387));currentParent=currentParent.memoizedProps;if(null!==currentParent){var context=parent.type;objectIs(parent.pendingProps.value,currentParent.value)||(null!==current?current.push(context):current=[context]);}}else if(parent===hostTransitionProviderCursor.current){currentParent=parent.alternate;if(null===currentParent)throw Error(formatProdErrorMessage(387));currentParent.memoizedState.memoizedState!==parent.memoizedState.memoizedState&&(null!==current?current.push(HostTransitionContext):current=[HostTransitionContext]);}parent=parent.return;}null!==current&&propagateContextChanges(workInProgress,current,renderLanes,forcePropagateEntireTree);workInProgress.flags|=262144;}function checkIfContextChanged(currentDependencies){for(currentDependencies=currentDependencies.firstContext;null!==currentDependencies;){if(!objectIs(currentDependencies.context._currentValue,currentDependencies.memoizedValue))return  true;currentDependencies=currentDependencies.next;}return  false;}function prepareToReadContext(workInProgress){currentlyRenderingFiber$1=workInProgress;lastContextDependency=null;workInProgress=workInProgress.dependencies;null!==workInProgress&&(workInProgress.firstContext=null);}function readContext(context){return readContextForConsumer(currentlyRenderingFiber$1,context);}function readContextDuringReconciliation(consumer,context){null===currentlyRenderingFiber$1&&prepareToReadContext(consumer);return readContextForConsumer(consumer,context);}function readContextForConsumer(consumer,context){var value=context._currentValue;context={context:context,memoizedValue:value,next:null};if(null===lastContextDependency){if(null===consumer)throw Error(formatProdErrorMessage(308));lastContextDependency=context;consumer.dependencies={lanes:0,firstContext:context};consumer.flags|=524288;}else lastContextDependency=lastContextDependency.next=context;return value;}var AbortControllerLocal="undefined"!==typeof AbortController?AbortController:function(){var listeners=[],signal=this.signal={aborted:false,addEventListener:function(type,listener){listeners.push(listener);}};this.abort=function(){signal.aborted=true;listeners.forEach(function(listener){return listener();});};},scheduleCallback$2=Scheduler.unstable_scheduleCallback,NormalPriority=Scheduler.unstable_NormalPriority,CacheContext={$$typeof:REACT_CONTEXT_TYPE,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function createCache(){return {controller:new AbortControllerLocal(),data:new Map(),refCount:0};}function releaseCache(cache){cache.refCount--;0===cache.refCount&&scheduleCallback$2(NormalPriority,function(){cache.controller.abort();});}var currentEntangledListeners=null,currentEntangledPendingCount=0,currentEntangledLane=0,currentEntangledActionThenable=null;function entangleAsyncAction(transition,thenable){if(null===currentEntangledListeners){var entangledListeners=currentEntangledListeners=[];currentEntangledPendingCount=0;currentEntangledLane=requestTransitionLane();currentEntangledActionThenable={status:"pending",value:void 0,then:function(resolve){entangledListeners.push(resolve);}};}currentEntangledPendingCount++;thenable.then(pingEngtangledActionScope,pingEngtangledActionScope);return thenable;}function pingEngtangledActionScope(){if(0===--currentEntangledPendingCount&&null!==currentEntangledListeners){null!==currentEntangledActionThenable&&(currentEntangledActionThenable.status="fulfilled");var listeners=currentEntangledListeners;currentEntangledListeners=null;currentEntangledLane=0;currentEntangledActionThenable=null;for(var i=0;i<listeners.length;i++)(0, listeners[i])();}}function chainThenableValue(thenable,result){var listeners=[],thenableWithOverride={status:"pending",value:null,reason:null,then:function(resolve){listeners.push(resolve);}};thenable.then(function(){thenableWithOverride.status="fulfilled";thenableWithOverride.value=result;for(var i=0;i<listeners.length;i++)(0, listeners[i])(result);},function(error){thenableWithOverride.status="rejected";thenableWithOverride.reason=error;for(error=0;error<listeners.length;error++)(0, listeners[error])(void 0);});return thenableWithOverride;}var prevOnStartTransitionFinish=ReactSharedInternals.S;ReactSharedInternals.S=function(transition,returnValue){globalMostRecentTransitionTime=now();"object"===typeof returnValue&&null!==returnValue&&"function"===typeof returnValue.then&&entangleAsyncAction(transition,returnValue);null!==prevOnStartTransitionFinish&&prevOnStartTransitionFinish(transition,returnValue);};var resumedCache=createCursor(null);function peekCacheFromPool(){var cacheResumedFromPreviousRender=resumedCache.current;return null!==cacheResumedFromPreviousRender?cacheResumedFromPreviousRender:workInProgressRoot.pooledCache;}function pushTransition(offscreenWorkInProgress,prevCachePool){null===prevCachePool?push(resumedCache,resumedCache.current):push(resumedCache,prevCachePool.pool);}function getSuspendedCache(){var cacheFromPool=peekCacheFromPool();return null===cacheFromPool?null:{parent:CacheContext._currentValue,pool:cacheFromPool};}var SuspenseException=Error(formatProdErrorMessage(460)),SuspenseyCommitException=Error(formatProdErrorMessage(474)),SuspenseActionException=Error(formatProdErrorMessage(542)),noopSuspenseyCommitThenable={then:function(){}};function isThenableResolved(thenable){thenable=thenable.status;return "fulfilled"===thenable||"rejected"===thenable;}function trackUsedThenable(thenableState,thenable,index){index=thenableState[index];void 0===index?thenableState.push(thenable):index!==thenable&&(thenable.then(noop$1,noop$1),thenable=index);switch(thenable.status){case "fulfilled":return thenable.value;case "rejected":throw thenableState=thenable.reason,checkIfUseWrappedInAsyncCatch(thenableState),thenableState;default:if("string"===typeof thenable.status)thenable.then(noop$1,noop$1);else {thenableState=workInProgressRoot;if(null!==thenableState&&100<thenableState.shellSuspendCounter)throw Error(formatProdErrorMessage(482));thenableState=thenable;thenableState.status="pending";thenableState.then(function(fulfilledValue){if("pending"===thenable.status){var fulfilledThenable=thenable;fulfilledThenable.status="fulfilled";fulfilledThenable.value=fulfilledValue;}},function(error){if("pending"===thenable.status){var rejectedThenable=thenable;rejectedThenable.status="rejected";rejectedThenable.reason=error;}});}switch(thenable.status){case "fulfilled":return thenable.value;case "rejected":throw thenableState=thenable.reason,checkIfUseWrappedInAsyncCatch(thenableState),thenableState;}suspendedThenable=thenable;throw SuspenseException;}}function resolveLazy(lazyType){try{var init=lazyType._init;return init(lazyType._payload);}catch(x){if(null!==x&&"object"===typeof x&&"function"===typeof x.then)throw suspendedThenable=x,SuspenseException;throw x;}}var suspendedThenable=null;function getSuspendedThenable(){if(null===suspendedThenable)throw Error(formatProdErrorMessage(459));var thenable=suspendedThenable;suspendedThenable=null;return thenable;}function checkIfUseWrappedInAsyncCatch(rejectedReason){if(rejectedReason===SuspenseException||rejectedReason===SuspenseActionException)throw Error(formatProdErrorMessage(483));}var thenableState$1=null,thenableIndexCounter$1=0;function unwrapThenable(thenable){var index=thenableIndexCounter$1;thenableIndexCounter$1+=1;null===thenableState$1&&(thenableState$1=[]);return trackUsedThenable(thenableState$1,thenable,index);}function coerceRef(workInProgress,element){element=element.props.ref;workInProgress.ref=void 0!==element?element:null;}function throwOnInvalidObjectTypeImpl(returnFiber,newChild){if(newChild.$$typeof===REACT_LEGACY_ELEMENT_TYPE)throw Error(formatProdErrorMessage(525));returnFiber=Object.prototype.toString.call(newChild);throw Error(formatProdErrorMessage(31,"[object Object]"===returnFiber?"object with keys {"+Object.keys(newChild).join(", ")+"}":returnFiber));}function createChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(shouldTrackSideEffects){var deletions=returnFiber.deletions;null===deletions?(returnFiber.deletions=[childToDelete],returnFiber.flags|=16):deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects)return null;for(;null!==currentFirstChild;)deleteChild(returnFiber,currentFirstChild),currentFirstChild=currentFirstChild.sibling;return null;}function mapRemainingChildren(currentFirstChild){for(var existingChildren=new Map();null!==currentFirstChild;)null!==currentFirstChild.key?existingChildren.set(currentFirstChild.key,currentFirstChild):existingChildren.set(currentFirstChild.index,currentFirstChild),currentFirstChild=currentFirstChild.sibling;return existingChildren;}function useFiber(fiber,pendingProps){fiber=createWorkInProgress(fiber,pendingProps);fiber.index=0;fiber.sibling=null;return fiber;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects)return newFiber.flags|=1048576,lastPlacedIndex;newIndex=newFiber.alternate;if(null!==newIndex)return newIndex=newIndex.index,newIndex<lastPlacedIndex?(newFiber.flags|=67108866,lastPlacedIndex):newIndex;newFiber.flags|=67108866;return lastPlacedIndex;}function placeSingleChild(newFiber){shouldTrackSideEffects&&null===newFiber.alternate&&(newFiber.flags|=67108866);return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(null===current||6!==current.tag)return current=createFiberFromText(textContent,returnFiber.mode,lanes),current.return=returnFiber,current;current=useFiber(current,textContent);current.return=returnFiber;return current;}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE)return updateFragment(returnFiber,current,element.props.children,lanes,element.key);if(null!==current&&(current.elementType===elementType||"object"===typeof elementType&&null!==elementType&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type))return current=useFiber(current,element.props),coerceRef(current,element),current.return=returnFiber,current;current=createFiberFromTypeAndProps(element.type,element.key,element.props,null,returnFiber.mode,lanes);coerceRef(current,element);current.return=returnFiber;return current;}function updatePortal(returnFiber,current,portal,lanes){if(null===current||4!==current.tag||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation)return current=createFiberFromPortal(portal,returnFiber.mode,lanes),current.return=returnFiber,current;current=useFiber(current,portal.children||[]);current.return=returnFiber;return current;}function updateFragment(returnFiber,current,fragment,lanes,key){if(null===current||7!==current.tag)return current=createFiberFromFragment(fragment,returnFiber.mode,lanes,key),current.return=returnFiber,current;current=useFiber(current,fragment);current.return=returnFiber;return current;}function createChild(returnFiber,newChild,lanes){if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild||"bigint"===typeof newChild)return newChild=createFiberFromText(""+newChild,returnFiber.mode,lanes),newChild.return=returnFiber,newChild;if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return lanes=createFiberFromTypeAndProps(newChild.type,newChild.key,newChild.props,null,returnFiber.mode,lanes),coerceRef(lanes,newChild),lanes.return=returnFiber,lanes;case REACT_PORTAL_TYPE:return newChild=createFiberFromPortal(newChild,returnFiber.mode,lanes),newChild.return=returnFiber,newChild;case REACT_LAZY_TYPE:return newChild=resolveLazy(newChild),createChild(returnFiber,newChild,lanes);}if(isArrayImpl(newChild)||getIteratorFn(newChild))return newChild=createFiberFromFragment(newChild,returnFiber.mode,lanes,null),newChild.return=returnFiber,newChild;if("function"===typeof newChild.then)return createChild(returnFiber,unwrapThenable(newChild),lanes);if(newChild.$$typeof===REACT_CONTEXT_TYPE)return createChild(returnFiber,readContextDuringReconciliation(returnFiber,newChild),lanes);throwOnInvalidObjectTypeImpl(returnFiber,newChild);}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){var key=null!==oldFiber?oldFiber.key:null;if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild||"bigint"===typeof newChild)return null!==key?null:updateTextNode(returnFiber,oldFiber,""+newChild,lanes);if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return newChild.key===key?updateElement(returnFiber,oldFiber,newChild,lanes):null;case REACT_PORTAL_TYPE:return newChild.key===key?updatePortal(returnFiber,oldFiber,newChild,lanes):null;case REACT_LAZY_TYPE:return newChild=resolveLazy(newChild),updateSlot(returnFiber,oldFiber,newChild,lanes);}if(isArrayImpl(newChild)||getIteratorFn(newChild))return null!==key?null:updateFragment(returnFiber,oldFiber,newChild,lanes,null);if("function"===typeof newChild.then)return updateSlot(returnFiber,oldFiber,unwrapThenable(newChild),lanes);if(newChild.$$typeof===REACT_CONTEXT_TYPE)return updateSlot(returnFiber,oldFiber,readContextDuringReconciliation(returnFiber,newChild),lanes);throwOnInvalidObjectTypeImpl(returnFiber,newChild);}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild||"bigint"===typeof newChild)return existingChildren=existingChildren.get(newIdx)||null,updateTextNode(returnFiber,existingChildren,""+newChild,lanes);if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return existingChildren=existingChildren.get(null===newChild.key?newIdx:newChild.key)||null,updateElement(returnFiber,existingChildren,newChild,lanes);case REACT_PORTAL_TYPE:return existingChildren=existingChildren.get(null===newChild.key?newIdx:newChild.key)||null,updatePortal(returnFiber,existingChildren,newChild,lanes);case REACT_LAZY_TYPE:return newChild=resolveLazy(newChild),updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes);}if(isArrayImpl(newChild)||getIteratorFn(newChild))return existingChildren=existingChildren.get(newIdx)||null,updateFragment(returnFiber,existingChildren,newChild,lanes,null);if("function"===typeof newChild.then)return updateFromMap(existingChildren,returnFiber,newIdx,unwrapThenable(newChild),lanes);if(newChild.$$typeof===REACT_CONTEXT_TYPE)return updateFromMap(existingChildren,returnFiber,newIdx,readContextDuringReconciliation(returnFiber,newChild),lanes);throwOnInvalidObjectTypeImpl(returnFiber,newChild);}return null;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,newIdx=currentFirstChild=0,nextOldFiber=null;null!==oldFiber&&newIdx<newChildren.length;newIdx++){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(null===newFiber){null===oldFiber&&(oldFiber=nextOldFiber);break;}shouldTrackSideEffects&&oldFiber&&null===newFiber.alternate&&deleteChild(returnFiber,oldFiber);currentFirstChild=placeChild(newFiber,currentFirstChild,newIdx);null===previousNewFiber?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber;previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length)return deleteRemainingChildren(returnFiber,oldFiber),isHydrating&&pushTreeFork(returnFiber,newIdx),resultingFirstChild;if(null===oldFiber){for(;newIdx<newChildren.length;newIdx++)oldFiber=createChild(returnFiber,newChildren[newIdx],lanes),null!==oldFiber&&(currentFirstChild=placeChild(oldFiber,currentFirstChild,newIdx),null===previousNewFiber?resultingFirstChild=oldFiber:previousNewFiber.sibling=oldFiber,previousNewFiber=oldFiber);isHydrating&&pushTreeFork(returnFiber,newIdx);return resultingFirstChild;}for(oldFiber=mapRemainingChildren(oldFiber);newIdx<newChildren.length;newIdx++)nextOldFiber=updateFromMap(oldFiber,returnFiber,newIdx,newChildren[newIdx],lanes),null!==nextOldFiber&&(shouldTrackSideEffects&&null!==nextOldFiber.alternate&&oldFiber.delete(null===nextOldFiber.key?newIdx:nextOldFiber.key),currentFirstChild=placeChild(nextOldFiber,currentFirstChild,newIdx),null===previousNewFiber?resultingFirstChild=nextOldFiber:previousNewFiber.sibling=nextOldFiber,previousNewFiber=nextOldFiber);shouldTrackSideEffects&&oldFiber.forEach(function(child){return deleteChild(returnFiber,child);});isHydrating&&pushTreeFork(returnFiber,newIdx);return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildren,lanes){if(null==newChildren)throw Error(formatProdErrorMessage(151));for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,newIdx=currentFirstChild=0,nextOldFiber=null,step=newChildren.next();null!==oldFiber&&!step.done;newIdx++,step=newChildren.next()){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(null===newFiber){null===oldFiber&&(oldFiber=nextOldFiber);break;}shouldTrackSideEffects&&oldFiber&&null===newFiber.alternate&&deleteChild(returnFiber,oldFiber);currentFirstChild=placeChild(newFiber,currentFirstChild,newIdx);null===previousNewFiber?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber;previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done)return deleteRemainingChildren(returnFiber,oldFiber),isHydrating&&pushTreeFork(returnFiber,newIdx),resultingFirstChild;if(null===oldFiber){for(;!step.done;newIdx++,step=newChildren.next())step=createChild(returnFiber,step.value,lanes),null!==step&&(currentFirstChild=placeChild(step,currentFirstChild,newIdx),null===previousNewFiber?resultingFirstChild=step:previousNewFiber.sibling=step,previousNewFiber=step);isHydrating&&pushTreeFork(returnFiber,newIdx);return resultingFirstChild;}for(oldFiber=mapRemainingChildren(oldFiber);!step.done;newIdx++,step=newChildren.next())step=updateFromMap(oldFiber,returnFiber,newIdx,step.value,lanes),null!==step&&(shouldTrackSideEffects&&null!==step.alternate&&oldFiber.delete(null===step.key?newIdx:step.key),currentFirstChild=placeChild(step,currentFirstChild,newIdx),null===previousNewFiber?resultingFirstChild=step:previousNewFiber.sibling=step,previousNewFiber=step);shouldTrackSideEffects&&oldFiber.forEach(function(child){return deleteChild(returnFiber,child);});isHydrating&&pushTreeFork(returnFiber,newIdx);return resultingFirstChild;}function reconcileChildFibersImpl(returnFiber,currentFirstChild,newChild,lanes){"object"===typeof newChild&&null!==newChild&&newChild.type===REACT_FRAGMENT_TYPE&&null===newChild.key&&(newChild=newChild.props.children);if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:a:{for(var key=newChild.key;null!==currentFirstChild;){if(currentFirstChild.key===key){key=newChild.type;if(key===REACT_FRAGMENT_TYPE){if(7===currentFirstChild.tag){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);lanes=useFiber(currentFirstChild,newChild.props.children);lanes.return=returnFiber;returnFiber=lanes;break a;}}else if(currentFirstChild.elementType===key||"object"===typeof key&&null!==key&&key.$$typeof===REACT_LAZY_TYPE&&resolveLazy(key)===currentFirstChild.type){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);lanes=useFiber(currentFirstChild,newChild.props);coerceRef(lanes,newChild);lanes.return=returnFiber;returnFiber=lanes;break a;}deleteRemainingChildren(returnFiber,currentFirstChild);break;}else deleteChild(returnFiber,currentFirstChild);currentFirstChild=currentFirstChild.sibling;}newChild.type===REACT_FRAGMENT_TYPE?(lanes=createFiberFromFragment(newChild.props.children,returnFiber.mode,lanes,newChild.key),lanes.return=returnFiber,returnFiber=lanes):(lanes=createFiberFromTypeAndProps(newChild.type,newChild.key,newChild.props,null,returnFiber.mode,lanes),coerceRef(lanes,newChild),lanes.return=returnFiber,returnFiber=lanes);}return placeSingleChild(returnFiber);case REACT_PORTAL_TYPE:a:{for(key=newChild.key;null!==currentFirstChild;){if(currentFirstChild.key===key){if(4===currentFirstChild.tag&&currentFirstChild.stateNode.containerInfo===newChild.containerInfo&&currentFirstChild.stateNode.implementation===newChild.implementation){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);lanes=useFiber(currentFirstChild,newChild.children||[]);lanes.return=returnFiber;returnFiber=lanes;break a;}else {deleteRemainingChildren(returnFiber,currentFirstChild);break;}}else deleteChild(returnFiber,currentFirstChild);currentFirstChild=currentFirstChild.sibling;}lanes=createFiberFromPortal(newChild,returnFiber.mode,lanes);lanes.return=returnFiber;returnFiber=lanes;}return placeSingleChild(returnFiber);case REACT_LAZY_TYPE:return newChild=resolveLazy(newChild),reconcileChildFibersImpl(returnFiber,currentFirstChild,newChild,lanes);}if(isArrayImpl(newChild))return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);if(getIteratorFn(newChild)){key=getIteratorFn(newChild);if("function"!==typeof key)throw Error(formatProdErrorMessage(150));newChild=key.call(newChild);return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}if("function"===typeof newChild.then)return reconcileChildFibersImpl(returnFiber,currentFirstChild,unwrapThenable(newChild),lanes);if(newChild.$$typeof===REACT_CONTEXT_TYPE)return reconcileChildFibersImpl(returnFiber,currentFirstChild,readContextDuringReconciliation(returnFiber,newChild),lanes);throwOnInvalidObjectTypeImpl(returnFiber,newChild);}return "string"===typeof newChild&&""!==newChild||"number"===typeof newChild||"bigint"===typeof newChild?(newChild=""+newChild,null!==currentFirstChild&&6===currentFirstChild.tag?(deleteRemainingChildren(returnFiber,currentFirstChild.sibling),lanes=useFiber(currentFirstChild,newChild),lanes.return=returnFiber,returnFiber=lanes):(deleteRemainingChildren(returnFiber,currentFirstChild),lanes=createFiberFromText(newChild,returnFiber.mode,lanes),lanes.return=returnFiber,returnFiber=lanes),placeSingleChild(returnFiber)):deleteRemainingChildren(returnFiber,currentFirstChild);}return function(returnFiber,currentFirstChild,newChild,lanes){try{thenableIndexCounter$1=0;var firstChildFiber=reconcileChildFibersImpl(returnFiber,currentFirstChild,newChild,lanes);thenableState$1=null;return firstChildFiber;}catch(x){if(x===SuspenseException||x===SuspenseActionException)throw x;var fiber=createFiberImplClass(29,x,null,returnFiber.mode);fiber.lanes=lanes;fiber.return=returnFiber;return fiber;}finally{}};}var reconcileChildFibers=createChildReconciler(true),mountChildFibers=createChildReconciler(false),hasForceUpdate=false;function initializeUpdateQueue(fiber){fiber.updateQueue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null};}function cloneUpdateQueue(current,workInProgress){current=current.updateQueue;workInProgress.updateQueue===current&&(workInProgress.updateQueue={baseState:current.baseState,firstBaseUpdate:current.firstBaseUpdate,lastBaseUpdate:current.lastBaseUpdate,shared:current.shared,callbacks:null});}function createUpdate(lane){return {lane:lane,tag:0,payload:null,callback:null,next:null};}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(null===updateQueue)return null;updateQueue=updateQueue.shared;if(0!==(executionContext&2)){var pending=updateQueue.pending;null===pending?update.next=update:(update.next=pending.next,pending.next=update);updateQueue.pending=update;update=getRootForUpdatedFiber(fiber);markUpdateLaneFromFiberToRoot(fiber,null,lane);return update;}enqueueUpdate$1(fiber,updateQueue,update,lane);return getRootForUpdatedFiber(fiber);}function entangleTransitions(root,fiber,lane){fiber=fiber.updateQueue;if(null!==fiber&&(fiber=fiber.shared,0!==(lane&4194048))){var queueLanes=fiber.lanes;queueLanes&=root.pendingLanes;lane|=queueLanes;fiber.lanes=lane;markRootEntangled(root,lane);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){var queue=workInProgress.updateQueue,current=workInProgress.alternate;if(null!==current&&(current=current.updateQueue,queue===current)){var newFirst=null,newLast=null;queue=queue.firstBaseUpdate;if(null!==queue){do{var clone={lane:queue.lane,tag:queue.tag,payload:queue.payload,callback:null,next:null};null===newLast?newFirst=newLast=clone:newLast=newLast.next=clone;queue=queue.next;}while(null!==queue);null===newLast?newFirst=newLast=capturedUpdate:newLast=newLast.next=capturedUpdate;}else newFirst=newLast=capturedUpdate;queue={baseState:current.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:current.shared,callbacks:current.callbacks};workInProgress.updateQueue=queue;return;}workInProgress=queue.lastBaseUpdate;null===workInProgress?queue.firstBaseUpdate=capturedUpdate:workInProgress.next=capturedUpdate;queue.lastBaseUpdate=capturedUpdate;}var didReadFromEntangledAsyncAction=false;function suspendIfUpdateReadFromEntangledAsyncAction(){if(didReadFromEntangledAsyncAction){var entangledActionThenable=currentEntangledActionThenable;if(null!==entangledActionThenable)throw entangledActionThenable;}}function processUpdateQueue(workInProgress$jscomp$0,props,instance$jscomp$0,renderLanes){didReadFromEntangledAsyncAction=false;var queue=workInProgress$jscomp$0.updateQueue;hasForceUpdate=false;var firstBaseUpdate=queue.firstBaseUpdate,lastBaseUpdate=queue.lastBaseUpdate,pendingQueue=queue.shared.pending;if(null!==pendingQueue){queue.shared.pending=null;var lastPendingUpdate=pendingQueue,firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;null===lastBaseUpdate?firstBaseUpdate=firstPendingUpdate:lastBaseUpdate.next=firstPendingUpdate;lastBaseUpdate=lastPendingUpdate;var current=workInProgress$jscomp$0.alternate;null!==current&&(current=current.updateQueue,pendingQueue=current.lastBaseUpdate,pendingQueue!==lastBaseUpdate&&(null===pendingQueue?current.firstBaseUpdate=firstPendingUpdate:pendingQueue.next=firstPendingUpdate,current.lastBaseUpdate=lastPendingUpdate));}if(null!==firstBaseUpdate){var newState=queue.baseState;lastBaseUpdate=0;current=firstPendingUpdate=lastPendingUpdate=null;pendingQueue=firstBaseUpdate;do{var updateLane=pendingQueue.lane&-536870913,isHiddenUpdate=updateLane!==pendingQueue.lane;if(isHiddenUpdate?(workInProgressRootRenderLanes&updateLane)===updateLane:(renderLanes&updateLane)===updateLane){0!==updateLane&&updateLane===currentEntangledLane&&(didReadFromEntangledAsyncAction=true);null!==current&&(current=current.next={lane:0,tag:pendingQueue.tag,payload:pendingQueue.payload,callback:null,next:null});a:{var workInProgress=workInProgress$jscomp$0,update=pendingQueue;updateLane=props;var instance=instance$jscomp$0;switch(update.tag){case 1:workInProgress=update.payload;if("function"===typeof workInProgress){newState=workInProgress.call(instance,newState,updateLane);break a;}newState=workInProgress;break a;case 3:workInProgress.flags=workInProgress.flags&-65537|128;case 0:workInProgress=update.payload;updateLane="function"===typeof workInProgress?workInProgress.call(instance,newState,updateLane):workInProgress;if(null===updateLane||void 0===updateLane)break a;newState=assign({},newState,updateLane);break a;case 2:hasForceUpdate=true;}}updateLane=pendingQueue.callback;null!==updateLane&&(workInProgress$jscomp$0.flags|=64,isHiddenUpdate&&(workInProgress$jscomp$0.flags|=8192),isHiddenUpdate=queue.callbacks,null===isHiddenUpdate?queue.callbacks=[updateLane]:isHiddenUpdate.push(updateLane));}else isHiddenUpdate={lane:updateLane,tag:pendingQueue.tag,payload:pendingQueue.payload,callback:pendingQueue.callback,next:null},null===current?(firstPendingUpdate=current=isHiddenUpdate,lastPendingUpdate=newState):current=current.next=isHiddenUpdate,lastBaseUpdate|=updateLane;pendingQueue=pendingQueue.next;if(null===pendingQueue)if(pendingQueue=queue.shared.pending,null===pendingQueue)break;else isHiddenUpdate=pendingQueue,pendingQueue=isHiddenUpdate.next,isHiddenUpdate.next=null,queue.lastBaseUpdate=isHiddenUpdate,queue.shared.pending=null;}while(1);null===current&&(lastPendingUpdate=newState);queue.baseState=lastPendingUpdate;queue.firstBaseUpdate=firstPendingUpdate;queue.lastBaseUpdate=current;null===firstBaseUpdate&&(queue.shared.lanes=0);workInProgressRootSkippedLanes|=lastBaseUpdate;workInProgress$jscomp$0.lanes=lastBaseUpdate;workInProgress$jscomp$0.memoizedState=newState;}}function callCallback(callback,context){if("function"!==typeof callback)throw Error(formatProdErrorMessage(191,callback));callback.call(context);}function commitCallbacks(updateQueue,context){var callbacks=updateQueue.callbacks;if(null!==callbacks)for(updateQueue.callbacks=null,updateQueue=0;updateQueue<callbacks.length;updateQueue++)callCallback(callbacks[updateQueue],context);}var currentTreeHiddenStackCursor=createCursor(null),prevEntangledRenderLanesCursor=createCursor(0);function pushHiddenContext(fiber,context){fiber=entangledRenderLanes;push(prevEntangledRenderLanesCursor,fiber);push(currentTreeHiddenStackCursor,context);entangledRenderLanes=fiber|context.baseLanes;}function reuseHiddenContextOnStack(){push(prevEntangledRenderLanesCursor,entangledRenderLanes);push(currentTreeHiddenStackCursor,currentTreeHiddenStackCursor.current);}function popHiddenContext(){entangledRenderLanes=prevEntangledRenderLanesCursor.current;pop(currentTreeHiddenStackCursor);pop(prevEntangledRenderLanesCursor);}var suspenseHandlerStackCursor=createCursor(null),shellBoundary=null;function pushPrimaryTreeSuspenseHandler(handler){var current=handler.alternate;push(suspenseStackCursor,suspenseStackCursor.current&1);push(suspenseHandlerStackCursor,handler);null===shellBoundary&&(null===current||null!==currentTreeHiddenStackCursor.current?shellBoundary=handler:null!==current.memoizedState&&(shellBoundary=handler));}function pushDehydratedActivitySuspenseHandler(fiber){push(suspenseStackCursor,suspenseStackCursor.current);push(suspenseHandlerStackCursor,fiber);null===shellBoundary&&(shellBoundary=fiber);}function pushOffscreenSuspenseHandler(fiber){22===fiber.tag?(push(suspenseStackCursor,suspenseStackCursor.current),push(suspenseHandlerStackCursor,fiber),null===shellBoundary&&(shellBoundary=fiber)):reuseSuspenseHandlerOnStack();}function reuseSuspenseHandlerOnStack(){push(suspenseStackCursor,suspenseStackCursor.current);push(suspenseHandlerStackCursor,suspenseHandlerStackCursor.current);}function popSuspenseHandler(fiber){pop(suspenseHandlerStackCursor);shellBoundary===fiber&&(shellBoundary=null);pop(suspenseStackCursor);}var suspenseStackCursor=createCursor(0);function findFirstSuspended(row){for(var node=row;null!==node;){if(13===node.tag){var state=node.memoizedState;if(null!==state&&(state=state.dehydrated,null===state||isSuspenseInstancePending(state)||isSuspenseInstanceFallback(state)))return node;}else if(19===node.tag&&("forwards"===node.memoizedProps.revealOrder||"backwards"===node.memoizedProps.revealOrder||"unstable_legacy-backwards"===node.memoizedProps.revealOrder||"together"===node.memoizedProps.revealOrder)){if(0!==(node.flags&128))return node;}else if(null!==node.child){node.child.return=node;node=node.child;continue;}if(node===row)break;for(;null===node.sibling;){if(null===node.return||node.return===row)return null;node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var renderLanes=0,currentlyRenderingFiber=null,currentHook=null,workInProgressHook=null,didScheduleRenderPhaseUpdate=false,didScheduleRenderPhaseUpdateDuringThisPass=false,shouldDoubleInvokeUserFnsInHooksDEV=false,localIdCounter=0,thenableIndexCounter=0,thenableState=null,globalClientIdCounter=0;function throwInvalidHookError(){throw Error(formatProdErrorMessage(321));}function areHookInputsEqual(nextDeps,prevDeps){if(null===prevDeps)return  false;for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++)if(!objectIs(nextDeps[i],prevDeps[i]))return  false;return  true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber=workInProgress;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=0;ReactSharedInternals.H=null===current||null===current.memoizedState?HooksDispatcherOnMount:HooksDispatcherOnUpdate;shouldDoubleInvokeUserFnsInHooksDEV=false;nextRenderLanes=Component(props,secondArg);shouldDoubleInvokeUserFnsInHooksDEV=false;didScheduleRenderPhaseUpdateDuringThisPass&&(nextRenderLanes=renderWithHooksAgain(workInProgress,Component,props,secondArg));finishRenderingHooks(current);return nextRenderLanes;}function finishRenderingHooks(current){ReactSharedInternals.H=ContextOnlyDispatcher;var didRenderTooFewHooks=null!==currentHook&&null!==currentHook.next;renderLanes=0;workInProgressHook=currentHook=currentlyRenderingFiber=null;didScheduleRenderPhaseUpdate=false;thenableIndexCounter=0;thenableState=null;if(didRenderTooFewHooks)throw Error(formatProdErrorMessage(300));null===current||didReceiveUpdate||(current=current.dependencies,null!==current&&checkIfContextChanged(current)&&(didReceiveUpdate=true));}function renderWithHooksAgain(workInProgress,Component,props,secondArg){currentlyRenderingFiber=workInProgress;var numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass&&(thenableState=null);thenableIndexCounter=0;didScheduleRenderPhaseUpdateDuringThisPass=false;if(25<=numberOfReRenders)throw Error(formatProdErrorMessage(301));numberOfReRenders+=1;workInProgressHook=currentHook=null;if(null!=workInProgress.updateQueue){var children=workInProgress.updateQueue;children.lastEffect=null;children.events=null;children.stores=null;null!=children.memoCache&&(children.memoCache.index=0);}ReactSharedInternals.H=HooksDispatcherOnRerender;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);return children;}function TransitionAwareHostComponent(){var dispatcher=ReactSharedInternals.H,maybeThenable=dispatcher.useState()[0];maybeThenable="function"===typeof maybeThenable.then?useThenable(maybeThenable):maybeThenable;dispatcher=dispatcher.useState()[0];(null!==currentHook?currentHook.memoizedState:null)!==dispatcher&&(currentlyRenderingFiber.flags|=1024);return maybeThenable;}function checkDidRenderIdHook(){var didRenderIdHook=0!==localIdCounter;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;workInProgress.flags&=-2053;current.lanes&=~lanes;}function resetHooksOnUnwind(workInProgress){if(didScheduleRenderPhaseUpdate){for(workInProgress=workInProgress.memoizedState;null!==workInProgress;){var queue=workInProgress.queue;null!==queue&&(queue.pending=null);workInProgress=workInProgress.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=0;workInProgressHook=currentHook=currentlyRenderingFiber=null;didScheduleRenderPhaseUpdateDuringThisPass=false;thenableIndexCounter=localIdCounter=0;thenableState=null;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===workInProgressHook?currentlyRenderingFiber.memoizedState=workInProgressHook=hook:workInProgressHook=workInProgressHook.next=hook;return workInProgressHook;}function updateWorkInProgressHook(){if(null===currentHook){var nextCurrentHook=currentlyRenderingFiber.alternate;nextCurrentHook=null!==nextCurrentHook?nextCurrentHook.memoizedState:null;}else nextCurrentHook=currentHook.next;var nextWorkInProgressHook=null===workInProgressHook?currentlyRenderingFiber.memoizedState:workInProgressHook.next;if(null!==nextWorkInProgressHook)workInProgressHook=nextWorkInProgressHook,currentHook=nextCurrentHook;else {if(null===nextCurrentHook){if(null===currentlyRenderingFiber.alternate)throw Error(formatProdErrorMessage(467));throw Error(formatProdErrorMessage(310));}currentHook=nextCurrentHook;nextCurrentHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};null===workInProgressHook?currentlyRenderingFiber.memoizedState=workInProgressHook=nextCurrentHook:workInProgressHook=workInProgressHook.next=nextCurrentHook;}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return {lastEffect:null,events:null,stores:null,memoCache:null};}function useThenable(thenable){var index=thenableIndexCounter;thenableIndexCounter+=1;null===thenableState&&(thenableState=[]);thenable=trackUsedThenable(thenableState,thenable,index);index=currentlyRenderingFiber;null===(null===workInProgressHook?index.memoizedState:workInProgressHook.next)&&(index=index.alternate,ReactSharedInternals.H=null===index||null===index.memoizedState?HooksDispatcherOnMount:HooksDispatcherOnUpdate);return thenable;}function use(usable){if(null!==usable&&"object"===typeof usable){if("function"===typeof usable.then)return useThenable(usable);if(usable.$$typeof===REACT_CONTEXT_TYPE)return readContext(usable);}throw Error(formatProdErrorMessage(438,String(usable)));}function useMemoCache(size){var memoCache=null,updateQueue=currentlyRenderingFiber.updateQueue;null!==updateQueue&&(memoCache=updateQueue.memoCache);if(null==memoCache){var current=currentlyRenderingFiber.alternate;null!==current&&(current=current.updateQueue,null!==current&&(current=current.memoCache,null!=current&&(memoCache={data:current.data.map(function(array){return array.slice();}),index:0})));}null==memoCache&&(memoCache={data:[],index:0});null===updateQueue&&(updateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber.updateQueue=updateQueue);updateQueue.memoCache=memoCache;updateQueue=memoCache.data[memoCache.index];if(void 0===updateQueue)for(updateQueue=memoCache.data[memoCache.index]=Array(size),current=0;current<size;current++)updateQueue[current]=REACT_MEMO_CACHE_SENTINEL;memoCache.index++;return updateQueue;}function basicStateReducer(state,action){return "function"===typeof action?action(state):action;}function updateReducer(reducer){var hook=updateWorkInProgressHook();return updateReducerImpl(hook,currentHook,reducer);}function updateReducerImpl(hook,current,reducer){var queue=hook.queue;if(null===queue)throw Error(formatProdErrorMessage(311));queue.lastRenderedReducer=reducer;var baseQueue=hook.baseQueue,pendingQueue=queue.pending;if(null!==pendingQueue){if(null!==baseQueue){var baseFirst=baseQueue.next;baseQueue.next=pendingQueue.next;pendingQueue.next=baseFirst;}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}pendingQueue=hook.baseState;if(null===baseQueue)hook.memoizedState=pendingQueue;else {current=baseQueue.next;var newBaseQueueFirst=baseFirst=null,newBaseQueueLast=null,update=current,didReadFromEntangledAsyncAction$60=false;do{var updateLane=update.lane&-536870913;if(updateLane!==update.lane?(workInProgressRootRenderLanes&updateLane)===updateLane:(renderLanes&updateLane)===updateLane){var revertLane=update.revertLane;if(0===revertLane)null!==newBaseQueueLast&&(newBaseQueueLast=newBaseQueueLast.next={lane:0,revertLane:0,gesture:null,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null}),updateLane===currentEntangledLane&&(didReadFromEntangledAsyncAction$60=true);else if((renderLanes&revertLane)===revertLane){update=update.next;revertLane===currentEntangledLane&&(didReadFromEntangledAsyncAction$60=true);continue;}else updateLane={lane:0,revertLane:update.revertLane,gesture:null,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null},null===newBaseQueueLast?(newBaseQueueFirst=newBaseQueueLast=updateLane,baseFirst=pendingQueue):newBaseQueueLast=newBaseQueueLast.next=updateLane,currentlyRenderingFiber.lanes|=revertLane,workInProgressRootSkippedLanes|=revertLane;updateLane=update.action;shouldDoubleInvokeUserFnsInHooksDEV&&reducer(pendingQueue,updateLane);pendingQueue=update.hasEagerState?update.eagerState:reducer(pendingQueue,updateLane);}else revertLane={lane:updateLane,revertLane:update.revertLane,gesture:update.gesture,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null},null===newBaseQueueLast?(newBaseQueueFirst=newBaseQueueLast=revertLane,baseFirst=pendingQueue):newBaseQueueLast=newBaseQueueLast.next=revertLane,currentlyRenderingFiber.lanes|=updateLane,workInProgressRootSkippedLanes|=updateLane;update=update.next;}while(null!==update&&update!==current);null===newBaseQueueLast?baseFirst=pendingQueue:newBaseQueueLast.next=newBaseQueueFirst;if(!objectIs(pendingQueue,hook.memoizedState)&&(didReceiveUpdate=true,didReadFromEntangledAsyncAction$60&&(reducer=currentEntangledActionThenable,null!==reducer)))throw reducer;hook.memoizedState=pendingQueue;hook.baseState=baseFirst;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=pendingQueue;}null===baseQueue&&(queue.lanes=0);return [hook.memoizedState,queue.dispatch];}function rerenderReducer(reducer){var hook=updateWorkInProgressHook(),queue=hook.queue;if(null===queue)throw Error(formatProdErrorMessage(311));queue.lastRenderedReducer=reducer;var dispatch=queue.dispatch,lastRenderPhaseUpdate=queue.pending,newState=hook.memoizedState;if(null!==lastRenderPhaseUpdate){queue.pending=null;var update=lastRenderPhaseUpdate=lastRenderPhaseUpdate.next;do newState=reducer(newState,update.action),update=update.next;while(update!==lastRenderPhaseUpdate);objectIs(newState,hook.memoizedState)||(didReceiveUpdate=true);hook.memoizedState=newState;null===hook.baseQueue&&(hook.baseState=newState);queue.lastRenderedState=newState;}return [newState,dispatch];}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber,hook=updateWorkInProgressHook(),isHydrating$jscomp$0=isHydrating;if(isHydrating$jscomp$0){if(void 0===getServerSnapshot)throw Error(formatProdErrorMessage(407));getServerSnapshot=getServerSnapshot();}else getServerSnapshot=getSnapshot();var snapshotChanged=!objectIs((currentHook||hook).memoizedState,getServerSnapshot);snapshotChanged&&(hook.memoizedState=getServerSnapshot,didReceiveUpdate=true);hook=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,hook,subscribe),[subscribe]);if(hook.getSnapshot!==getSnapshot||snapshotChanged||null!==workInProgressHook&&workInProgressHook.memoizedState.tag&1){fiber.flags|=2048;pushSimpleEffect(9,{destroy:void 0},updateStoreInstance.bind(null,fiber,hook,getServerSnapshot,getSnapshot),null);if(null===workInProgressRoot)throw Error(formatProdErrorMessage(349));isHydrating$jscomp$0||0!==(renderLanes&127)||pushStoreConsistencyCheck(fiber,getSnapshot,getServerSnapshot);}return getServerSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=16384;fiber={getSnapshot:getSnapshot,value:renderedSnapshot};getSnapshot=currentlyRenderingFiber.updateQueue;null===getSnapshot?(getSnapshot=createFunctionComponentUpdateQueue(),currentlyRenderingFiber.updateQueue=getSnapshot,getSnapshot.stores=[fiber]):(renderedSnapshot=getSnapshot.stores,null===renderedSnapshot?getSnapshot.stores=[fiber]:renderedSnapshot.push(fiber));}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){inst.value=nextSnapshot;inst.getSnapshot=getSnapshot;checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber);}function subscribeToStore(fiber,inst,subscribe){return subscribe(function(){checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber);});}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;inst=inst.value;try{var nextValue=latestGetSnapshot();return !objectIs(inst,nextValue);}catch(error){return  true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,2);null!==root&&scheduleUpdateOnFiber(root,fiber,2);}function mountStateImpl(initialState){var hook=mountWorkInProgressHook();if("function"===typeof initialState){var initialStateInitializer=initialState;initialState=initialStateInitializer();if(shouldDoubleInvokeUserFnsInHooksDEV){setIsStrictModeForDevtools(true);try{initialStateInitializer();}finally{setIsStrictModeForDevtools(false);}}}hook.memoizedState=hook.baseState=initialState;hook.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};return hook;}function updateOptimisticImpl(hook,current,passthrough,reducer){hook.baseState=passthrough;return updateReducerImpl(hook,currentHook,"function"===typeof reducer?reducer:basicStateReducer);}function dispatchActionState(fiber,actionQueue,setPendingState,setState,payload){if(isRenderPhaseUpdate(fiber))throw Error(formatProdErrorMessage(485));fiber=actionQueue.action;if(null!==fiber){var actionNode={payload:payload,action:fiber,next:null,isTransition:true,status:"pending",value:null,reason:null,listeners:[],then:function(listener){actionNode.listeners.push(listener);}};null!==ReactSharedInternals.T?setPendingState(true):actionNode.isTransition=false;setState(actionNode);setPendingState=actionQueue.pending;null===setPendingState?(actionNode.next=actionQueue.pending=actionNode,runActionStateAction(actionQueue,actionNode)):(actionNode.next=setPendingState.next,actionQueue.pending=setPendingState.next=actionNode);}}function runActionStateAction(actionQueue,node){var action=node.action,payload=node.payload,prevState=actionQueue.state;if(node.isTransition){var prevTransition=ReactSharedInternals.T,currentTransition={};ReactSharedInternals.T=currentTransition;try{var returnValue=action(prevState,payload),onStartTransitionFinish=ReactSharedInternals.S;null!==onStartTransitionFinish&&onStartTransitionFinish(currentTransition,returnValue);handleActionReturnValue(actionQueue,node,returnValue);}catch(error){onActionError(actionQueue,node,error);}finally{null!==prevTransition&&null!==currentTransition.types&&(prevTransition.types=currentTransition.types),ReactSharedInternals.T=prevTransition;}}else try{prevTransition=action(prevState,payload),handleActionReturnValue(actionQueue,node,prevTransition);}catch(error$66){onActionError(actionQueue,node,error$66);}}function handleActionReturnValue(actionQueue,node,returnValue){null!==returnValue&&"object"===typeof returnValue&&"function"===typeof returnValue.then?returnValue.then(function(nextState){onActionSuccess(actionQueue,node,nextState);},function(error){return onActionError(actionQueue,node,error);}):onActionSuccess(actionQueue,node,returnValue);}function onActionSuccess(actionQueue,actionNode,nextState){actionNode.status="fulfilled";actionNode.value=nextState;notifyActionListeners(actionNode);actionQueue.state=nextState;actionNode=actionQueue.pending;null!==actionNode&&(nextState=actionNode.next,nextState===actionNode?actionQueue.pending=null:(nextState=nextState.next,actionNode.next=nextState,runActionStateAction(actionQueue,nextState)));}function onActionError(actionQueue,actionNode,error){var last=actionQueue.pending;actionQueue.pending=null;if(null!==last){last=last.next;do actionNode.status="rejected",actionNode.reason=error,notifyActionListeners(actionNode),actionNode=actionNode.next;while(actionNode!==last);}actionQueue.action=null;}function notifyActionListeners(actionNode){actionNode=actionNode.listeners;for(var i=0;i<actionNode.length;i++)(0, actionNode[i])();}function actionStateReducer(oldState,newState){return newState;}function mountActionState(action,initialStateProp){if(isHydrating){var ssrFormState=workInProgressRoot.formState;if(null!==ssrFormState){a:{var JSCompiler_inline_result=currentlyRenderingFiber;if(isHydrating){if(nextHydratableInstance){b:{var JSCompiler_inline_result$jscomp$0=nextHydratableInstance;for(var inRootOrSingleton=rootOrSingletonContext;8!==JSCompiler_inline_result$jscomp$0.nodeType;){if(!inRootOrSingleton){JSCompiler_inline_result$jscomp$0=null;break b;}JSCompiler_inline_result$jscomp$0=getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);if(null===JSCompiler_inline_result$jscomp$0){JSCompiler_inline_result$jscomp$0=null;break b;}}inRootOrSingleton=JSCompiler_inline_result$jscomp$0.data;JSCompiler_inline_result$jscomp$0="F!"===inRootOrSingleton||"F"===inRootOrSingleton?JSCompiler_inline_result$jscomp$0:null;}if(JSCompiler_inline_result$jscomp$0){nextHydratableInstance=getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);JSCompiler_inline_result="F!"===JSCompiler_inline_result$jscomp$0.data;break a;}}throwOnHydrationMismatch(JSCompiler_inline_result);}JSCompiler_inline_result=false;}JSCompiler_inline_result&&(initialStateProp=ssrFormState[0]);}}ssrFormState=mountWorkInProgressHook();ssrFormState.memoizedState=ssrFormState.baseState=initialStateProp;JSCompiler_inline_result={pending:null,lanes:0,dispatch:null,lastRenderedReducer:actionStateReducer,lastRenderedState:initialStateProp};ssrFormState.queue=JSCompiler_inline_result;ssrFormState=dispatchSetState.bind(null,currentlyRenderingFiber,JSCompiler_inline_result);JSCompiler_inline_result.dispatch=ssrFormState;JSCompiler_inline_result=mountStateImpl(false);inRootOrSingleton=dispatchOptimisticSetState.bind(null,currentlyRenderingFiber,false,JSCompiler_inline_result.queue);JSCompiler_inline_result=mountWorkInProgressHook();JSCompiler_inline_result$jscomp$0={state:initialStateProp,dispatch:null,action:action,pending:null};JSCompiler_inline_result.queue=JSCompiler_inline_result$jscomp$0;ssrFormState=dispatchActionState.bind(null,currentlyRenderingFiber,JSCompiler_inline_result$jscomp$0,inRootOrSingleton,ssrFormState);JSCompiler_inline_result$jscomp$0.dispatch=ssrFormState;JSCompiler_inline_result.memoizedState=action;return [initialStateProp,ssrFormState,false];}function updateActionState(action){var stateHook=updateWorkInProgressHook();return updateActionStateImpl(stateHook,currentHook,action);}function updateActionStateImpl(stateHook,currentStateHook,action){currentStateHook=updateReducerImpl(stateHook,currentStateHook,actionStateReducer)[0];stateHook=updateReducer(basicStateReducer)[0];if("object"===typeof currentStateHook&&null!==currentStateHook&&"function"===typeof currentStateHook.then)try{var state=useThenable(currentStateHook);}catch(x){if(x===SuspenseException)throw SuspenseActionException;throw x;}else state=currentStateHook;currentStateHook=updateWorkInProgressHook();var actionQueue=currentStateHook.queue,dispatch=actionQueue.dispatch;action!==currentStateHook.memoizedState&&(currentlyRenderingFiber.flags|=2048,pushSimpleEffect(9,{destroy:void 0},actionStateActionEffect.bind(null,actionQueue,action),null));return [state,dispatch,stateHook];}function actionStateActionEffect(actionQueue,action){actionQueue.action=action;}function rerenderActionState(action){var stateHook=updateWorkInProgressHook(),currentStateHook=currentHook;if(null!==currentStateHook)return updateActionStateImpl(stateHook,currentStateHook,action);updateWorkInProgressHook();stateHook=stateHook.memoizedState;currentStateHook=updateWorkInProgressHook();var dispatch=currentStateHook.queue.dispatch;currentStateHook.memoizedState=action;return [stateHook,dispatch,false];}function pushSimpleEffect(tag,inst,create,deps){tag={tag:tag,create:create,deps:deps,inst:inst,next:null};inst=currentlyRenderingFiber.updateQueue;null===inst&&(inst=createFunctionComponentUpdateQueue(),currentlyRenderingFiber.updateQueue=inst);create=inst.lastEffect;null===create?inst.lastEffect=tag.next=tag:(deps=create.next,create.next=tag,tag.next=deps,inst.lastEffect=tag);return tag;}function updateRef(){return updateWorkInProgressHook().memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();currentlyRenderingFiber.flags|=fiberFlags;hook.memoizedState=pushSimpleEffect(1|hookFlags,{destroy:void 0},create,void 0===deps?null:deps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();deps=void 0===deps?null:deps;var inst=hook.memoizedState.inst;null!==currentHook&&null!==deps&&areHookInputsEqual(deps,currentHook.memoizedState.deps)?hook.memoizedState=pushSimpleEffect(hookFlags,inst,create,deps):(currentlyRenderingFiber.flags|=fiberFlags,hook.memoizedState=pushSimpleEffect(1|hookFlags,inst,create,deps));}function mountEffect(create,deps){mountEffectImpl(8390656,8,create,deps);}function updateEffect(create,deps){updateEffectImpl(2048,8,create,deps);}function useEffectEventImpl(payload){currentlyRenderingFiber.flags|=4;var componentUpdateQueue=currentlyRenderingFiber.updateQueue;if(null===componentUpdateQueue)componentUpdateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber.updateQueue=componentUpdateQueue,componentUpdateQueue.events=[payload];else {var events=componentUpdateQueue.events;null===events?componentUpdateQueue.events=[payload]:events.push(payload);}}function updateEvent(callback){var ref=updateWorkInProgressHook().memoizedState;useEffectEventImpl({ref:ref,nextImpl:callback});return function(){if(0!==(executionContext&2))throw Error(formatProdErrorMessage(440));return ref.impl.apply(void 0,arguments);};}function updateInsertionEffect(create,deps){return updateEffectImpl(4,2,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(4,4,create,deps);}function imperativeHandleEffect(create,ref){if("function"===typeof ref){create=create();var refCleanup=ref(create);return function(){"function"===typeof refCleanup?refCleanup():ref(null);};}if(null!==ref&&void 0!==ref)return create=create(),ref.current=create,function(){ref.current=null;};}function updateImperativeHandle(ref,create,deps){deps=null!==deps&&void 0!==deps?deps.concat([ref]):null;updateEffectImpl(4,4,imperativeHandleEffect.bind(null,create,ref),deps);}function mountDebugValue(){}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();deps=void 0===deps?null:deps;var prevState=hook.memoizedState;if(null!==deps&&areHookInputsEqual(deps,prevState[1]))return prevState[0];hook.memoizedState=[callback,deps];return callback;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();deps=void 0===deps?null:deps;var prevState=hook.memoizedState;if(null!==deps&&areHookInputsEqual(deps,prevState[1]))return prevState[0];prevState=nextCreate();if(shouldDoubleInvokeUserFnsInHooksDEV){setIsStrictModeForDevtools(true);try{nextCreate();}finally{setIsStrictModeForDevtools(false);}}hook.memoizedState=[prevState,deps];return prevState;}function mountDeferredValueImpl(hook,value,initialValue){if(void 0===initialValue||0!==(renderLanes&1073741824)&&0===(workInProgressRootRenderLanes&261930))return hook.memoizedState=value;hook.memoizedState=initialValue;hook=requestDeferredLane();currentlyRenderingFiber.lanes|=hook;workInProgressRootSkippedLanes|=hook;return initialValue;}function updateDeferredValueImpl(hook,prevValue,value,initialValue){if(objectIs(value,prevValue))return value;if(null!==currentTreeHiddenStackCursor.current)return hook=mountDeferredValueImpl(hook,value,initialValue),objectIs(hook,prevValue)||(didReceiveUpdate=true),hook;if(0===(renderLanes&42)||0!==(renderLanes&1073741824)&&0===(workInProgressRootRenderLanes&261930))return didReceiveUpdate=true,hook.memoizedState=value;hook=requestDeferredLane();currentlyRenderingFiber.lanes|=hook;workInProgressRootSkippedLanes|=hook;return prevValue;}function startTransition(fiber,queue,pendingState,finishedState,callback){var previousPriority=ReactDOMSharedInternals.p;ReactDOMSharedInternals.p=0!==previousPriority&&8>previousPriority?previousPriority:8;var prevTransition=ReactSharedInternals.T,currentTransition={};ReactSharedInternals.T=currentTransition;dispatchOptimisticSetState(fiber,false,queue,pendingState);try{var returnValue=callback(),onStartTransitionFinish=ReactSharedInternals.S;null!==onStartTransitionFinish&&onStartTransitionFinish(currentTransition,returnValue);if(null!==returnValue&&"object"===typeof returnValue&&"function"===typeof returnValue.then){var thenableForFinishedState=chainThenableValue(returnValue,finishedState);dispatchSetStateInternal(fiber,queue,thenableForFinishedState,requestUpdateLane(fiber));}else dispatchSetStateInternal(fiber,queue,finishedState,requestUpdateLane(fiber));}catch(error){dispatchSetStateInternal(fiber,queue,{then:function(){},status:"rejected",reason:error},requestUpdateLane());}finally{ReactDOMSharedInternals.p=previousPriority,null!==prevTransition&&null!==currentTransition.types&&(prevTransition.types=currentTransition.types),ReactSharedInternals.T=prevTransition;}}function noop(){}function startHostTransition(formFiber,pendingState,action,formData){if(5!==formFiber.tag)throw Error(formatProdErrorMessage(476));var queue=ensureFormComponentIsStateful(formFiber).queue;startTransition(formFiber,queue,pendingState,sharedNotPendingObject,null===action?noop:function(){requestFormReset$1(formFiber);return action(formData);});}function ensureFormComponentIsStateful(formFiber){var existingStateHook=formFiber.memoizedState;if(null!==existingStateHook)return existingStateHook;existingStateHook={memoizedState:sharedNotPendingObject,baseState:sharedNotPendingObject,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:sharedNotPendingObject},next:null};var initialResetState={};existingStateHook.next={memoizedState:initialResetState,baseState:initialResetState,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialResetState},next:null};formFiber.memoizedState=existingStateHook;formFiber=formFiber.alternate;null!==formFiber&&(formFiber.memoizedState=existingStateHook);return existingStateHook;}function requestFormReset$1(formFiber){var stateHook=ensureFormComponentIsStateful(formFiber);null===stateHook.next&&(stateHook=formFiber.alternate.memoizedState);dispatchSetStateInternal(formFiber,stateHook.next.queue,{},requestUpdateLane());}function useHostTransitionStatus(){return readContext(HostTransitionContext);}function updateId(){return updateWorkInProgressHook().memoizedState;}function updateRefresh(){return updateWorkInProgressHook().memoizedState;}function refreshCache(fiber){for(var provider=fiber.return;null!==provider;){switch(provider.tag){case 24:case 3:var lane=requestUpdateLane();fiber=createUpdate(lane);var root$69=enqueueUpdate(provider,fiber,lane);null!==root$69&&(scheduleUpdateOnFiber(root$69,provider,lane),entangleTransitions(root$69,provider,lane));provider={cache:createCache()};fiber.payload=provider;return;}provider=provider.return;}}function dispatchReducerAction(fiber,queue,action){var lane=requestUpdateLane();action={lane:lane,revertLane:0,gesture:null,action:action,hasEagerState:false,eagerState:null,next:null};isRenderPhaseUpdate(fiber)?enqueueRenderPhaseUpdate(queue,action):(action=enqueueConcurrentHookUpdate(fiber,queue,action,lane),null!==action&&(scheduleUpdateOnFiber(action,fiber,lane),entangleTransitionUpdate(action,queue,lane)));}function dispatchSetState(fiber,queue,action){var lane=requestUpdateLane();dispatchSetStateInternal(fiber,queue,action,lane);}function dispatchSetStateInternal(fiber,queue,action,lane){var update={lane:lane,revertLane:0,gesture:null,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,update);else {var alternate=fiber.alternate;if(0===fiber.lanes&&(null===alternate||0===alternate.lanes)&&(alternate=queue.lastRenderedReducer,null!==alternate))try{var currentState=queue.lastRenderedState,eagerState=alternate(currentState,action);update.hasEagerState=!0;update.eagerState=eagerState;if(objectIs(eagerState,currentState))return enqueueUpdate$1(fiber,queue,update,0),null===workInProgressRoot&&finishQueueingConcurrentUpdates(),!1;}catch(error){}finally{}action=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(null!==action)return scheduleUpdateOnFiber(action,fiber,lane),entangleTransitionUpdate(action,queue,lane),true;}return  false;}function dispatchOptimisticSetState(fiber,throwIfDuringRender,queue,action){action={lane:2,revertLane:requestTransitionLane(),gesture:null,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){if(throwIfDuringRender)throw Error(formatProdErrorMessage(479));}else throwIfDuringRender=enqueueConcurrentHookUpdate(fiber,queue,action,2),null!==throwIfDuringRender&&scheduleUpdateOnFiber(throwIfDuringRender,fiber,2);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber||null!==alternate&&alternate===currentlyRenderingFiber;}function enqueueRenderPhaseUpdate(queue,update){didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;null===pending?update.next=update:(update.next=pending.next,pending.next=update);queue.pending=update;}function entangleTransitionUpdate(root,queue,lane){if(0!==(lane&4194048)){var queueLanes=queue.lanes;queueLanes&=root.pendingLanes;lane|=queueLanes;queue.lanes=lane;markRootEntangled(root,lane);}}var ContextOnlyDispatcher={readContext:readContext,use:use,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,useHostTransitionStatus:throwInvalidHookError,useFormState:throwInvalidHookError,useActionState:throwInvalidHookError,useOptimistic:throwInvalidHookError,useMemoCache:throwInvalidHookError,useCacheRefresh:throwInvalidHookError};ContextOnlyDispatcher.useEffectEvent=throwInvalidHookError;var HooksDispatcherOnMount={readContext:readContext,use:use,useCallback:function(callback,deps){mountWorkInProgressHook().memoizedState=[callback,void 0===deps?null:deps];return callback;},useContext:readContext,useEffect:mountEffect,useImperativeHandle:function(ref,create,deps){deps=null!==deps&&void 0!==deps?deps.concat([ref]):null;mountEffectImpl(4194308,4,imperativeHandleEffect.bind(null,create,ref),deps);},useLayoutEffect:function(create,deps){return mountEffectImpl(4194308,4,create,deps);},useInsertionEffect:function(create,deps){mountEffectImpl(4,2,create,deps);},useMemo:function(nextCreate,deps){var hook=mountWorkInProgressHook();deps=void 0===deps?null:deps;var nextValue=nextCreate();if(shouldDoubleInvokeUserFnsInHooksDEV){setIsStrictModeForDevtools(true);try{nextCreate();}finally{setIsStrictModeForDevtools(false);}}hook.memoizedState=[nextValue,deps];return nextValue;},useReducer:function(reducer,initialArg,init){var hook=mountWorkInProgressHook();if(void 0!==init){var initialState=init(initialArg);if(shouldDoubleInvokeUserFnsInHooksDEV){setIsStrictModeForDevtools(true);try{init(initialArg);}finally{setIsStrictModeForDevtools(false);}}}else initialState=initialArg;hook.memoizedState=hook.baseState=initialState;reducer={pending:null,lanes:0,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=reducer;reducer=reducer.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber,reducer);return [hook.memoizedState,reducer];},useRef:function(initialValue){var hook=mountWorkInProgressHook();initialValue={current:initialValue};return hook.memoizedState=initialValue;},useState:function(initialState){initialState=mountStateImpl(initialState);var queue=initialState.queue,dispatch=dispatchSetState.bind(null,currentlyRenderingFiber,queue);queue.dispatch=dispatch;return [initialState.memoizedState,dispatch];},useDebugValue:mountDebugValue,useDeferredValue:function(value,initialValue){var hook=mountWorkInProgressHook();return mountDeferredValueImpl(hook,value,initialValue);},useTransition:function(){var stateHook=mountStateImpl(false);stateHook=startTransition.bind(null,currentlyRenderingFiber,stateHook.queue,true,false);mountWorkInProgressHook().memoizedState=stateHook;return [false,stateHook];},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber,hook=mountWorkInProgressHook();if(isHydrating){if(void 0===getServerSnapshot)throw Error(formatProdErrorMessage(407));getServerSnapshot=getServerSnapshot();}else {getServerSnapshot=getSnapshot();if(null===workInProgressRoot)throw Error(formatProdErrorMessage(349));0!==(workInProgressRootRenderLanes&127)||pushStoreConsistencyCheck(fiber,getSnapshot,getServerSnapshot);}hook.memoizedState=getServerSnapshot;var inst={value:getServerSnapshot,getSnapshot:getSnapshot};hook.queue=inst;mountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);fiber.flags|=2048;pushSimpleEffect(9,{destroy:void 0},updateStoreInstance.bind(null,fiber,inst,getServerSnapshot,getSnapshot),null);return getServerSnapshot;},useId:function(){var hook=mountWorkInProgressHook(),identifierPrefix=workInProgressRoot.identifierPrefix;if(isHydrating){var JSCompiler_inline_result=treeContextOverflow;var idWithLeadingBit=treeContextId;JSCompiler_inline_result=(idWithLeadingBit&~(1<<32-clz32(idWithLeadingBit)-1)).toString(32)+JSCompiler_inline_result;identifierPrefix="_"+identifierPrefix+"R_"+JSCompiler_inline_result;JSCompiler_inline_result=localIdCounter++;0<JSCompiler_inline_result&&(identifierPrefix+="H"+JSCompiler_inline_result.toString(32));identifierPrefix+="_";}else JSCompiler_inline_result=globalClientIdCounter++,identifierPrefix="_"+identifierPrefix+"r_"+JSCompiler_inline_result.toString(32)+"_";return hook.memoizedState=identifierPrefix;},useHostTransitionStatus:useHostTransitionStatus,useFormState:mountActionState,useActionState:mountActionState,useOptimistic:function(passthrough){var hook=mountWorkInProgressHook();hook.memoizedState=hook.baseState=passthrough;var queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};hook.queue=queue;hook=dispatchOptimisticSetState.bind(null,currentlyRenderingFiber,true,queue);queue.dispatch=hook;return [passthrough,hook];},useMemoCache:useMemoCache,useCacheRefresh:function(){return mountWorkInProgressHook().memoizedState=refreshCache.bind(null,currentlyRenderingFiber);},useEffectEvent:function(callback){var hook=mountWorkInProgressHook(),ref={impl:callback};hook.memoizedState=ref;return function(){if(0!==(executionContext&2))throw Error(formatProdErrorMessage(440));return ref.impl.apply(void 0,arguments);};}},HooksDispatcherOnUpdate={readContext:readContext,use:use,useCallback:updateCallback,useContext:readContext,useEffect:updateEffect,useImperativeHandle:updateImperativeHandle,useInsertionEffect:updateInsertionEffect,useLayoutEffect:updateLayoutEffect,useMemo:updateMemo,useReducer:updateReducer,useRef:updateRef,useState:function(){return updateReducer(basicStateReducer);},useDebugValue:mountDebugValue,useDeferredValue:function(value,initialValue){var hook=updateWorkInProgressHook();return updateDeferredValueImpl(hook,currentHook.memoizedState,value,initialValue);},useTransition:function(){var booleanOrThenable=updateReducer(basicStateReducer)[0],start=updateWorkInProgressHook().memoizedState;return ["boolean"===typeof booleanOrThenable?booleanOrThenable:useThenable(booleanOrThenable),start];},useSyncExternalStore:updateSyncExternalStore,useId:updateId,useHostTransitionStatus:useHostTransitionStatus,useFormState:updateActionState,useActionState:updateActionState,useOptimistic:function(passthrough,reducer){var hook=updateWorkInProgressHook();return updateOptimisticImpl(hook,currentHook,passthrough,reducer);},useMemoCache:useMemoCache,useCacheRefresh:updateRefresh};HooksDispatcherOnUpdate.useEffectEvent=updateEvent;var HooksDispatcherOnRerender={readContext:readContext,use:use,useCallback:updateCallback,useContext:readContext,useEffect:updateEffect,useImperativeHandle:updateImperativeHandle,useInsertionEffect:updateInsertionEffect,useLayoutEffect:updateLayoutEffect,useMemo:updateMemo,useReducer:rerenderReducer,useRef:updateRef,useState:function(){return rerenderReducer(basicStateReducer);},useDebugValue:mountDebugValue,useDeferredValue:function(value,initialValue){var hook=updateWorkInProgressHook();return null===currentHook?mountDeferredValueImpl(hook,value,initialValue):updateDeferredValueImpl(hook,currentHook.memoizedState,value,initialValue);},useTransition:function(){var booleanOrThenable=rerenderReducer(basicStateReducer)[0],start=updateWorkInProgressHook().memoizedState;return ["boolean"===typeof booleanOrThenable?booleanOrThenable:useThenable(booleanOrThenable),start];},useSyncExternalStore:updateSyncExternalStore,useId:updateId,useHostTransitionStatus:useHostTransitionStatus,useFormState:rerenderActionState,useActionState:rerenderActionState,useOptimistic:function(passthrough,reducer){var hook=updateWorkInProgressHook();if(null!==currentHook)return updateOptimisticImpl(hook,currentHook,passthrough,reducer);hook.baseState=passthrough;return [passthrough,hook.queue.dispatch];},useMemoCache:useMemoCache,useCacheRefresh:updateRefresh};HooksDispatcherOnRerender.useEffectEvent=updateEvent;function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){ctor=workInProgress.memoizedState;getDerivedStateFromProps=getDerivedStateFromProps(nextProps,ctor);getDerivedStateFromProps=null===getDerivedStateFromProps||void 0===getDerivedStateFromProps?ctor:assign({},ctor,getDerivedStateFromProps);workInProgress.memoizedState=getDerivedStateFromProps;0===workInProgress.lanes&&(workInProgress.updateQueue.baseState=getDerivedStateFromProps);}var classComponentUpdater={enqueueSetState:function(inst,payload,callback){inst=inst._reactInternals;var lane=requestUpdateLane(),update=createUpdate(lane);update.payload=payload;void 0!==callback&&null!==callback&&(update.callback=callback);payload=enqueueUpdate(inst,update,lane);null!==payload&&(scheduleUpdateOnFiber(payload,inst,lane),entangleTransitions(payload,inst,lane));},enqueueReplaceState:function(inst,payload,callback){inst=inst._reactInternals;var lane=requestUpdateLane(),update=createUpdate(lane);update.tag=1;update.payload=payload;void 0!==callback&&null!==callback&&(update.callback=callback);payload=enqueueUpdate(inst,update,lane);null!==payload&&(scheduleUpdateOnFiber(payload,inst,lane),entangleTransitions(payload,inst,lane));},enqueueForceUpdate:function(inst,callback){inst=inst._reactInternals;var lane=requestUpdateLane(),update=createUpdate(lane);update.tag=2;void 0!==callback&&null!==callback&&(update.callback=callback);callback=enqueueUpdate(inst,update,lane);null!==callback&&(scheduleUpdateOnFiber(callback,inst,lane),entangleTransitions(callback,inst,lane));}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){workInProgress=workInProgress.stateNode;return "function"===typeof workInProgress.shouldComponentUpdate?workInProgress.shouldComponentUpdate(newProps,newState,nextContext):ctor.prototype&&ctor.prototype.isPureReactComponent?!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState):true;}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){workInProgress=instance.state;"function"===typeof instance.componentWillReceiveProps&&instance.componentWillReceiveProps(newProps,nextContext);"function"===typeof instance.UNSAFE_componentWillReceiveProps&&instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);instance.state!==workInProgress&&classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}function resolveClassComponentProps(Component,baseProps){var newProps=baseProps;if("ref"in baseProps){newProps={};for(var propName in baseProps)"ref"!==propName&&(newProps[propName]=baseProps[propName]);}if(Component=Component.defaultProps){newProps===baseProps&&(newProps=assign({},newProps));for(var propName$73 in Component) void 0===newProps[propName$73]&&(newProps[propName$73]=Component[propName$73]);}return newProps;}function defaultOnUncaughtError(error){reportGlobalError(error);}function defaultOnCaughtError(error){console.error(error);}function defaultOnRecoverableError(error){reportGlobalError(error);}function logUncaughtError(root,errorInfo){try{var onUncaughtError=root.onUncaughtError;onUncaughtError(errorInfo.value,{componentStack:errorInfo.stack});}catch(e$74){setTimeout(function(){throw e$74;});}}function logCaughtError(root,boundary,errorInfo){try{var onCaughtError=root.onCaughtError;onCaughtError(errorInfo.value,{componentStack:errorInfo.stack,errorBoundary:1===boundary.tag?boundary.stateNode:null});}catch(e$75){setTimeout(function(){throw e$75;});}}function createRootErrorUpdate(root,errorInfo,lane){lane=createUpdate(lane);lane.tag=3;lane.payload={element:null};lane.callback=function(){logUncaughtError(root,errorInfo);};return lane;}function createClassErrorUpdate(lane){lane=createUpdate(lane);lane.tag=3;return lane;}function initializeClassErrorUpdate(update,root,fiber,errorInfo){var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if("function"===typeof getDerivedStateFromError){var error=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error);};update.callback=function(){logCaughtError(root,fiber,errorInfo);};}var inst=fiber.stateNode;null!==inst&&"function"===typeof inst.componentDidCatch&&(update.callback=function(){logCaughtError(root,fiber,errorInfo);"function"!==typeof getDerivedStateFromError&&(null===legacyErrorBoundariesThatAlreadyFailed?legacyErrorBoundariesThatAlreadyFailed=new Set([this]):legacyErrorBoundariesThatAlreadyFailed.add(this));var stack=errorInfo.stack;this.componentDidCatch(errorInfo.value,{componentStack:null!==stack?stack:""});});}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){sourceFiber.flags|=32768;if(null!==value&&"object"===typeof value&&"function"===typeof value.then){returnFiber=sourceFiber.alternate;null!==returnFiber&&propagateParentContextChanges(returnFiber,sourceFiber,rootRenderLanes,true);sourceFiber=suspenseHandlerStackCursor.current;if(null!==sourceFiber){switch(sourceFiber.tag){case 31:case 13:return null===shellBoundary?renderDidSuspendDelayIfPossible():null===sourceFiber.alternate&&0===workInProgressRootExitStatus&&(workInProgressRootExitStatus=3),sourceFiber.flags&=-257,sourceFiber.flags|=65536,sourceFiber.lanes=rootRenderLanes,value===noopSuspenseyCommitThenable?sourceFiber.flags|=16384:(returnFiber=sourceFiber.updateQueue,null===returnFiber?sourceFiber.updateQueue=new Set([value]):returnFiber.add(value),attachPingListener(root,value,rootRenderLanes)),false;case 22:return sourceFiber.flags|=65536,value===noopSuspenseyCommitThenable?sourceFiber.flags|=16384:(returnFiber=sourceFiber.updateQueue,null===returnFiber?(returnFiber={transitions:null,markerInstances:null,retryQueue:new Set([value])},sourceFiber.updateQueue=returnFiber):(sourceFiber=returnFiber.retryQueue,null===sourceFiber?returnFiber.retryQueue=new Set([value]):sourceFiber.add(value)),attachPingListener(root,value,rootRenderLanes)),false;}throw Error(formatProdErrorMessage(435,sourceFiber.tag));}attachPingListener(root,value,rootRenderLanes);renderDidSuspendDelayIfPossible();return  false;}if(isHydrating)return returnFiber=suspenseHandlerStackCursor.current,null!==returnFiber?(0===(returnFiber.flags&65536)&&(returnFiber.flags|=256),returnFiber.flags|=65536,returnFiber.lanes=rootRenderLanes,value!==HydrationMismatchException&&(root=Error(formatProdErrorMessage(422),{cause:value}),queueHydrationError(createCapturedValueAtFiber(root,sourceFiber)))):(value!==HydrationMismatchException&&(returnFiber=Error(formatProdErrorMessage(423),{cause:value}),queueHydrationError(createCapturedValueAtFiber(returnFiber,sourceFiber))),root=root.current.alternate,root.flags|=65536,rootRenderLanes&=-rootRenderLanes,root.lanes|=rootRenderLanes,value=createCapturedValueAtFiber(value,sourceFiber),rootRenderLanes=createRootErrorUpdate(root.stateNode,value,rootRenderLanes),enqueueCapturedUpdate(root,rootRenderLanes),4!==workInProgressRootExitStatus&&(workInProgressRootExitStatus=2)),false;var wrapperError=Error(formatProdErrorMessage(520),{cause:value});wrapperError=createCapturedValueAtFiber(wrapperError,sourceFiber);null===workInProgressRootConcurrentErrors?workInProgressRootConcurrentErrors=[wrapperError]:workInProgressRootConcurrentErrors.push(wrapperError);4!==workInProgressRootExitStatus&&(workInProgressRootExitStatus=2);if(null===returnFiber)return  true;value=createCapturedValueAtFiber(value,sourceFiber);sourceFiber=returnFiber;do{switch(sourceFiber.tag){case 3:return sourceFiber.flags|=65536,root=rootRenderLanes&-rootRenderLanes,sourceFiber.lanes|=root,root=createRootErrorUpdate(sourceFiber.stateNode,value,root),enqueueCapturedUpdate(sourceFiber,root),false;case 1:if(returnFiber=sourceFiber.type,wrapperError=sourceFiber.stateNode,0===(sourceFiber.flags&128)&&("function"===typeof returnFiber.getDerivedStateFromError||null!==wrapperError&&"function"===typeof wrapperError.componentDidCatch&&(null===legacyErrorBoundariesThatAlreadyFailed||!legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))return sourceFiber.flags|=65536,rootRenderLanes&=-rootRenderLanes,sourceFiber.lanes|=rootRenderLanes,rootRenderLanes=createClassErrorUpdate(rootRenderLanes),initializeClassErrorUpdate(rootRenderLanes,root,sourceFiber,value),enqueueCapturedUpdate(sourceFiber,rootRenderLanes),false;}sourceFiber=sourceFiber.return;}while(null!==sourceFiber);return  false;}var SelectiveHydrationException=Error(formatProdErrorMessage(461)),didReceiveUpdate=false;function reconcileChildren(current,workInProgress,nextChildren,renderLanes){workInProgress.child=null===current?mountChildFibers(workInProgress,null,nextChildren,renderLanes):reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){Component=Component.render;var ref=workInProgress.ref;if("ref"in nextProps){var propsWithoutRef={};for(var key in nextProps)"ref"!==key&&(propsWithoutRef[key]=nextProps[key]);}else propsWithoutRef=nextProps;prepareToReadContext(workInProgress);nextProps=renderWithHooks(current,workInProgress,Component,propsWithoutRef,ref,renderLanes);key=checkDidRenderIdHook();if(null!==current&&!didReceiveUpdate)return bailoutHooks(current,workInProgress,renderLanes),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);isHydrating&&key&&pushMaterializedTreeId(workInProgress);workInProgress.flags|=1;reconcileChildren(current,workInProgress,nextProps,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(null===current){var type=Component.type;if("function"===typeof type&&!shouldConstruct(type)&&void 0===type.defaultProps&&null===Component.compare)return workInProgress.tag=15,workInProgress.type=type,updateSimpleMemoComponent(current,workInProgress,type,nextProps,renderLanes);current=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);current.ref=workInProgress.ref;current.return=workInProgress;return workInProgress.child=current;}type=current.child;if(!checkScheduledUpdateOrContext(current,renderLanes)){var prevProps=type.memoizedProps;Component=Component.compare;Component=null!==Component?Component:shallowEqual;if(Component(prevProps,nextProps)&&current.ref===workInProgress.ref)return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}workInProgress.flags|=1;current=createWorkInProgress(type,nextProps);current.ref=workInProgress.ref;current.return=workInProgress;return workInProgress.child=current;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(null!==current){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref)if(didReceiveUpdate=false,workInProgress.pendingProps=nextProps=prevProps,checkScheduledUpdateOrContext(current,renderLanes))0!==(current.flags&131072)&&(didReceiveUpdate=true);else return workInProgress.lanes=current.lanes,bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes,nextProps){var nextChildren=nextProps.children,prevState=null!==current?current.memoizedState:null;null===current&&null===workInProgress.stateNode&&(workInProgress.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null});if("hidden"===nextProps.mode){if(0!==(workInProgress.flags&128)){prevState=null!==prevState?prevState.baseLanes|renderLanes:renderLanes;if(null!==current){nextProps=workInProgress.child=current.child;for(nextChildren=0;null!==nextProps;)nextChildren=nextChildren|nextProps.lanes|nextProps.childLanes,nextProps=nextProps.sibling;nextProps=nextChildren&~prevState;}else nextProps=0,workInProgress.child=null;return deferHiddenOffscreenComponent(current,workInProgress,prevState,renderLanes,nextProps);}if(0!==(renderLanes&536870912))workInProgress.memoizedState={baseLanes:0,cachePool:null},null!==current&&pushTransition(workInProgress,null!==prevState?prevState.cachePool:null),null!==prevState?pushHiddenContext(workInProgress,prevState):reuseHiddenContextOnStack(),pushOffscreenSuspenseHandler(workInProgress);else return nextProps=workInProgress.lanes=536870912,deferHiddenOffscreenComponent(current,workInProgress,null!==prevState?prevState.baseLanes|renderLanes:renderLanes,renderLanes,nextProps);}else null!==prevState?(pushTransition(workInProgress,prevState.cachePool),pushHiddenContext(workInProgress,prevState),reuseSuspenseHandlerOnStack(),workInProgress.memoizedState=null):(null!==current&&pushTransition(workInProgress,null),reuseHiddenContextOnStack(),reuseSuspenseHandlerOnStack());reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function bailoutOffscreenComponent(current,workInProgress){null!==current&&22===current.tag||null!==workInProgress.stateNode||(workInProgress.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null});return workInProgress.sibling;}function deferHiddenOffscreenComponent(current,workInProgress,nextBaseLanes,renderLanes,remainingChildLanes){var JSCompiler_inline_result=peekCacheFromPool();JSCompiler_inline_result=null===JSCompiler_inline_result?null:{parent:CacheContext._currentValue,pool:JSCompiler_inline_result};workInProgress.memoizedState={baseLanes:nextBaseLanes,cachePool:JSCompiler_inline_result};null!==current&&pushTransition(workInProgress,null);reuseHiddenContextOnStack();pushOffscreenSuspenseHandler(workInProgress);null!==current&&propagateParentContextChanges(current,workInProgress,renderLanes,true);workInProgress.childLanes=remainingChildLanes;return null;}function mountActivityChildren(workInProgress,nextProps){nextProps=mountWorkInProgressOffscreenFiber({mode:nextProps.mode,children:nextProps.children},workInProgress.mode);nextProps.ref=workInProgress.ref;workInProgress.child=nextProps;nextProps.return=workInProgress;return nextProps;}function retryActivityComponentWithoutHydrating(current,workInProgress,renderLanes){reconcileChildFibers(workInProgress,current.child,null,renderLanes);current=mountActivityChildren(workInProgress,workInProgress.pendingProps);current.flags|=2;popSuspenseHandler(workInProgress);workInProgress.memoizedState=null;return current;}function updateActivityComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps,didSuspend=0!==(workInProgress.flags&128);workInProgress.flags&=-129;if(null===current){if(isHydrating){if("hidden"===nextProps.mode)return current=mountActivityChildren(workInProgress,nextProps),workInProgress.lanes=536870912,bailoutOffscreenComponent(null,current);pushDehydratedActivitySuspenseHandler(workInProgress);(current=nextHydratableInstance)?(current=canHydrateHydrationBoundary(current,rootOrSingletonContext),current=null!==current&&"&"===current.data?current:null,null!==current&&(workInProgress.memoizedState={dehydrated:current,treeContext:null!==treeContextProvider?{id:treeContextId,overflow:treeContextOverflow}:null,retryLane:536870912,hydrationErrors:null},renderLanes=createFiberFromDehydratedFragment(current),renderLanes.return=workInProgress,workInProgress.child=renderLanes,hydrationParentFiber=workInProgress,nextHydratableInstance=null)):current=null;if(null===current)throw throwOnHydrationMismatch(workInProgress);workInProgress.lanes=536870912;return null;}return mountActivityChildren(workInProgress,nextProps);}var prevState=current.memoizedState;if(null!==prevState){var dehydrated=prevState.dehydrated;pushDehydratedActivitySuspenseHandler(workInProgress);if(didSuspend){if(workInProgress.flags&256)workInProgress.flags&=-257,workInProgress=retryActivityComponentWithoutHydrating(current,workInProgress,renderLanes);else if(null!==workInProgress.memoizedState)workInProgress.child=current.child,workInProgress.flags|=128,workInProgress=null;else throw Error(formatProdErrorMessage(558));}else if(didReceiveUpdate||propagateParentContextChanges(current,workInProgress,renderLanes,false),didSuspend=0!==(renderLanes&current.childLanes),didReceiveUpdate||didSuspend){nextProps=workInProgressRoot;if(null!==nextProps&&(dehydrated=getBumpedLaneForHydration(nextProps,renderLanes),0!==dehydrated&&dehydrated!==prevState.retryLane))throw prevState.retryLane=dehydrated,enqueueConcurrentRenderForLane(current,dehydrated),scheduleUpdateOnFiber(nextProps,current,dehydrated),SelectiveHydrationException;renderDidSuspendDelayIfPossible();workInProgress=retryActivityComponentWithoutHydrating(current,workInProgress,renderLanes);}else current=prevState.treeContext,nextHydratableInstance=getNextHydratable(dehydrated.nextSibling),hydrationParentFiber=workInProgress,isHydrating=true,hydrationErrors=null,rootOrSingletonContext=false,null!==current&&restoreSuspendedTreeContext(workInProgress,current),workInProgress=mountActivityChildren(workInProgress,nextProps),workInProgress.flags|=4096;return workInProgress;}current=createWorkInProgress(current.child,{mode:nextProps.mode,children:nextProps.children});current.ref=workInProgress.ref;workInProgress.child=current;current.return=workInProgress;return current;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(null===ref)null!==current&&null!==current.ref&&(workInProgress.flags|=4194816);else {if("function"!==typeof ref&&"object"!==typeof ref)throw Error(formatProdErrorMessage(284));if(null===current||current.ref!==ref)workInProgress.flags|=4194816;}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){prepareToReadContext(workInProgress);Component=renderWithHooks(current,workInProgress,Component,nextProps,void 0,renderLanes);nextProps=checkDidRenderIdHook();if(null!==current&&!didReceiveUpdate)return bailoutHooks(current,workInProgress,renderLanes),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);isHydrating&&nextProps&&pushMaterializedTreeId(workInProgress);workInProgress.flags|=1;reconcileChildren(current,workInProgress,Component,renderLanes);return workInProgress.child;}function replayFunctionComponent(current,workInProgress,nextProps,Component,secondArg,renderLanes){prepareToReadContext(workInProgress);workInProgress.updateQueue=null;nextProps=renderWithHooksAgain(workInProgress,Component,nextProps,secondArg);finishRenderingHooks(current);Component=checkDidRenderIdHook();if(null!==current&&!didReceiveUpdate)return bailoutHooks(current,workInProgress,renderLanes),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);isHydrating&&Component&&pushMaterializedTreeId(workInProgress);workInProgress.flags|=1;reconcileChildren(current,workInProgress,nextProps,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){prepareToReadContext(workInProgress);if(null===workInProgress.stateNode){var context=emptyContextObject,contextType=Component.contextType;"object"===typeof contextType&&null!==contextType&&(context=readContext(contextType));context=new Component(nextProps,context);workInProgress.memoizedState=null!==context.state&&void 0!==context.state?context.state:null;context.updater=classComponentUpdater;workInProgress.stateNode=context;context._reactInternals=workInProgress;context=workInProgress.stateNode;context.props=nextProps;context.state=workInProgress.memoizedState;context.refs={};initializeUpdateQueue(workInProgress);contextType=Component.contextType;context.context="object"===typeof contextType&&null!==contextType?readContext(contextType):emptyContextObject;context.state=workInProgress.memoizedState;contextType=Component.getDerivedStateFromProps;"function"===typeof contextType&&(applyDerivedStateFromProps(workInProgress,Component,contextType,nextProps),context.state=workInProgress.memoizedState);"function"===typeof Component.getDerivedStateFromProps||"function"===typeof context.getSnapshotBeforeUpdate||"function"!==typeof context.UNSAFE_componentWillMount&&"function"!==typeof context.componentWillMount||(contextType=context.state,"function"===typeof context.componentWillMount&&context.componentWillMount(),"function"===typeof context.UNSAFE_componentWillMount&&context.UNSAFE_componentWillMount(),contextType!==context.state&&classComponentUpdater.enqueueReplaceState(context,context.state,null),processUpdateQueue(workInProgress,nextProps,context,renderLanes),suspendIfUpdateReadFromEntangledAsyncAction(),context.state=workInProgress.memoizedState);"function"===typeof context.componentDidMount&&(workInProgress.flags|=4194308);nextProps=true;}else if(null===current){context=workInProgress.stateNode;var unresolvedOldProps=workInProgress.memoizedProps,oldProps=resolveClassComponentProps(Component,unresolvedOldProps);context.props=oldProps;var oldContext=context.context,contextType$jscomp$0=Component.contextType;contextType=emptyContextObject;"object"===typeof contextType$jscomp$0&&null!==contextType$jscomp$0&&(contextType=readContext(contextType$jscomp$0));var getDerivedStateFromProps=Component.getDerivedStateFromProps;contextType$jscomp$0="function"===typeof getDerivedStateFromProps||"function"===typeof context.getSnapshotBeforeUpdate;unresolvedOldProps=workInProgress.pendingProps!==unresolvedOldProps;contextType$jscomp$0||"function"!==typeof context.UNSAFE_componentWillReceiveProps&&"function"!==typeof context.componentWillReceiveProps||(unresolvedOldProps||oldContext!==contextType)&&callComponentWillReceiveProps(workInProgress,context,nextProps,contextType);hasForceUpdate=false;var oldState=workInProgress.memoizedState;context.state=oldState;processUpdateQueue(workInProgress,nextProps,context,renderLanes);suspendIfUpdateReadFromEntangledAsyncAction();oldContext=workInProgress.memoizedState;unresolvedOldProps||oldState!==oldContext||hasForceUpdate?("function"===typeof getDerivedStateFromProps&&(applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,nextProps),oldContext=workInProgress.memoizedState),(oldProps=hasForceUpdate||checkShouldComponentUpdate(workInProgress,Component,oldProps,nextProps,oldState,oldContext,contextType))?(contextType$jscomp$0||"function"!==typeof context.UNSAFE_componentWillMount&&"function"!==typeof context.componentWillMount||("function"===typeof context.componentWillMount&&context.componentWillMount(),"function"===typeof context.UNSAFE_componentWillMount&&context.UNSAFE_componentWillMount()),"function"===typeof context.componentDidMount&&(workInProgress.flags|=4194308)):("function"===typeof context.componentDidMount&&(workInProgress.flags|=4194308),workInProgress.memoizedProps=nextProps,workInProgress.memoizedState=oldContext),context.props=nextProps,context.state=oldContext,context.context=contextType,nextProps=oldProps):("function"===typeof context.componentDidMount&&(workInProgress.flags|=4194308),nextProps=false);}else {context=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);contextType=workInProgress.memoizedProps;contextType$jscomp$0=resolveClassComponentProps(Component,contextType);context.props=contextType$jscomp$0;getDerivedStateFromProps=workInProgress.pendingProps;oldState=context.context;oldContext=Component.contextType;oldProps=emptyContextObject;"object"===typeof oldContext&&null!==oldContext&&(oldProps=readContext(oldContext));unresolvedOldProps=Component.getDerivedStateFromProps;(oldContext="function"===typeof unresolvedOldProps||"function"===typeof context.getSnapshotBeforeUpdate)||"function"!==typeof context.UNSAFE_componentWillReceiveProps&&"function"!==typeof context.componentWillReceiveProps||(contextType!==getDerivedStateFromProps||oldState!==oldProps)&&callComponentWillReceiveProps(workInProgress,context,nextProps,oldProps);hasForceUpdate=false;oldState=workInProgress.memoizedState;context.state=oldState;processUpdateQueue(workInProgress,nextProps,context,renderLanes);suspendIfUpdateReadFromEntangledAsyncAction();var newState=workInProgress.memoizedState;contextType!==getDerivedStateFromProps||oldState!==newState||hasForceUpdate||null!==current&&null!==current.dependencies&&checkIfContextChanged(current.dependencies)?("function"===typeof unresolvedOldProps&&(applyDerivedStateFromProps(workInProgress,Component,unresolvedOldProps,nextProps),newState=workInProgress.memoizedState),(contextType$jscomp$0=hasForceUpdate||checkShouldComponentUpdate(workInProgress,Component,contextType$jscomp$0,nextProps,oldState,newState,oldProps)||null!==current&&null!==current.dependencies&&checkIfContextChanged(current.dependencies))?(oldContext||"function"!==typeof context.UNSAFE_componentWillUpdate&&"function"!==typeof context.componentWillUpdate||("function"===typeof context.componentWillUpdate&&context.componentWillUpdate(nextProps,newState,oldProps),"function"===typeof context.UNSAFE_componentWillUpdate&&context.UNSAFE_componentWillUpdate(nextProps,newState,oldProps)),"function"===typeof context.componentDidUpdate&&(workInProgress.flags|=4),"function"===typeof context.getSnapshotBeforeUpdate&&(workInProgress.flags|=1024)):("function"!==typeof context.componentDidUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=4),"function"!==typeof context.getSnapshotBeforeUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=1024),workInProgress.memoizedProps=nextProps,workInProgress.memoizedState=newState),context.props=nextProps,context.state=newState,context.context=oldProps,nextProps=contextType$jscomp$0):("function"!==typeof context.componentDidUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=4),"function"!==typeof context.getSnapshotBeforeUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=1024),nextProps=false);}context=nextProps;markRef(current,workInProgress);nextProps=0!==(workInProgress.flags&128);context||nextProps?(context=workInProgress.stateNode,Component=nextProps&&"function"!==typeof Component.getDerivedStateFromError?null:context.render(),workInProgress.flags|=1,null!==current&&nextProps?(workInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes),workInProgress.child=reconcileChildFibers(workInProgress,null,Component,renderLanes)):reconcileChildren(current,workInProgress,Component,renderLanes),workInProgress.memoizedState=context.state,current=workInProgress.child):current=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);return current;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes){resetHydrationState();workInProgress.flags|=256;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function mountSuspenseOffscreenState(renderLanes){return {baseLanes:renderLanes,cachePool:getSuspendedCache()};}function getRemainingWorkInPrimaryTree(current,primaryTreeDidDefer,renderLanes){current=null!==current?current.childLanes&~renderLanes:0;primaryTreeDidDefer&&(current|=workInProgressDeferredLane);return current;}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps,showFallback=false,didSuspend=0!==(workInProgress.flags&128),JSCompiler_temp;(JSCompiler_temp=didSuspend)||(JSCompiler_temp=null!==current&&null===current.memoizedState?false:0!==(suspenseStackCursor.current&2));JSCompiler_temp&&(showFallback=true,workInProgress.flags&=-129);JSCompiler_temp=0!==(workInProgress.flags&32);workInProgress.flags&=-33;if(null===current){if(isHydrating){showFallback?pushPrimaryTreeSuspenseHandler(workInProgress):reuseSuspenseHandlerOnStack();(current=nextHydratableInstance)?(current=canHydrateHydrationBoundary(current,rootOrSingletonContext),current=null!==current&&"&"!==current.data?current:null,null!==current&&(workInProgress.memoizedState={dehydrated:current,treeContext:null!==treeContextProvider?{id:treeContextId,overflow:treeContextOverflow}:null,retryLane:536870912,hydrationErrors:null},renderLanes=createFiberFromDehydratedFragment(current),renderLanes.return=workInProgress,workInProgress.child=renderLanes,hydrationParentFiber=workInProgress,nextHydratableInstance=null)):current=null;if(null===current)throw throwOnHydrationMismatch(workInProgress);isSuspenseInstanceFallback(current)?workInProgress.lanes=32:workInProgress.lanes=536870912;return null;}var nextPrimaryChildren=nextProps.children;nextProps=nextProps.fallback;if(showFallback)return reuseSuspenseHandlerOnStack(),showFallback=workInProgress.mode,nextPrimaryChildren=mountWorkInProgressOffscreenFiber({mode:"hidden",children:nextPrimaryChildren},showFallback),nextProps=createFiberFromFragment(nextProps,showFallback,renderLanes,null),nextPrimaryChildren.return=workInProgress,nextProps.return=workInProgress,nextPrimaryChildren.sibling=nextProps,workInProgress.child=nextPrimaryChildren,nextProps=workInProgress.child,nextProps.memoizedState=mountSuspenseOffscreenState(renderLanes),nextProps.childLanes=getRemainingWorkInPrimaryTree(current,JSCompiler_temp,renderLanes),workInProgress.memoizedState=SUSPENDED_MARKER,bailoutOffscreenComponent(null,nextProps);pushPrimaryTreeSuspenseHandler(workInProgress);return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}var prevState=current.memoizedState;if(null!==prevState&&(nextPrimaryChildren=prevState.dehydrated,null!==nextPrimaryChildren)){if(didSuspend)workInProgress.flags&256?(pushPrimaryTreeSuspenseHandler(workInProgress),workInProgress.flags&=-257,workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes)):null!==workInProgress.memoizedState?(reuseSuspenseHandlerOnStack(),workInProgress.child=current.child,workInProgress.flags|=128,workInProgress=null):(reuseSuspenseHandlerOnStack(),nextPrimaryChildren=nextProps.fallback,showFallback=workInProgress.mode,nextProps=mountWorkInProgressOffscreenFiber({mode:"visible",children:nextProps.children},showFallback),nextPrimaryChildren=createFiberFromFragment(nextPrimaryChildren,showFallback,renderLanes,null),nextPrimaryChildren.flags|=2,nextProps.return=workInProgress,nextPrimaryChildren.return=workInProgress,nextProps.sibling=nextPrimaryChildren,workInProgress.child=nextProps,reconcileChildFibers(workInProgress,current.child,null,renderLanes),nextProps=workInProgress.child,nextProps.memoizedState=mountSuspenseOffscreenState(renderLanes),nextProps.childLanes=getRemainingWorkInPrimaryTree(current,JSCompiler_temp,renderLanes),workInProgress.memoizedState=SUSPENDED_MARKER,workInProgress=bailoutOffscreenComponent(null,nextProps));else if(pushPrimaryTreeSuspenseHandler(workInProgress),isSuspenseInstanceFallback(nextPrimaryChildren)){JSCompiler_temp=nextPrimaryChildren.nextSibling&&nextPrimaryChildren.nextSibling.dataset;if(JSCompiler_temp)var digest=JSCompiler_temp.dgst;JSCompiler_temp=digest;nextProps=Error(formatProdErrorMessage(419));nextProps.stack="";nextProps.digest=JSCompiler_temp;queueHydrationError({value:nextProps,source:null,stack:null});workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes);}else if(didReceiveUpdate||propagateParentContextChanges(current,workInProgress,renderLanes,false),JSCompiler_temp=0!==(renderLanes&current.childLanes),didReceiveUpdate||JSCompiler_temp){JSCompiler_temp=workInProgressRoot;if(null!==JSCompiler_temp&&(nextProps=getBumpedLaneForHydration(JSCompiler_temp,renderLanes),0!==nextProps&&nextProps!==prevState.retryLane))throw prevState.retryLane=nextProps,enqueueConcurrentRenderForLane(current,nextProps),scheduleUpdateOnFiber(JSCompiler_temp,current,nextProps),SelectiveHydrationException;isSuspenseInstancePending(nextPrimaryChildren)||renderDidSuspendDelayIfPossible();workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes);}else isSuspenseInstancePending(nextPrimaryChildren)?(workInProgress.flags|=192,workInProgress.child=current.child,workInProgress=null):(current=prevState.treeContext,nextHydratableInstance=getNextHydratable(nextPrimaryChildren.nextSibling),hydrationParentFiber=workInProgress,isHydrating=true,hydrationErrors=null,rootOrSingletonContext=false,null!==current&&restoreSuspendedTreeContext(workInProgress,current),workInProgress=mountSuspensePrimaryChildren(workInProgress,nextProps.children),workInProgress.flags|=4096);return workInProgress;}if(showFallback)return reuseSuspenseHandlerOnStack(),nextPrimaryChildren=nextProps.fallback,showFallback=workInProgress.mode,prevState=current.child,digest=prevState.sibling,nextProps=createWorkInProgress(prevState,{mode:"hidden",children:nextProps.children}),nextProps.subtreeFlags=prevState.subtreeFlags&65011712,null!==digest?nextPrimaryChildren=createWorkInProgress(digest,nextPrimaryChildren):(nextPrimaryChildren=createFiberFromFragment(nextPrimaryChildren,showFallback,renderLanes,null),nextPrimaryChildren.flags|=2),nextPrimaryChildren.return=workInProgress,nextProps.return=workInProgress,nextProps.sibling=nextPrimaryChildren,workInProgress.child=nextProps,bailoutOffscreenComponent(null,nextProps),nextProps=workInProgress.child,nextPrimaryChildren=current.child.memoizedState,null===nextPrimaryChildren?nextPrimaryChildren=mountSuspenseOffscreenState(renderLanes):(showFallback=nextPrimaryChildren.cachePool,null!==showFallback?(prevState=CacheContext._currentValue,showFallback=showFallback.parent!==prevState?{parent:prevState,pool:prevState}:showFallback):showFallback=getSuspendedCache(),nextPrimaryChildren={baseLanes:nextPrimaryChildren.baseLanes|renderLanes,cachePool:showFallback}),nextProps.memoizedState=nextPrimaryChildren,nextProps.childLanes=getRemainingWorkInPrimaryTree(current,JSCompiler_temp,renderLanes),workInProgress.memoizedState=SUSPENDED_MARKER,bailoutOffscreenComponent(current.child,nextProps);pushPrimaryTreeSuspenseHandler(workInProgress);renderLanes=current.child;current=renderLanes.sibling;renderLanes=createWorkInProgress(renderLanes,{mode:"visible",children:nextProps.children});renderLanes.return=workInProgress;renderLanes.sibling=null;null!==current&&(JSCompiler_temp=workInProgress.deletions,null===JSCompiler_temp?(workInProgress.deletions=[current],workInProgress.flags|=16):JSCompiler_temp.push(current));workInProgress.child=renderLanes;workInProgress.memoizedState=null;return renderLanes;}function mountSuspensePrimaryChildren(workInProgress,primaryChildren){primaryChildren=mountWorkInProgressOffscreenFiber({mode:"visible",children:primaryChildren},workInProgress.mode);primaryChildren.return=workInProgress;return workInProgress.child=primaryChildren;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode){offscreenProps=createFiberImplClass(22,offscreenProps,null,mode);offscreenProps.lanes=0;return offscreenProps;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes){reconcileChildFibers(workInProgress,current.child,null,renderLanes);current=mountSuspensePrimaryChildren(workInProgress,workInProgress.pendingProps.children);current.flags|=2;workInProgress.memoizedState=null;return current;}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes|=renderLanes;var alternate=fiber.alternate;null!==alternate&&(alternate.lanes|=renderLanes);scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode,treeForkCount){var renderState=workInProgress.memoizedState;null===renderState?workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode,treeForkCount:treeForkCount}:(renderState.isBackwards=isBackwards,renderState.rendering=null,renderState.renderingStartTime=0,renderState.last=lastContentRow,renderState.tail=tail,renderState.tailMode=tailMode,renderState.treeForkCount=treeForkCount);}function updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps,revealOrder=nextProps.revealOrder,tailMode=nextProps.tail;nextProps=nextProps.children;var suspenseContext=suspenseStackCursor.current,shouldForceFallback=0!==(suspenseContext&2);shouldForceFallback?(suspenseContext=suspenseContext&1|2,workInProgress.flags|=128):suspenseContext&=1;push(suspenseStackCursor,suspenseContext);reconcileChildren(current,workInProgress,nextProps,renderLanes);nextProps=isHydrating?treeForkCount:0;if(!shouldForceFallback&&null!==current&&0!==(current.flags&128))a:for(current=workInProgress.child;null!==current;){if(13===current.tag)null!==current.memoizedState&&scheduleSuspenseWorkOnFiber(current,renderLanes,workInProgress);else if(19===current.tag)scheduleSuspenseWorkOnFiber(current,renderLanes,workInProgress);else if(null!==current.child){current.child.return=current;current=current.child;continue;}if(current===workInProgress)break a;for(;null===current.sibling;){if(null===current.return||current.return===workInProgress)break a;current=current.return;}current.sibling.return=current.return;current=current.sibling;}switch(revealOrder){case "forwards":renderLanes=workInProgress.child;for(revealOrder=null;null!==renderLanes;)current=renderLanes.alternate,null!==current&&null===findFirstSuspended(current)&&(revealOrder=renderLanes),renderLanes=renderLanes.sibling;renderLanes=revealOrder;null===renderLanes?(revealOrder=workInProgress.child,workInProgress.child=null):(revealOrder=renderLanes.sibling,renderLanes.sibling=null);initSuspenseListRenderState(workInProgress,false,revealOrder,renderLanes,tailMode,nextProps);break;case "backwards":case "unstable_legacy-backwards":renderLanes=null;revealOrder=workInProgress.child;for(workInProgress.child=null;null!==revealOrder;){current=revealOrder.alternate;if(null!==current&&null===findFirstSuspended(current)){workInProgress.child=revealOrder;break;}current=revealOrder.sibling;revealOrder.sibling=renderLanes;renderLanes=revealOrder;revealOrder=current;}initSuspenseListRenderState(workInProgress,true,renderLanes,null,tailMode,nextProps);break;case "together":initSuspenseListRenderState(workInProgress,false,null,null,void 0,nextProps);break;default:workInProgress.memoizedState=null;}return workInProgress.child;}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){null!==current&&(workInProgress.dependencies=current.dependencies);workInProgressRootSkippedLanes|=workInProgress.lanes;if(0===(renderLanes&workInProgress.childLanes))if(null!==current){if(propagateParentContextChanges(current,workInProgress,renderLanes,false),0===(renderLanes&workInProgress.childLanes))return null;}else return null;if(null!==current&&workInProgress.child!==current.child)throw Error(formatProdErrorMessage(153));if(null!==workInProgress.child){current=workInProgress.child;renderLanes=createWorkInProgress(current,current.pendingProps);workInProgress.child=renderLanes;for(renderLanes.return=workInProgress;null!==current.sibling;)current=current.sibling,renderLanes=renderLanes.sibling=createWorkInProgress(current,current.pendingProps),renderLanes.return=workInProgress;renderLanes.sibling=null;}return workInProgress.child;}function checkScheduledUpdateOrContext(current,renderLanes){if(0!==(current.lanes&renderLanes))return  true;current=current.dependencies;return null!==current&&checkIfContextChanged(current)?true:false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){switch(workInProgress.tag){case 3:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);pushProvider(workInProgress,CacheContext,current.memoizedState.cache);resetHydrationState();break;case 27:case 5:pushHostContext(workInProgress);break;case 4:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case 10:pushProvider(workInProgress,workInProgress.type,workInProgress.memoizedProps.value);break;case 31:if(null!==workInProgress.memoizedState)return workInProgress.flags|=128,pushDehydratedActivitySuspenseHandler(workInProgress),null;break;case 13:var state$102=workInProgress.memoizedState;if(null!==state$102){if(null!==state$102.dehydrated)return pushPrimaryTreeSuspenseHandler(workInProgress),workInProgress.flags|=128,null;if(0!==(renderLanes&workInProgress.child.childLanes))return updateSuspenseComponent(current,workInProgress,renderLanes);pushPrimaryTreeSuspenseHandler(workInProgress);current=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);return null!==current?current.sibling:null;}pushPrimaryTreeSuspenseHandler(workInProgress);break;case 19:var didSuspendBefore=0!==(current.flags&128);state$102=0!==(renderLanes&workInProgress.childLanes);state$102||(propagateParentContextChanges(current,workInProgress,renderLanes,false),state$102=0!==(renderLanes&workInProgress.childLanes));if(didSuspendBefore){if(state$102)return updateSuspenseListComponent(current,workInProgress,renderLanes);workInProgress.flags|=128;}didSuspendBefore=workInProgress.memoizedState;null!==didSuspendBefore&&(didSuspendBefore.rendering=null,didSuspendBefore.tail=null,didSuspendBefore.lastEffect=null);push(suspenseStackCursor,suspenseStackCursor.current);if(state$102)break;else return null;case 22:return workInProgress.lanes=0,updateOffscreenComponent(current,workInProgress,renderLanes,workInProgress.pendingProps);case 24:pushProvider(workInProgress,CacheContext,current.memoizedState.cache);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){if(null!==current){if(current.memoizedProps!==workInProgress.pendingProps)didReceiveUpdate=true;else {if(!checkScheduledUpdateOrContext(current,renderLanes)&&0===(workInProgress.flags&128))return didReceiveUpdate=false,attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);didReceiveUpdate=0!==(current.flags&131072)?true:false;}}else didReceiveUpdate=false,isHydrating&&0!==(workInProgress.flags&1048576)&&pushTreeId(workInProgress,treeForkCount,workInProgress.index);workInProgress.lanes=0;switch(workInProgress.tag){case 16:a:{var props=workInProgress.pendingProps;current=resolveLazy(workInProgress.elementType);workInProgress.type=current;if("function"===typeof current)shouldConstruct(current)?(props=resolveClassComponentProps(current,props),workInProgress.tag=1,workInProgress=updateClassComponent(null,workInProgress,current,props,renderLanes)):(workInProgress.tag=0,workInProgress=updateFunctionComponent(null,workInProgress,current,props,renderLanes));else {if(void 0!==current&&null!==current){var $$typeof=current.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){workInProgress.tag=11;workInProgress=updateForwardRef(null,workInProgress,current,props,renderLanes);break a;}else if($$typeof===REACT_MEMO_TYPE){workInProgress.tag=14;workInProgress=updateMemoComponent(null,workInProgress,current,props,renderLanes);break a;}}workInProgress=getComponentNameFromType(current)||current;throw Error(formatProdErrorMessage(306,workInProgress,""));}}return workInProgress;case 0:return updateFunctionComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);case 1:return props=workInProgress.type,$$typeof=resolveClassComponentProps(props,workInProgress.pendingProps),updateClassComponent(current,workInProgress,props,$$typeof,renderLanes);case 3:a:{pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);if(null===current)throw Error(formatProdErrorMessage(387));props=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;$$typeof=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,props,null,renderLanes);var nextState=workInProgress.memoizedState;props=nextState.cache;pushProvider(workInProgress,CacheContext,props);props!==prevState.cache&&propagateContextChanges(workInProgress,[CacheContext],renderLanes,true);suspendIfUpdateReadFromEntangledAsyncAction();props=nextState.element;if(prevState.isDehydrated){if(prevState={element:props,isDehydrated:false,cache:nextState.cache},workInProgress.updateQueue.baseState=prevState,workInProgress.memoizedState=prevState,workInProgress.flags&256){workInProgress=mountHostRootWithoutHydrating(current,workInProgress,props,renderLanes);break a;}else if(props!==$$typeof){$$typeof=createCapturedValueAtFiber(Error(formatProdErrorMessage(424)),workInProgress);queueHydrationError($$typeof);workInProgress=mountHostRootWithoutHydrating(current,workInProgress,props,renderLanes);break a;}else {current=workInProgress.stateNode.containerInfo;switch(current.nodeType){case 9:current=current.body;break;default:current="HTML"===current.nodeName?current.ownerDocument.body:current;}nextHydratableInstance=getNextHydratable(current.firstChild);hydrationParentFiber=workInProgress;isHydrating=true;hydrationErrors=null;rootOrSingletonContext=true;renderLanes=mountChildFibers(workInProgress,null,props,renderLanes);for(workInProgress.child=renderLanes;renderLanes;)renderLanes.flags=renderLanes.flags&-3|4096,renderLanes=renderLanes.sibling;}}else {resetHydrationState();if(props===$$typeof){workInProgress=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);break a;}reconcileChildren(current,workInProgress,props,renderLanes);}workInProgress=workInProgress.child;}return workInProgress;case 26:return markRef(current,workInProgress),null===current?(renderLanes=getResource(workInProgress.type,null,workInProgress.pendingProps,null))?workInProgress.memoizedState=renderLanes:isHydrating||(renderLanes=workInProgress.type,current=workInProgress.pendingProps,props=getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes),props[internalInstanceKey]=workInProgress,props[internalPropsKey]=current,setInitialProperties(props,renderLanes,current),markNodeAsHoistable(props),workInProgress.stateNode=props):workInProgress.memoizedState=getResource(workInProgress.type,current.memoizedProps,workInProgress.pendingProps,current.memoizedState),null;case 27:return pushHostContext(workInProgress),null===current&&isHydrating&&(props=workInProgress.stateNode=resolveSingletonInstance(workInProgress.type,workInProgress.pendingProps,rootInstanceStackCursor.current),hydrationParentFiber=workInProgress,rootOrSingletonContext=true,$$typeof=nextHydratableInstance,isSingletonScope(workInProgress.type)?(previousHydratableOnEnteringScopedSingleton=$$typeof,nextHydratableInstance=getNextHydratable(props.firstChild)):nextHydratableInstance=$$typeof),reconcileChildren(current,workInProgress,workInProgress.pendingProps.children,renderLanes),markRef(current,workInProgress),null===current&&(workInProgress.flags|=4194304),workInProgress.child;case 5:if(null===current&&isHydrating){if($$typeof=props=nextHydratableInstance)props=canHydrateInstance(props,workInProgress.type,workInProgress.pendingProps,rootOrSingletonContext),null!==props?(workInProgress.stateNode=props,hydrationParentFiber=workInProgress,nextHydratableInstance=getNextHydratable(props.firstChild),rootOrSingletonContext=false,$$typeof=true):$$typeof=false;$$typeof||throwOnHydrationMismatch(workInProgress);}pushHostContext(workInProgress);$$typeof=workInProgress.type;prevState=workInProgress.pendingProps;nextState=null!==current?current.memoizedProps:null;props=prevState.children;shouldSetTextContent($$typeof,prevState)?props=null:null!==nextState&&shouldSetTextContent($$typeof,nextState)&&(workInProgress.flags|=32);null!==workInProgress.memoizedState&&($$typeof=renderWithHooks(current,workInProgress,TransitionAwareHostComponent,null,null,renderLanes),HostTransitionContext._currentValue=$$typeof);markRef(current,workInProgress);reconcileChildren(current,workInProgress,props,renderLanes);return workInProgress.child;case 6:if(null===current&&isHydrating){if(current=renderLanes=nextHydratableInstance)renderLanes=canHydrateTextInstance(renderLanes,workInProgress.pendingProps,rootOrSingletonContext),null!==renderLanes?(workInProgress.stateNode=renderLanes,hydrationParentFiber=workInProgress,nextHydratableInstance=null,current=true):current=false;current||throwOnHydrationMismatch(workInProgress);}return null;case 13:return updateSuspenseComponent(current,workInProgress,renderLanes);case 4:return pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo),props=workInProgress.pendingProps,null===current?workInProgress.child=reconcileChildFibers(workInProgress,null,props,renderLanes):reconcileChildren(current,workInProgress,props,renderLanes),workInProgress.child;case 11:return updateForwardRef(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);case 7:return reconcileChildren(current,workInProgress,workInProgress.pendingProps,renderLanes),workInProgress.child;case 8:return reconcileChildren(current,workInProgress,workInProgress.pendingProps.children,renderLanes),workInProgress.child;case 12:return reconcileChildren(current,workInProgress,workInProgress.pendingProps.children,renderLanes),workInProgress.child;case 10:return props=workInProgress.pendingProps,pushProvider(workInProgress,workInProgress.type,props.value),reconcileChildren(current,workInProgress,props.children,renderLanes),workInProgress.child;case 9:return $$typeof=workInProgress.type._context,props=workInProgress.pendingProps.children,prepareToReadContext(workInProgress),$$typeof=readContext($$typeof),props=props($$typeof),workInProgress.flags|=1,reconcileChildren(current,workInProgress,props,renderLanes),workInProgress.child;case 14:return updateMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);case 15:return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);case 19:return updateSuspenseListComponent(current,workInProgress,renderLanes);case 31:return updateActivityComponent(current,workInProgress,renderLanes);case 22:return updateOffscreenComponent(current,workInProgress,renderLanes,workInProgress.pendingProps);case 24:return prepareToReadContext(workInProgress),props=readContext(CacheContext),null===current?($$typeof=peekCacheFromPool(),null===$$typeof&&($$typeof=workInProgressRoot,prevState=createCache(),$$typeof.pooledCache=prevState,prevState.refCount++,null!==prevState&&($$typeof.pooledCacheLanes|=renderLanes),$$typeof=prevState),workInProgress.memoizedState={parent:props,cache:$$typeof},initializeUpdateQueue(workInProgress),pushProvider(workInProgress,CacheContext,$$typeof)):(0!==(current.lanes&renderLanes)&&(cloneUpdateQueue(current,workInProgress),processUpdateQueue(workInProgress,null,null,renderLanes),suspendIfUpdateReadFromEntangledAsyncAction()),$$typeof=current.memoizedState,prevState=workInProgress.memoizedState,$$typeof.parent!==props?($$typeof={parent:props,cache:props},workInProgress.memoizedState=$$typeof,0===workInProgress.lanes&&(workInProgress.memoizedState=workInProgress.updateQueue.baseState=$$typeof),pushProvider(workInProgress,CacheContext,props)):(props=prevState.cache,pushProvider(workInProgress,CacheContext,props),props!==$$typeof.cache&&propagateContextChanges(workInProgress,[CacheContext],renderLanes,true))),reconcileChildren(current,workInProgress,workInProgress.pendingProps.children,renderLanes),workInProgress.child;case 29:throw workInProgress.pendingProps;}throw Error(formatProdErrorMessage(156,workInProgress.tag));}function markUpdate(workInProgress){workInProgress.flags|=4;}function preloadInstanceAndSuspendIfNeeded(workInProgress,type,oldProps,newProps,renderLanes){if(type=0!==(workInProgress.mode&32))type=false;if(type){if(workInProgress.flags|=16777216,(renderLanes&335544128)===renderLanes)if(workInProgress.stateNode.complete)workInProgress.flags|=8192;else if(shouldRemainOnPreviousScreen())workInProgress.flags|=8192;else throw suspendedThenable=noopSuspenseyCommitThenable,SuspenseyCommitException;}else workInProgress.flags&=-16777217;}function preloadResourceAndSuspendIfNeeded(workInProgress,resource){if("stylesheet"!==resource.type||0!==(resource.state.loading&4))workInProgress.flags&=-16777217;else if(workInProgress.flags|=16777216,!preloadResource(resource))if(shouldRemainOnPreviousScreen())workInProgress.flags|=8192;else throw suspendedThenable=noopSuspenseyCommitThenable,SuspenseyCommitException;}function scheduleRetryEffect(workInProgress,retryQueue){null!==retryQueue&&(workInProgress.flags|=4);workInProgress.flags&16384&&(retryQueue=22!==workInProgress.tag?claimNextRetryLane():536870912,workInProgress.lanes|=retryQueue,workInProgressSuspendedRetryLanes|=retryQueue);}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(!isHydrating)switch(renderState.tailMode){case "hidden":hasRenderedATailFallback=renderState.tail;for(var lastTailNode=null;null!==hasRenderedATailFallback;)null!==hasRenderedATailFallback.alternate&&(lastTailNode=hasRenderedATailFallback),hasRenderedATailFallback=hasRenderedATailFallback.sibling;null===lastTailNode?renderState.tail=null:lastTailNode.sibling=null;break;case "collapsed":lastTailNode=renderState.tail;for(var lastTailNode$106=null;null!==lastTailNode;)null!==lastTailNode.alternate&&(lastTailNode$106=lastTailNode),lastTailNode=lastTailNode.sibling;null===lastTailNode$106?hasRenderedATailFallback||null===renderState.tail?renderState.tail=null:renderState.tail.sibling=null:lastTailNode$106.sibling=null;}}function bubbleProperties(completedWork){var didBailout=null!==completedWork.alternate&&completedWork.alternate.child===completedWork.child,newChildLanes=0,subtreeFlags=0;if(didBailout)for(var child$107=completedWork.child;null!==child$107;)newChildLanes|=child$107.lanes|child$107.childLanes,subtreeFlags|=child$107.subtreeFlags&65011712,subtreeFlags|=child$107.flags&65011712,child$107.return=completedWork,child$107=child$107.sibling;else for(child$107=completedWork.child;null!==child$107;)newChildLanes|=child$107.lanes|child$107.childLanes,subtreeFlags|=child$107.subtreeFlags,subtreeFlags|=child$107.flags,child$107.return=completedWork,child$107=child$107.sibling;completedWork.subtreeFlags|=subtreeFlags;completedWork.childLanes=newChildLanes;return didBailout;}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;popTreeContext(workInProgress);switch(workInProgress.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return bubbleProperties(workInProgress),null;case 1:return bubbleProperties(workInProgress),null;case 3:renderLanes=workInProgress.stateNode;newProps=null;null!==current&&(newProps=current.memoizedState.cache);workInProgress.memoizedState.cache!==newProps&&(workInProgress.flags|=2048);popProvider(CacheContext);popHostContainer();renderLanes.pendingContext&&(renderLanes.context=renderLanes.pendingContext,renderLanes.pendingContext=null);if(null===current||null===current.child)popHydrationState(workInProgress)?markUpdate(workInProgress):null===current||current.memoizedState.isDehydrated&&0===(workInProgress.flags&256)||(workInProgress.flags|=1024,upgradeHydrationErrorsToRecoverable());bubbleProperties(workInProgress);return null;case 26:var type=workInProgress.type,nextResource=workInProgress.memoizedState;null===current?(markUpdate(workInProgress),null!==nextResource?(bubbleProperties(workInProgress),preloadResourceAndSuspendIfNeeded(workInProgress,nextResource)):(bubbleProperties(workInProgress),preloadInstanceAndSuspendIfNeeded(workInProgress,type,null,newProps,renderLanes))):nextResource?nextResource!==current.memoizedState?(markUpdate(workInProgress),bubbleProperties(workInProgress),preloadResourceAndSuspendIfNeeded(workInProgress,nextResource)):(bubbleProperties(workInProgress),workInProgress.flags&=-16777217):(current=current.memoizedProps,current!==newProps&&markUpdate(workInProgress),bubbleProperties(workInProgress),preloadInstanceAndSuspendIfNeeded(workInProgress,type,current,newProps,renderLanes));return null;case 27:popHostContext(workInProgress);renderLanes=rootInstanceStackCursor.current;type=workInProgress.type;if(null!==current&&null!=workInProgress.stateNode)current.memoizedProps!==newProps&&markUpdate(workInProgress);else {if(!newProps){if(null===workInProgress.stateNode)throw Error(formatProdErrorMessage(166));bubbleProperties(workInProgress);return null;}current=contextStackCursor.current;popHydrationState(workInProgress)?prepareToHydrateHostInstance(workInProgress):(current=resolveSingletonInstance(type,newProps,renderLanes),workInProgress.stateNode=current,markUpdate(workInProgress));}bubbleProperties(workInProgress);return null;case 5:popHostContext(workInProgress);type=workInProgress.type;if(null!==current&&null!=workInProgress.stateNode)current.memoizedProps!==newProps&&markUpdate(workInProgress);else {if(!newProps){if(null===workInProgress.stateNode)throw Error(formatProdErrorMessage(166));bubbleProperties(workInProgress);return null;}nextResource=contextStackCursor.current;if(popHydrationState(workInProgress))prepareToHydrateHostInstance(workInProgress);else {var ownerDocument=getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);switch(nextResource){case 1:nextResource=ownerDocument.createElementNS("http://www.w3.org/2000/svg",type);break;case 2:nextResource=ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML",type);break;default:switch(type){case "svg":nextResource=ownerDocument.createElementNS("http://www.w3.org/2000/svg",type);break;case "math":nextResource=ownerDocument.createElementNS("http://www.w3.org/1998/Math/MathML",type);break;case "script":nextResource=ownerDocument.createElement("div");nextResource.innerHTML="<script>\x3c/script>";nextResource=nextResource.removeChild(nextResource.firstChild);break;case "select":nextResource="string"===typeof newProps.is?ownerDocument.createElement("select",{is:newProps.is}):ownerDocument.createElement("select");newProps.multiple?nextResource.multiple=true:newProps.size&&(nextResource.size=newProps.size);break;default:nextResource="string"===typeof newProps.is?ownerDocument.createElement(type,{is:newProps.is}):ownerDocument.createElement(type);}}nextResource[internalInstanceKey]=workInProgress;nextResource[internalPropsKey]=newProps;a:for(ownerDocument=workInProgress.child;null!==ownerDocument;){if(5===ownerDocument.tag||6===ownerDocument.tag)nextResource.appendChild(ownerDocument.stateNode);else if(4!==ownerDocument.tag&&27!==ownerDocument.tag&&null!==ownerDocument.child){ownerDocument.child.return=ownerDocument;ownerDocument=ownerDocument.child;continue;}if(ownerDocument===workInProgress)break a;for(;null===ownerDocument.sibling;){if(null===ownerDocument.return||ownerDocument.return===workInProgress)break a;ownerDocument=ownerDocument.return;}ownerDocument.sibling.return=ownerDocument.return;ownerDocument=ownerDocument.sibling;}workInProgress.stateNode=nextResource;a:switch(setInitialProperties(nextResource,type,newProps),type){case "button":case "input":case "select":case "textarea":newProps=!!newProps.autoFocus;break a;case "img":newProps=true;break a;default:newProps=false;}newProps&&markUpdate(workInProgress);}}bubbleProperties(workInProgress);preloadInstanceAndSuspendIfNeeded(workInProgress,workInProgress.type,null===current?null:current.memoizedProps,workInProgress.pendingProps,renderLanes);return null;case 6:if(current&&null!=workInProgress.stateNode)current.memoizedProps!==newProps&&markUpdate(workInProgress);else {if("string"!==typeof newProps&&null===workInProgress.stateNode)throw Error(formatProdErrorMessage(166));current=rootInstanceStackCursor.current;if(popHydrationState(workInProgress)){current=workInProgress.stateNode;renderLanes=workInProgress.memoizedProps;newProps=null;type=hydrationParentFiber;if(null!==type)switch(type.tag){case 27:case 5:newProps=type.memoizedProps;}current[internalInstanceKey]=workInProgress;current=current.nodeValue===renderLanes||null!==newProps&&true===newProps.suppressHydrationWarning||checkForUnmatchedText(current.nodeValue,renderLanes)?true:false;current||throwOnHydrationMismatch(workInProgress,true);}else current=getOwnerDocumentFromRootContainer(current).createTextNode(newProps),current[internalInstanceKey]=workInProgress,workInProgress.stateNode=current;}bubbleProperties(workInProgress);return null;case 31:renderLanes=workInProgress.memoizedState;if(null===current||null!==current.memoizedState){newProps=popHydrationState(workInProgress);if(null!==renderLanes){if(null===current){if(!newProps)throw Error(formatProdErrorMessage(318));current=workInProgress.memoizedState;current=null!==current?current.dehydrated:null;if(!current)throw Error(formatProdErrorMessage(557));current[internalInstanceKey]=workInProgress;}else resetHydrationState(),0===(workInProgress.flags&128)&&(workInProgress.memoizedState=null),workInProgress.flags|=4;bubbleProperties(workInProgress);current=false;}else renderLanes=upgradeHydrationErrorsToRecoverable(),null!==current&&null!==current.memoizedState&&(current.memoizedState.hydrationErrors=renderLanes),current=true;if(!current){if(workInProgress.flags&256)return popSuspenseHandler(workInProgress),workInProgress;popSuspenseHandler(workInProgress);return null;}if(0!==(workInProgress.flags&128))throw Error(formatProdErrorMessage(558));}bubbleProperties(workInProgress);return null;case 13:newProps=workInProgress.memoizedState;if(null===current||null!==current.memoizedState&&null!==current.memoizedState.dehydrated){type=popHydrationState(workInProgress);if(null!==newProps&&null!==newProps.dehydrated){if(null===current){if(!type)throw Error(formatProdErrorMessage(318));type=workInProgress.memoizedState;type=null!==type?type.dehydrated:null;if(!type)throw Error(formatProdErrorMessage(317));type[internalInstanceKey]=workInProgress;}else resetHydrationState(),0===(workInProgress.flags&128)&&(workInProgress.memoizedState=null),workInProgress.flags|=4;bubbleProperties(workInProgress);type=false;}else type=upgradeHydrationErrorsToRecoverable(),null!==current&&null!==current.memoizedState&&(current.memoizedState.hydrationErrors=type),type=true;if(!type){if(workInProgress.flags&256)return popSuspenseHandler(workInProgress),workInProgress;popSuspenseHandler(workInProgress);return null;}}popSuspenseHandler(workInProgress);if(0!==(workInProgress.flags&128))return workInProgress.lanes=renderLanes,workInProgress;renderLanes=null!==newProps;current=null!==current&&null!==current.memoizedState;renderLanes&&(newProps=workInProgress.child,type=null,null!==newProps.alternate&&null!==newProps.alternate.memoizedState&&null!==newProps.alternate.memoizedState.cachePool&&(type=newProps.alternate.memoizedState.cachePool.pool),nextResource=null,null!==newProps.memoizedState&&null!==newProps.memoizedState.cachePool&&(nextResource=newProps.memoizedState.cachePool.pool),nextResource!==type&&(newProps.flags|=2048));renderLanes!==current&&renderLanes&&(workInProgress.child.flags|=8192);scheduleRetryEffect(workInProgress,workInProgress.updateQueue);bubbleProperties(workInProgress);return null;case 4:return popHostContainer(),null===current&&listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),bubbleProperties(workInProgress),null;case 10:return popProvider(workInProgress.type),bubbleProperties(workInProgress),null;case 19:pop(suspenseStackCursor);newProps=workInProgress.memoizedState;if(null===newProps)return bubbleProperties(workInProgress),null;type=0!==(workInProgress.flags&128);nextResource=newProps.rendering;if(null===nextResource){if(type)cutOffTailIfNeeded(newProps,false);else {if(0!==workInProgressRootExitStatus||null!==current&&0!==(current.flags&128))for(current=workInProgress.child;null!==current;){nextResource=findFirstSuspended(current);if(null!==nextResource){workInProgress.flags|=128;cutOffTailIfNeeded(newProps,false);current=nextResource.updateQueue;workInProgress.updateQueue=current;scheduleRetryEffect(workInProgress,current);workInProgress.subtreeFlags=0;current=renderLanes;for(renderLanes=workInProgress.child;null!==renderLanes;)resetWorkInProgress(renderLanes,current),renderLanes=renderLanes.sibling;push(suspenseStackCursor,suspenseStackCursor.current&1|2);isHydrating&&pushTreeFork(workInProgress,newProps.treeForkCount);return workInProgress.child;}current=current.sibling;}null!==newProps.tail&&now()>workInProgressRootRenderTargetTime&&(workInProgress.flags|=128,type=true,cutOffTailIfNeeded(newProps,false),workInProgress.lanes=4194304);}}else {if(!type)if(current=findFirstSuspended(nextResource),null!==current){if(workInProgress.flags|=128,type=true,current=current.updateQueue,workInProgress.updateQueue=current,scheduleRetryEffect(workInProgress,current),cutOffTailIfNeeded(newProps,true),null===newProps.tail&&"hidden"===newProps.tailMode&&!nextResource.alternate&&!isHydrating)return bubbleProperties(workInProgress),null;}else 2*now()-newProps.renderingStartTime>workInProgressRootRenderTargetTime&&536870912!==renderLanes&&(workInProgress.flags|=128,type=true,cutOffTailIfNeeded(newProps,false),workInProgress.lanes=4194304);newProps.isBackwards?(nextResource.sibling=workInProgress.child,workInProgress.child=nextResource):(current=newProps.last,null!==current?current.sibling=nextResource:workInProgress.child=nextResource,newProps.last=nextResource);}if(null!==newProps.tail)return current=newProps.tail,newProps.rendering=current,newProps.tail=current.sibling,newProps.renderingStartTime=now(),current.sibling=null,renderLanes=suspenseStackCursor.current,push(suspenseStackCursor,type?renderLanes&1|2:renderLanes&1),isHydrating&&pushTreeFork(workInProgress,newProps.treeForkCount),current;bubbleProperties(workInProgress);return null;case 22:case 23:return popSuspenseHandler(workInProgress),popHiddenContext(),newProps=null!==workInProgress.memoizedState,null!==current?null!==current.memoizedState!==newProps&&(workInProgress.flags|=8192):newProps&&(workInProgress.flags|=8192),newProps?0!==(renderLanes&536870912)&&0===(workInProgress.flags&128)&&(bubbleProperties(workInProgress),workInProgress.subtreeFlags&6&&(workInProgress.flags|=8192)):bubbleProperties(workInProgress),renderLanes=workInProgress.updateQueue,null!==renderLanes&&scheduleRetryEffect(workInProgress,renderLanes.retryQueue),renderLanes=null,null!==current&&null!==current.memoizedState&&null!==current.memoizedState.cachePool&&(renderLanes=current.memoizedState.cachePool.pool),newProps=null,null!==workInProgress.memoizedState&&null!==workInProgress.memoizedState.cachePool&&(newProps=workInProgress.memoizedState.cachePool.pool),newProps!==renderLanes&&(workInProgress.flags|=2048),null!==current&&pop(resumedCache),null;case 24:return renderLanes=null,null!==current&&(renderLanes=current.memoizedState.cache),workInProgress.memoizedState.cache!==renderLanes&&(workInProgress.flags|=2048),popProvider(CacheContext),bubbleProperties(workInProgress),null;case 25:return null;case 30:return null;}throw Error(formatProdErrorMessage(156,workInProgress.tag));}function unwindWork(current,workInProgress){popTreeContext(workInProgress);switch(workInProgress.tag){case 1:return current=workInProgress.flags,current&65536?(workInProgress.flags=current&-65537|128,workInProgress):null;case 3:return popProvider(CacheContext),popHostContainer(),current=workInProgress.flags,0!==(current&65536)&&0===(current&128)?(workInProgress.flags=current&-65537|128,workInProgress):null;case 26:case 27:case 5:return popHostContext(workInProgress),null;case 31:if(null!==workInProgress.memoizedState){popSuspenseHandler(workInProgress);if(null===workInProgress.alternate)throw Error(formatProdErrorMessage(340));resetHydrationState();}current=workInProgress.flags;return current&65536?(workInProgress.flags=current&-65537|128,workInProgress):null;case 13:popSuspenseHandler(workInProgress);current=workInProgress.memoizedState;if(null!==current&&null!==current.dehydrated){if(null===workInProgress.alternate)throw Error(formatProdErrorMessage(340));resetHydrationState();}current=workInProgress.flags;return current&65536?(workInProgress.flags=current&-65537|128,workInProgress):null;case 19:return pop(suspenseStackCursor),null;case 4:return popHostContainer(),null;case 10:return popProvider(workInProgress.type),null;case 22:case 23:return popSuspenseHandler(workInProgress),popHiddenContext(),null!==current&&pop(resumedCache),current=workInProgress.flags,current&65536?(workInProgress.flags=current&-65537|128,workInProgress):null;case 24:return popProvider(CacheContext),null;case 25:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork){popTreeContext(interruptedWork);switch(interruptedWork.tag){case 3:popProvider(CacheContext);popHostContainer();break;case 26:case 27:case 5:popHostContext(interruptedWork);break;case 4:popHostContainer();break;case 31:null!==interruptedWork.memoizedState&&popSuspenseHandler(interruptedWork);break;case 13:popSuspenseHandler(interruptedWork);break;case 19:pop(suspenseStackCursor);break;case 10:popProvider(interruptedWork.type);break;case 22:case 23:popSuspenseHandler(interruptedWork);popHiddenContext();null!==current&&pop(resumedCache);break;case 24:popProvider(CacheContext);}}function commitHookEffectListMount(flags,finishedWork){try{var updateQueue=finishedWork.updateQueue,lastEffect=null!==updateQueue?updateQueue.lastEffect:null;if(null!==lastEffect){var firstEffect=lastEffect.next;updateQueue=firstEffect;do{if((updateQueue.tag&flags)===flags){lastEffect=void 0;var create=updateQueue.create,inst=updateQueue.inst;lastEffect=create();inst.destroy=lastEffect;}updateQueue=updateQueue.next;}while(updateQueue!==firstEffect);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor$jscomp$0){try{var updateQueue=finishedWork.updateQueue,lastEffect=null!==updateQueue?updateQueue.lastEffect:null;if(null!==lastEffect){var firstEffect=lastEffect.next;updateQueue=firstEffect;do{if((updateQueue.tag&flags)===flags){var inst=updateQueue.inst,destroy=inst.destroy;if(void 0!==destroy){inst.destroy=void 0;lastEffect=finishedWork;var nearestMountedAncestor=nearestMountedAncestor$jscomp$0,destroy_=destroy;try{destroy_();}catch(error){captureCommitPhaseError(lastEffect,nearestMountedAncestor,error);}}}updateQueue=updateQueue.next;}while(updateQueue!==firstEffect);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}function commitClassCallbacks(finishedWork){var updateQueue=finishedWork.updateQueue;if(null!==updateQueue){var instance=finishedWork.stateNode;try{commitCallbacks(updateQueue,instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}function safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){instance.props=resolveClassComponentProps(current.type,current.memoizedProps);instance.state=current.memoizedState;try{instance.componentWillUnmount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyAttachRef(current,nearestMountedAncestor){try{var ref=current.ref;if(null!==ref){switch(current.tag){case 26:case 27:case 5:var instanceToUse=current.stateNode;break;case 30:instanceToUse=current.stateNode;break;default:instanceToUse=current.stateNode;}"function"===typeof ref?current.refCleanup=ref(instanceToUse):ref.current=instanceToUse;}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref,refCleanup=current.refCleanup;if(null!==ref)if("function"===typeof refCleanup)try{refCleanup();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}finally{current.refCleanup=null,current=current.alternate,null!=current&&(current.refCleanup=null);}else if("function"===typeof ref)try{ref(null);}catch(error$140){captureCommitPhaseError(current,nearestMountedAncestor,error$140);}else ref.current=null;}function commitHostMount(finishedWork){var type=finishedWork.type,props=finishedWork.memoizedProps,instance=finishedWork.stateNode;try{a:switch(type){case "button":case "input":case "select":case "textarea":props.autoFocus&&instance.focus();break a;case "img":props.src?instance.src=props.src:props.srcSet&&(instance.srcset=props.srcSet);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}function commitHostUpdate(finishedWork,newProps,oldProps){try{var domElement=finishedWork.stateNode;updateProperties(domElement,finishedWork.type,oldProps,newProps);domElement[internalPropsKey]=newProps;}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}function isHostParent(fiber){return 5===fiber.tag||3===fiber.tag||26===fiber.tag||27===fiber.tag&&isSingletonScope(fiber.type)||4===fiber.tag;}function getHostSibling(fiber){a:for(;;){for(;null===fiber.sibling;){if(null===fiber.return||isHostParent(fiber.return))return null;fiber=fiber.return;}fiber.sibling.return=fiber.return;for(fiber=fiber.sibling;5!==fiber.tag&&6!==fiber.tag&&18!==fiber.tag;){if(27===fiber.tag&&isSingletonScope(fiber.type))continue a;if(fiber.flags&2)continue a;if(null===fiber.child||4===fiber.tag)continue a;else fiber.child.return=fiber,fiber=fiber.child;}if(!(fiber.flags&2))return fiber.stateNode;}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;if(5===tag||6===tag)node=node.stateNode,before?(9===parent.nodeType?parent.body:"HTML"===parent.nodeName?parent.ownerDocument.body:parent).insertBefore(node,before):(before=9===parent.nodeType?parent.body:"HTML"===parent.nodeName?parent.ownerDocument.body:parent,before.appendChild(node),parent=parent._reactRootContainer,null!==parent&&void 0!==parent||null!==before.onclick||(before.onclick=noop$1));else if(4!==tag&&(27===tag&&isSingletonScope(node.type)&&(parent=node.stateNode,before=null),node=node.child,null!==node))for(insertOrAppendPlacementNodeIntoContainer(node,before,parent),node=node.sibling;null!==node;)insertOrAppendPlacementNodeIntoContainer(node,before,parent),node=node.sibling;}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;if(5===tag||6===tag)node=node.stateNode,before?parent.insertBefore(node,before):parent.appendChild(node);else if(4!==tag&&(27===tag&&isSingletonScope(node.type)&&(parent=node.stateNode),node=node.child,null!==node))for(insertOrAppendPlacementNode(node,before,parent),node=node.sibling;null!==node;)insertOrAppendPlacementNode(node,before,parent),node=node.sibling;}function commitHostSingletonAcquisition(finishedWork){var singleton=finishedWork.stateNode,props=finishedWork.memoizedProps;try{for(var type=finishedWork.type,attributes=singleton.attributes;attributes.length;)singleton.removeAttributeNode(attributes[0]);setInitialProperties(singleton,type,props);singleton[internalInstanceKey]=finishedWork;singleton[internalPropsKey]=props;}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}var offscreenSubtreeIsHidden=false,offscreenSubtreeWasHidden=false,needsFormReset=false,PossiblyWeakSet="function"===typeof WeakSet?WeakSet:Set,nextEffect=null;function commitBeforeMutationEffects(root,firstChild){root=root.containerInfo;eventsEnabled=_enabled;root=getActiveElementDeep(root);if(hasSelectionCapabilities(root)){if("selectionStart"in root)var JSCompiler_temp={start:root.selectionStart,end:root.selectionEnd};else a:{JSCompiler_temp=(JSCompiler_temp=root.ownerDocument)&&JSCompiler_temp.defaultView||window;var selection=JSCompiler_temp.getSelection&&JSCompiler_temp.getSelection();if(selection&&0!==selection.rangeCount){JSCompiler_temp=selection.anchorNode;var anchorOffset=selection.anchorOffset,focusNode=selection.focusNode;selection=selection.focusOffset;try{JSCompiler_temp.nodeType,focusNode.nodeType;}catch(e$20){JSCompiler_temp=null;break a;}var length=0,start=-1,end=-1,indexWithinAnchor=0,indexWithinFocus=0,node=root,parentNode=null;b:for(;;){for(var next;;){node!==JSCompiler_temp||0!==anchorOffset&&3!==node.nodeType||(start=length+anchorOffset);node!==focusNode||0!==selection&&3!==node.nodeType||(end=length+selection);3===node.nodeType&&(length+=node.nodeValue.length);if(null===(next=node.firstChild))break;parentNode=node;node=next;}for(;;){if(node===root)break b;parentNode===JSCompiler_temp&&++indexWithinAnchor===anchorOffset&&(start=length);parentNode===focusNode&&++indexWithinFocus===selection&&(end=length);if(null!==(next=node.nextSibling))break;node=parentNode;parentNode=node.parentNode;}node=next;}JSCompiler_temp=-1===start||-1===end?null:{start:start,end:end};}else JSCompiler_temp=null;}JSCompiler_temp=JSCompiler_temp||{start:0,end:0};}else JSCompiler_temp=null;selectionInformation={focusedElem:root,selectionRange:JSCompiler_temp};_enabled=false;for(nextEffect=firstChild;null!==nextEffect;)if(firstChild=nextEffect,root=firstChild.child,0!==(firstChild.subtreeFlags&1028)&&null!==root)root.return=firstChild,nextEffect=root;else for(;null!==nextEffect;){firstChild=nextEffect;focusNode=firstChild.alternate;root=firstChild.flags;switch(firstChild.tag){case 0:if(0!==(root&4)&&(root=firstChild.updateQueue,root=null!==root?root.events:null,null!==root))for(JSCompiler_temp=0;JSCompiler_temp<root.length;JSCompiler_temp++)anchorOffset=root[JSCompiler_temp],anchorOffset.ref.impl=anchorOffset.nextImpl;break;case 11:case 15:break;case 1:if(0!==(root&1024)&&null!==focusNode){root=void 0;JSCompiler_temp=firstChild;anchorOffset=focusNode.memoizedProps;focusNode=focusNode.memoizedState;selection=JSCompiler_temp.stateNode;try{var resolvedPrevProps=resolveClassComponentProps(JSCompiler_temp.type,anchorOffset);root=selection.getSnapshotBeforeUpdate(resolvedPrevProps,focusNode);selection.__reactInternalSnapshotBeforeUpdate=root;}catch(error){captureCommitPhaseError(JSCompiler_temp,JSCompiler_temp.return,error);}}break;case 3:if(0!==(root&1024))if(root=firstChild.stateNode.containerInfo,JSCompiler_temp=root.nodeType,9===JSCompiler_temp)clearContainerSparingly(root);else if(1===JSCompiler_temp)switch(root.nodeName){case "HEAD":case "HTML":case "BODY":clearContainerSparingly(root);break;default:root.textContent="";}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if(0!==(root&1024))throw Error(formatProdErrorMessage(163));}root=firstChild.sibling;if(null!==root){root.return=firstChild.return;nextEffect=root;break;}nextEffect=firstChild.return;}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork){var flags=finishedWork.flags;switch(finishedWork.tag){case 0:case 11:case 15:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);flags&4&&commitHookEffectListMount(5,finishedWork);break;case 1:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);if(flags&4)if(finishedRoot=finishedWork.stateNode,null===current)try{finishedRoot.componentDidMount();}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}else {var prevProps=resolveClassComponentProps(finishedWork.type,current.memoizedProps);current=current.memoizedState;try{finishedRoot.componentDidUpdate(prevProps,current,finishedRoot.__reactInternalSnapshotBeforeUpdate);}catch(error$139){captureCommitPhaseError(finishedWork,finishedWork.return,error$139);}}flags&64&&commitClassCallbacks(finishedWork);flags&512&&safelyAttachRef(finishedWork,finishedWork.return);break;case 3:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);if(flags&64&&(finishedRoot=finishedWork.updateQueue,null!==finishedRoot)){current=null;if(null!==finishedWork.child)switch(finishedWork.child.tag){case 27:case 5:current=finishedWork.child.stateNode;break;case 1:current=finishedWork.child.stateNode;}try{commitCallbacks(finishedRoot,current);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}break;case 27:null===current&&flags&4&&commitHostSingletonAcquisition(finishedWork);case 26:case 5:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);null===current&&flags&4&&commitHostMount(finishedWork);flags&512&&safelyAttachRef(finishedWork,finishedWork.return);break;case 12:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);break;case 31:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);flags&4&&commitActivityHydrationCallbacks(finishedRoot,finishedWork);break;case 13:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);flags&4&&commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);flags&64&&(finishedRoot=finishedWork.memoizedState,null!==finishedRoot&&(finishedRoot=finishedRoot.dehydrated,null!==finishedRoot&&(finishedWork=retryDehydratedSuspenseBoundary.bind(null,finishedWork),registerSuspenseInstanceRetry(finishedRoot,finishedWork))));break;case 22:flags=null!==finishedWork.memoizedState||offscreenSubtreeIsHidden;if(!flags){current=null!==current&&null!==current.memoizedState||offscreenSubtreeWasHidden;prevProps=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeIsHidden=flags;(offscreenSubtreeWasHidden=current)&&!prevOffscreenSubtreeWasHidden?recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,0!==(finishedWork.subtreeFlags&8772)):recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);offscreenSubtreeIsHidden=prevProps;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}break;case 30:break;default:recursivelyTraverseLayoutEffects(finishedRoot,finishedWork);}}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;null!==alternate&&(fiber.alternate=null,detachFiberAfterEffects(alternate));fiber.child=null;fiber.deletions=null;fiber.sibling=null;5===fiber.tag&&(alternate=fiber.stateNode,null!==alternate&&detachDeletedInstance(alternate));fiber.stateNode=null;fiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;fiber.updateQueue=null;}var hostParent=null,hostParentIsContainer=false;function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){for(parent=parent.child;null!==parent;)commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,parent),parent=parent.sibling;}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){if(injectedHook&&"function"===typeof injectedHook.onCommitFiberUnmount)try{injectedHook.onCommitFiberUnmount(rendererID,deletedFiber);}catch(err){}switch(deletedFiber.tag){case 26:offscreenSubtreeWasHidden||safelyDetachRef(deletedFiber,nearestMountedAncestor);recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);deletedFiber.memoizedState?deletedFiber.memoizedState.count--:deletedFiber.stateNode&&(deletedFiber=deletedFiber.stateNode,deletedFiber.parentNode.removeChild(deletedFiber));break;case 27:offscreenSubtreeWasHidden||safelyDetachRef(deletedFiber,nearestMountedAncestor);var prevHostParent=hostParent,prevHostParentIsContainer=hostParentIsContainer;isSingletonScope(deletedFiber.type)&&(hostParent=deletedFiber.stateNode,hostParentIsContainer=false);recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);releaseSingletonInstance(deletedFiber.stateNode);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;break;case 5:offscreenSubtreeWasHidden||safelyDetachRef(deletedFiber,nearestMountedAncestor);case 6:prevHostParent=hostParent;prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(null!==hostParent)if(hostParentIsContainer)try{(9===hostParent.nodeType?hostParent.body:"HTML"===hostParent.nodeName?hostParent.ownerDocument.body:hostParent).removeChild(deletedFiber.stateNode);}catch(error){captureCommitPhaseError(deletedFiber,nearestMountedAncestor,error);}else try{hostParent.removeChild(deletedFiber.stateNode);}catch(error){captureCommitPhaseError(deletedFiber,nearestMountedAncestor,error);}break;case 18:null!==hostParent&&(hostParentIsContainer?(finishedRoot=hostParent,clearHydrationBoundary(9===finishedRoot.nodeType?finishedRoot.body:"HTML"===finishedRoot.nodeName?finishedRoot.ownerDocument.body:finishedRoot,deletedFiber.stateNode),retryIfBlockedOn(finishedRoot)):clearHydrationBoundary(hostParent,deletedFiber.stateNode));break;case 4:prevHostParent=hostParent;prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;break;case 0:case 11:case 14:case 15:commitHookEffectListUnmount(2,deletedFiber,nearestMountedAncestor);offscreenSubtreeWasHidden||commitHookEffectListUnmount(4,deletedFiber,nearestMountedAncestor);recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);break;case 1:offscreenSubtreeWasHidden||(safelyDetachRef(deletedFiber,nearestMountedAncestor),prevHostParent=deletedFiber.stateNode,"function"===typeof prevHostParent.componentWillUnmount&&safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,prevHostParent));recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);break;case 21:recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);break;case 22:offscreenSubtreeWasHidden=(prevHostParent=offscreenSubtreeWasHidden)||null!==deletedFiber.memoizedState;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevHostParent;break;default:recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}}function commitActivityHydrationCallbacks(finishedRoot,finishedWork){if(null===finishedWork.memoizedState&&(finishedRoot=finishedWork.alternate,null!==finishedRoot&&(finishedRoot=finishedRoot.memoizedState,null!==finishedRoot))){finishedRoot=finishedRoot.dehydrated;try{retryIfBlockedOn(finishedRoot);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){if(null===finishedWork.memoizedState&&(finishedRoot=finishedWork.alternate,null!==finishedRoot&&(finishedRoot=finishedRoot.memoizedState,null!==finishedRoot&&(finishedRoot=finishedRoot.dehydrated,null!==finishedRoot))))try{retryIfBlockedOn(finishedRoot);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}function getRetryCache(finishedWork){switch(finishedWork.tag){case 31:case 13:case 19:var retryCache=finishedWork.stateNode;null===retryCache&&(retryCache=finishedWork.stateNode=new PossiblyWeakSet());return retryCache;case 22:return finishedWork=finishedWork.stateNode,retryCache=finishedWork._retryCache,null===retryCache&&(retryCache=finishedWork._retryCache=new PossiblyWeakSet()),retryCache;default:throw Error(formatProdErrorMessage(435,finishedWork.tag));}}function attachSuspenseRetryListeners(finishedWork,wakeables){var retryCache=getRetryCache(finishedWork);wakeables.forEach(function(wakeable){if(!retryCache.has(wakeable)){retryCache.add(wakeable);var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);wakeable.then(retry,retry);}});}function recursivelyTraverseMutationEffects(root$jscomp$0,parentFiber){var deletions=parentFiber.deletions;if(null!==deletions)for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i],root=root$jscomp$0,returnFiber=parentFiber,parent=returnFiber;a:for(;null!==parent;){switch(parent.tag){case 27:if(isSingletonScope(parent.type)){hostParent=parent.stateNode;hostParentIsContainer=false;break a;}break;case 5:hostParent=parent.stateNode;hostParentIsContainer=false;break a;case 3:case 4:hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break a;}parent=parent.return;}if(null===hostParent)throw Error(formatProdErrorMessage(160));commitDeletionEffectsOnFiber(root,returnFiber,childToDelete);hostParent=null;hostParentIsContainer=false;root=childToDelete.alternate;null!==root&&(root.return=null);childToDelete.return=null;}if(parentFiber.subtreeFlags&13886)for(parentFiber=parentFiber.child;null!==parentFiber;)commitMutationEffectsOnFiber(parentFiber,root$jscomp$0),parentFiber=parentFiber.sibling;}var currentHoistableRoot=null;function commitMutationEffectsOnFiber(finishedWork,root){var current=finishedWork.alternate,flags=finishedWork.flags;switch(finishedWork.tag){case 0:case 11:case 14:case 15:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&4&&(commitHookEffectListUnmount(3,finishedWork,finishedWork.return),commitHookEffectListMount(3,finishedWork),commitHookEffectListUnmount(5,finishedWork,finishedWork.return));break;case 1:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&512&&(offscreenSubtreeWasHidden||null===current||safelyDetachRef(current,current.return));flags&64&&offscreenSubtreeIsHidden&&(finishedWork=finishedWork.updateQueue,null!==finishedWork&&(flags=finishedWork.callbacks,null!==flags&&(current=finishedWork.shared.hiddenCallbacks,finishedWork.shared.hiddenCallbacks=null===current?flags:current.concat(flags))));break;case 26:var hoistableRoot=currentHoistableRoot;recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&512&&(offscreenSubtreeWasHidden||null===current||safelyDetachRef(current,current.return));if(flags&4){var currentResource=null!==current?current.memoizedState:null;flags=finishedWork.memoizedState;if(null===current){if(null===flags){if(null===finishedWork.stateNode){a:{flags=finishedWork.type;current=finishedWork.memoizedProps;hoistableRoot=hoistableRoot.ownerDocument||hoistableRoot;b:switch(flags){case "title":currentResource=hoistableRoot.getElementsByTagName("title")[0];if(!currentResource||currentResource[internalHoistableMarker]||currentResource[internalInstanceKey]||"http://www.w3.org/2000/svg"===currentResource.namespaceURI||currentResource.hasAttribute("itemprop"))currentResource=hoistableRoot.createElement(flags),hoistableRoot.head.insertBefore(currentResource,hoistableRoot.querySelector("head > title"));setInitialProperties(currentResource,flags,current);currentResource[internalInstanceKey]=finishedWork;markNodeAsHoistable(currentResource);flags=currentResource;break a;case "link":var maybeNodes=getHydratableHoistableCache("link","href",hoistableRoot).get(flags+(current.href||""));if(maybeNodes)for(var i=0;i<maybeNodes.length;i++)if(currentResource=maybeNodes[i],currentResource.getAttribute("href")===(null==current.href||""===current.href?null:current.href)&&currentResource.getAttribute("rel")===(null==current.rel?null:current.rel)&&currentResource.getAttribute("title")===(null==current.title?null:current.title)&&currentResource.getAttribute("crossorigin")===(null==current.crossOrigin?null:current.crossOrigin)){maybeNodes.splice(i,1);break b;}currentResource=hoistableRoot.createElement(flags);setInitialProperties(currentResource,flags,current);hoistableRoot.head.appendChild(currentResource);break;case "meta":if(maybeNodes=getHydratableHoistableCache("meta","content",hoistableRoot).get(flags+(current.content||"")))for(i=0;i<maybeNodes.length;i++)if(currentResource=maybeNodes[i],currentResource.getAttribute("content")===(null==current.content?null:""+current.content)&&currentResource.getAttribute("name")===(null==current.name?null:current.name)&&currentResource.getAttribute("property")===(null==current.property?null:current.property)&&currentResource.getAttribute("http-equiv")===(null==current.httpEquiv?null:current.httpEquiv)&&currentResource.getAttribute("charset")===(null==current.charSet?null:current.charSet)){maybeNodes.splice(i,1);break b;}currentResource=hoistableRoot.createElement(flags);setInitialProperties(currentResource,flags,current);hoistableRoot.head.appendChild(currentResource);break;default:throw Error(formatProdErrorMessage(468,flags));}currentResource[internalInstanceKey]=finishedWork;markNodeAsHoistable(currentResource);flags=currentResource;}finishedWork.stateNode=flags;}else mountHoistable(hoistableRoot,finishedWork.type,finishedWork.stateNode);}else finishedWork.stateNode=acquireResource(hoistableRoot,flags,finishedWork.memoizedProps);}else currentResource!==flags?(null===currentResource?null!==current.stateNode&&(current=current.stateNode,current.parentNode.removeChild(current)):currentResource.count--,null===flags?mountHoistable(hoistableRoot,finishedWork.type,finishedWork.stateNode):acquireResource(hoistableRoot,flags,finishedWork.memoizedProps)):null===flags&&null!==finishedWork.stateNode&&commitHostUpdate(finishedWork,finishedWork.memoizedProps,current.memoizedProps);}break;case 27:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&512&&(offscreenSubtreeWasHidden||null===current||safelyDetachRef(current,current.return));null!==current&&flags&4&&commitHostUpdate(finishedWork,finishedWork.memoizedProps,current.memoizedProps);break;case 5:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&512&&(offscreenSubtreeWasHidden||null===current||safelyDetachRef(current,current.return));if(finishedWork.flags&32){hoistableRoot=finishedWork.stateNode;try{setTextContent(hoistableRoot,"");}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}flags&4&&null!=finishedWork.stateNode&&(hoistableRoot=finishedWork.memoizedProps,commitHostUpdate(finishedWork,hoistableRoot,null!==current?current.memoizedProps:hoistableRoot));flags&1024&&(needsFormReset=true);break;case 6:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&4){if(null===finishedWork.stateNode)throw Error(formatProdErrorMessage(162));flags=finishedWork.memoizedProps;current=finishedWork.stateNode;try{current.nodeValue=flags;}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}break;case 3:tagCaches=null;hoistableRoot=currentHoistableRoot;currentHoistableRoot=getHoistableRoot(root.containerInfo);recursivelyTraverseMutationEffects(root,finishedWork);currentHoistableRoot=hoistableRoot;commitReconciliationEffects(finishedWork);if(flags&4&&null!==current&&current.memoizedState.isDehydrated)try{retryIfBlockedOn(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}needsFormReset&&(needsFormReset=false,recursivelyResetForms(finishedWork));break;case 4:flags=currentHoistableRoot;currentHoistableRoot=getHoistableRoot(finishedWork.stateNode.containerInfo);recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);currentHoistableRoot=flags;break;case 12:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);break;case 31:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&4&&(flags=finishedWork.updateQueue,null!==flags&&(finishedWork.updateQueue=null,attachSuspenseRetryListeners(finishedWork,flags)));break;case 13:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);finishedWork.child.flags&8192&&null!==finishedWork.memoizedState!==(null!==current&&null!==current.memoizedState)&&(globalMostRecentFallbackTime=now());flags&4&&(flags=finishedWork.updateQueue,null!==flags&&(finishedWork.updateQueue=null,attachSuspenseRetryListeners(finishedWork,flags)));break;case 22:hoistableRoot=null!==finishedWork.memoizedState;var wasHidden=null!==current&&null!==current.memoizedState,prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden,prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden||hoistableRoot;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;commitReconciliationEffects(finishedWork);if(flags&8192)a:for(root=finishedWork.stateNode,root._visibility=hoistableRoot?root._visibility&-2:root._visibility|1,hoistableRoot&&(null===current||wasHidden||offscreenSubtreeIsHidden||offscreenSubtreeWasHidden||recursivelyTraverseDisappearLayoutEffects(finishedWork)),current=null,root=finishedWork;;){if(5===root.tag||26===root.tag){if(null===current){wasHidden=current=root;try{if(currentResource=wasHidden.stateNode,hoistableRoot)maybeNodes=currentResource.style,"function"===typeof maybeNodes.setProperty?maybeNodes.setProperty("display","none","important"):maybeNodes.display="none";else {i=wasHidden.stateNode;var styleProp=wasHidden.memoizedProps.style,display=void 0!==styleProp&&null!==styleProp&&styleProp.hasOwnProperty("display")?styleProp.display:null;i.style.display=null==display||"boolean"===typeof display?"":(""+display).trim();}}catch(error){captureCommitPhaseError(wasHidden,wasHidden.return,error);}}}else if(6===root.tag){if(null===current){wasHidden=root;try{wasHidden.stateNode.nodeValue=hoistableRoot?"":wasHidden.memoizedProps;}catch(error){captureCommitPhaseError(wasHidden,wasHidden.return,error);}}}else if(18===root.tag){if(null===current){wasHidden=root;try{var instance=wasHidden.stateNode;hoistableRoot?hideOrUnhideDehydratedBoundary(instance,!0):hideOrUnhideDehydratedBoundary(wasHidden.stateNode,!1);}catch(error){captureCommitPhaseError(wasHidden,wasHidden.return,error);}}}else if((22!==root.tag&&23!==root.tag||null===root.memoizedState||root===finishedWork)&&null!==root.child){root.child.return=root;root=root.child;continue;}if(root===finishedWork)break a;for(;null===root.sibling;){if(null===root.return||root.return===finishedWork)break a;current===root&&(current=null);root=root.return;}current===root&&(current=null);root.sibling.return=root.return;root=root.sibling;}flags&4&&(flags=finishedWork.updateQueue,null!==flags&&(current=flags.retryQueue,null!==current&&(flags.retryQueue=null,attachSuspenseRetryListeners(finishedWork,current))));break;case 19:recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);flags&4&&(flags=finishedWork.updateQueue,null!==flags&&(finishedWork.updateQueue=null,attachSuspenseRetryListeners(finishedWork,flags)));break;case 30:break;case 21:break;default:recursivelyTraverseMutationEffects(root,finishedWork),commitReconciliationEffects(finishedWork);}}function commitReconciliationEffects(finishedWork){var flags=finishedWork.flags;if(flags&2){try{for(var hostParentFiber,parentFiber=finishedWork.return;null!==parentFiber;){if(isHostParent(parentFiber)){hostParentFiber=parentFiber;break;}parentFiber=parentFiber.return;}if(null==hostParentFiber)throw Error(formatProdErrorMessage(160));switch(hostParentFiber.tag){case 27:var parent=hostParentFiber.stateNode,before=getHostSibling(finishedWork);insertOrAppendPlacementNode(finishedWork,before,parent);break;case 5:var parent$141=hostParentFiber.stateNode;hostParentFiber.flags&32&&(setTextContent(parent$141,""),hostParentFiber.flags&=-33);var before$142=getHostSibling(finishedWork);insertOrAppendPlacementNode(finishedWork,before$142,parent$141);break;case 3:case 4:var parent$143=hostParentFiber.stateNode.containerInfo,before$144=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,before$144,parent$143);break;default:throw Error(formatProdErrorMessage(161));}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}finishedWork.flags&=-3;}flags&4096&&(finishedWork.flags&=-4097);}function recursivelyResetForms(parentFiber){if(parentFiber.subtreeFlags&1024)for(parentFiber=parentFiber.child;null!==parentFiber;){var fiber=parentFiber;recursivelyResetForms(fiber);5===fiber.tag&&fiber.flags&1024&&fiber.stateNode.reset();parentFiber=parentFiber.sibling;}}function recursivelyTraverseLayoutEffects(root,parentFiber){if(parentFiber.subtreeFlags&8772)for(parentFiber=parentFiber.child;null!==parentFiber;)commitLayoutEffectOnFiber(root,parentFiber.alternate,parentFiber),parentFiber=parentFiber.sibling;}function recursivelyTraverseDisappearLayoutEffects(parentFiber){for(parentFiber=parentFiber.child;null!==parentFiber;){var finishedWork=parentFiber;switch(finishedWork.tag){case 0:case 11:case 14:case 15:commitHookEffectListUnmount(4,finishedWork,finishedWork.return);recursivelyTraverseDisappearLayoutEffects(finishedWork);break;case 1:safelyDetachRef(finishedWork,finishedWork.return);var instance=finishedWork.stateNode;"function"===typeof instance.componentWillUnmount&&safelyCallComponentWillUnmount(finishedWork,finishedWork.return,instance);recursivelyTraverseDisappearLayoutEffects(finishedWork);break;case 27:releaseSingletonInstance(finishedWork.stateNode);case 26:case 5:safelyDetachRef(finishedWork,finishedWork.return);recursivelyTraverseDisappearLayoutEffects(finishedWork);break;case 22:null===finishedWork.memoizedState&&recursivelyTraverseDisappearLayoutEffects(finishedWork);break;case 30:recursivelyTraverseDisappearLayoutEffects(finishedWork);break;default:recursivelyTraverseDisappearLayoutEffects(finishedWork);}parentFiber=parentFiber.sibling;}}function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0,parentFiber,includeWorkInProgressEffects){includeWorkInProgressEffects=includeWorkInProgressEffects&&0!==(parentFiber.subtreeFlags&8772);for(parentFiber=parentFiber.child;null!==parentFiber;){var current=parentFiber.alternate,finishedRoot=finishedRoot$jscomp$0,finishedWork=parentFiber,flags=finishedWork.flags;switch(finishedWork.tag){case 0:case 11:case 15:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);commitHookEffectListMount(4,finishedWork);break;case 1:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);current=finishedWork;finishedRoot=current.stateNode;if("function"===typeof finishedRoot.componentDidMount)try{finishedRoot.componentDidMount();}catch(error){captureCommitPhaseError(current,current.return,error);}current=finishedWork;finishedRoot=current.updateQueue;if(null!==finishedRoot){var instance=current.stateNode;try{var hiddenCallbacks=finishedRoot.shared.hiddenCallbacks;if(null!==hiddenCallbacks)for(finishedRoot.shared.hiddenCallbacks=null,finishedRoot=0;finishedRoot<hiddenCallbacks.length;finishedRoot++)callCallback(hiddenCallbacks[finishedRoot],instance);}catch(error){captureCommitPhaseError(current,current.return,error);}}includeWorkInProgressEffects&&flags&64&&commitClassCallbacks(finishedWork);safelyAttachRef(finishedWork,finishedWork.return);break;case 27:commitHostSingletonAcquisition(finishedWork);case 26:case 5:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);includeWorkInProgressEffects&&null===current&&flags&4&&commitHostMount(finishedWork);safelyAttachRef(finishedWork,finishedWork.return);break;case 12:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);break;case 31:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);includeWorkInProgressEffects&&flags&4&&commitActivityHydrationCallbacks(finishedRoot,finishedWork);break;case 13:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);includeWorkInProgressEffects&&flags&4&&commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;case 22:null===finishedWork.memoizedState&&recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);safelyAttachRef(finishedWork,finishedWork.return);break;case 30:break;default:recursivelyTraverseReappearLayoutEffects(finishedRoot,finishedWork,includeWorkInProgressEffects);}parentFiber=parentFiber.sibling;}}function commitOffscreenPassiveMountEffects(current,finishedWork){var previousCache=null;null!==current&&null!==current.memoizedState&&null!==current.memoizedState.cachePool&&(previousCache=current.memoizedState.cachePool.pool);current=null;null!==finishedWork.memoizedState&&null!==finishedWork.memoizedState.cachePool&&(current=finishedWork.memoizedState.cachePool.pool);current!==previousCache&&(null!=current&&current.refCount++,null!=previousCache&&releaseCache(previousCache));}function commitCachePassiveMountEffect(current,finishedWork){current=null;null!==finishedWork.alternate&&(current=finishedWork.alternate.memoizedState.cache);finishedWork=finishedWork.memoizedState.cache;finishedWork!==current&&(finishedWork.refCount++,null!=current&&releaseCache(current));}function recursivelyTraversePassiveMountEffects(root,parentFiber,committedLanes,committedTransitions){if(parentFiber.subtreeFlags&10256)for(parentFiber=parentFiber.child;null!==parentFiber;)commitPassiveMountOnFiber(root,parentFiber,committedLanes,committedTransitions),parentFiber=parentFiber.sibling;}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){var flags=finishedWork.flags;switch(finishedWork.tag){case 0:case 11:case 15:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);flags&2048&&commitHookEffectListMount(9,finishedWork);break;case 1:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);break;case 3:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);flags&2048&&(finishedRoot=null,null!==finishedWork.alternate&&(finishedRoot=finishedWork.alternate.memoizedState.cache),finishedWork=finishedWork.memoizedState.cache,finishedWork!==finishedRoot&&(finishedWork.refCount++,null!=finishedRoot&&releaseCache(finishedRoot)));break;case 12:if(flags&2048){recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);finishedRoot=finishedWork.stateNode;try{var _finishedWork$memoize2=finishedWork.memoizedProps,id=_finishedWork$memoize2.id,onPostCommit=_finishedWork$memoize2.onPostCommit;"function"===typeof onPostCommit&&onPostCommit(id,null===finishedWork.alternate?"mount":"update",finishedRoot.passiveEffectDuration,-0);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}else recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);break;case 31:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);break;case 13:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);break;case 23:break;case 22:_finishedWork$memoize2=finishedWork.stateNode;id=finishedWork.alternate;null!==finishedWork.memoizedState?_finishedWork$memoize2._visibility&2?recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions):recursivelyTraverseAtomicPassiveEffects(finishedRoot,finishedWork):_finishedWork$memoize2._visibility&2?recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions):(_finishedWork$memoize2._visibility|=2,recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,0!==(finishedWork.subtreeFlags&10256)||false));flags&2048&&commitOffscreenPassiveMountEffects(id,finishedWork);break;case 24:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);flags&2048&&commitCachePassiveMountEffect(finishedWork.alternate,finishedWork);break;default:recursivelyTraversePassiveMountEffects(finishedRoot,finishedWork,committedLanes,committedTransitions);}}function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0,parentFiber,committedLanes$jscomp$0,committedTransitions$jscomp$0,includeWorkInProgressEffects){includeWorkInProgressEffects=includeWorkInProgressEffects&&(0!==(parentFiber.subtreeFlags&10256)||false);for(parentFiber=parentFiber.child;null!==parentFiber;){var finishedRoot=finishedRoot$jscomp$0,finishedWork=parentFiber,committedLanes=committedLanes$jscomp$0,committedTransitions=committedTransitions$jscomp$0,flags=finishedWork.flags;switch(finishedWork.tag){case 0:case 11:case 15:recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,includeWorkInProgressEffects);commitHookEffectListMount(8,finishedWork);break;case 23:break;case 22:var instance=finishedWork.stateNode;null!==finishedWork.memoizedState?instance._visibility&2?recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,includeWorkInProgressEffects):recursivelyTraverseAtomicPassiveEffects(finishedRoot,finishedWork):(instance._visibility|=2,recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,includeWorkInProgressEffects));includeWorkInProgressEffects&&flags&2048&&commitOffscreenPassiveMountEffects(finishedWork.alternate,finishedWork);break;case 24:recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,includeWorkInProgressEffects);includeWorkInProgressEffects&&flags&2048&&commitCachePassiveMountEffect(finishedWork.alternate,finishedWork);break;default:recursivelyTraverseReconnectPassiveEffects(finishedRoot,finishedWork,committedLanes,committedTransitions,includeWorkInProgressEffects);}parentFiber=parentFiber.sibling;}}function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0,parentFiber){if(parentFiber.subtreeFlags&10256)for(parentFiber=parentFiber.child;null!==parentFiber;){var finishedRoot=finishedRoot$jscomp$0,finishedWork=parentFiber,flags=finishedWork.flags;switch(finishedWork.tag){case 22:recursivelyTraverseAtomicPassiveEffects(finishedRoot,finishedWork);flags&2048&&commitOffscreenPassiveMountEffects(finishedWork.alternate,finishedWork);break;case 24:recursivelyTraverseAtomicPassiveEffects(finishedRoot,finishedWork);flags&2048&&commitCachePassiveMountEffect(finishedWork.alternate,finishedWork);break;default:recursivelyTraverseAtomicPassiveEffects(finishedRoot,finishedWork);}parentFiber=parentFiber.sibling;}}var suspenseyCommitFlag=8192;function recursivelyAccumulateSuspenseyCommit(parentFiber,committedLanes,suspendedState){if(parentFiber.subtreeFlags&suspenseyCommitFlag)for(parentFiber=parentFiber.child;null!==parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber,committedLanes,suspendedState),parentFiber=parentFiber.sibling;}function accumulateSuspenseyCommitOnFiber(fiber,committedLanes,suspendedState){switch(fiber.tag){case 26:recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState);fiber.flags&suspenseyCommitFlag&&null!==fiber.memoizedState&&suspendResource(suspendedState,currentHoistableRoot,fiber.memoizedState,fiber.memoizedProps);break;case 5:recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState);break;case 3:case 4:var previousHoistableRoot=currentHoistableRoot;currentHoistableRoot=getHoistableRoot(fiber.stateNode.containerInfo);recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState);currentHoistableRoot=previousHoistableRoot;break;case 22:null===fiber.memoizedState&&(previousHoistableRoot=fiber.alternate,null!==previousHoistableRoot&&null!==previousHoistableRoot.memoizedState?(previousHoistableRoot=suspenseyCommitFlag,suspenseyCommitFlag=16777216,recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState),suspenseyCommitFlag=previousHoistableRoot):recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState));break;default:recursivelyAccumulateSuspenseyCommit(fiber,committedLanes,suspendedState);}}function detachAlternateSiblings(parentFiber){var previousFiber=parentFiber.alternate;if(null!==previousFiber&&(parentFiber=previousFiber.child,null!==parentFiber)){previousFiber.child=null;do previousFiber=parentFiber.sibling,parentFiber.sibling=null,parentFiber=previousFiber;while(null!==parentFiber);}}function recursivelyTraversePassiveUnmountEffects(parentFiber){var deletions=parentFiber.deletions;if(0!==(parentFiber.flags&16)){if(null!==deletions)for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];nextEffect=childToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete,parentFiber);}detachAlternateSiblings(parentFiber);}if(parentFiber.subtreeFlags&10256)for(parentFiber=parentFiber.child;null!==parentFiber;)commitPassiveUnmountOnFiber(parentFiber),parentFiber=parentFiber.sibling;}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case 0:case 11:case 15:recursivelyTraversePassiveUnmountEffects(finishedWork);finishedWork.flags&2048&&commitHookEffectListUnmount(9,finishedWork,finishedWork.return);break;case 3:recursivelyTraversePassiveUnmountEffects(finishedWork);break;case 12:recursivelyTraversePassiveUnmountEffects(finishedWork);break;case 22:var instance=finishedWork.stateNode;null!==finishedWork.memoizedState&&instance._visibility&2&&(null===finishedWork.return||13!==finishedWork.return.tag)?(instance._visibility&=-3,recursivelyTraverseDisconnectPassiveEffects(finishedWork)):recursivelyTraversePassiveUnmountEffects(finishedWork);break;default:recursivelyTraversePassiveUnmountEffects(finishedWork);}}function recursivelyTraverseDisconnectPassiveEffects(parentFiber){var deletions=parentFiber.deletions;if(0!==(parentFiber.flags&16)){if(null!==deletions)for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];nextEffect=childToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete,parentFiber);}detachAlternateSiblings(parentFiber);}for(parentFiber=parentFiber.child;null!==parentFiber;){deletions=parentFiber;switch(deletions.tag){case 0:case 11:case 15:commitHookEffectListUnmount(8,deletions,deletions.return);recursivelyTraverseDisconnectPassiveEffects(deletions);break;case 22:i=deletions.stateNode;i._visibility&2&&(i._visibility&=-3,recursivelyTraverseDisconnectPassiveEffects(deletions));break;default:recursivelyTraverseDisconnectPassiveEffects(deletions);}parentFiber=parentFiber.sibling;}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){for(;null!==nextEffect;){var fiber=nextEffect;switch(fiber.tag){case 0:case 11:case 15:commitHookEffectListUnmount(8,fiber,nearestMountedAncestor);break;case 23:case 22:if(null!==fiber.memoizedState&&null!==fiber.memoizedState.cachePool){var cache=fiber.memoizedState.cachePool.pool;null!=cache&&cache.refCount++;}break;case 24:releaseCache(fiber.memoizedState.cache);}cache=fiber.child;if(null!==cache)cache.return=fiber,nextEffect=cache;else a:for(fiber=deletedSubtreeRoot;null!==nextEffect;){cache=nextEffect;var sibling=cache.sibling,returnFiber=cache.return;detachFiberAfterEffects(cache);if(cache===fiber){nextEffect=null;break a;}if(null!==sibling){sibling.return=returnFiber;nextEffect=sibling;break a;}nextEffect=returnFiber;}}}var DefaultAsyncDispatcher={getCacheForType:function(resourceType){var cache=readContext(CacheContext),cacheForType=cache.data.get(resourceType);void 0===cacheForType&&(cacheForType=resourceType(),cache.data.set(resourceType,cacheForType));return cacheForType;},cacheSignal:function(){return readContext(CacheContext).controller.signal;}},PossiblyWeakMap="function"===typeof WeakMap?WeakMap:Map,executionContext=0,workInProgressRoot=null,workInProgress=null,workInProgressRootRenderLanes=0,workInProgressSuspendedReason=0,workInProgressThrownValue=null,workInProgressRootDidSkipSuspendedSiblings=false,workInProgressRootIsPrerendering=false,workInProgressRootDidAttachPingListener=false,entangledRenderLanes=0,workInProgressRootExitStatus=0,workInProgressRootSkippedLanes=0,workInProgressRootInterleavedUpdatedLanes=0,workInProgressRootPingedLanes=0,workInProgressDeferredLane=0,workInProgressSuspendedRetryLanes=0,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,workInProgressRootDidIncludeRecursiveRenderUpdate=false,globalMostRecentFallbackTime=0,globalMostRecentTransitionTime=0,workInProgressRootRenderTargetTime=Infinity,workInProgressTransitions=null,legacyErrorBoundariesThatAlreadyFailed=null,pendingEffectsStatus=0,pendingEffectsRoot=null,pendingFinishedWork=null,pendingEffectsLanes=0,pendingEffectsRemainingLanes=0,pendingPassiveTransitions=null,pendingRecoverableErrors=null,nestedUpdateCount=0,rootWithNestedUpdates=null;function requestUpdateLane(){return 0!==(executionContext&2)&&0!==workInProgressRootRenderLanes?workInProgressRootRenderLanes&-workInProgressRootRenderLanes:null!==ReactSharedInternals.T?requestTransitionLane():resolveUpdatePriority();}function requestDeferredLane(){if(0===workInProgressDeferredLane)if(0===(workInProgressRootRenderLanes&536870912)||isHydrating){var lane=nextTransitionDeferredLane;nextTransitionDeferredLane<<=1;0===(nextTransitionDeferredLane&3932160)&&(nextTransitionDeferredLane=262144);workInProgressDeferredLane=lane;}else workInProgressDeferredLane=536870912;lane=suspenseHandlerStackCursor.current;null!==lane&&(lane.flags|=32);return workInProgressDeferredLane;}function scheduleUpdateOnFiber(root,fiber,lane){if(root===workInProgressRoot&&(2===workInProgressSuspendedReason||9===workInProgressSuspendedReason)||null!==root.cancelPendingCommit)prepareFreshStack(root,0),markRootSuspended(root,workInProgressRootRenderLanes,workInProgressDeferredLane,false);markRootUpdated$1(root,lane);if(0===(executionContext&2)||root!==workInProgressRoot)root===workInProgressRoot&&(0===(executionContext&2)&&(workInProgressRootInterleavedUpdatedLanes|=lane),4===workInProgressRootExitStatus&&markRootSuspended(root,workInProgressRootRenderLanes,workInProgressDeferredLane,false)),ensureRootIsScheduled(root);}function performWorkOnRoot(root$jscomp$0,lanes,forceSync){if(0!==(executionContext&6))throw Error(formatProdErrorMessage(327));var shouldTimeSlice=!forceSync&&0===(lanes&127)&&0===(lanes&root$jscomp$0.expiredLanes)||checkIfRootIsPrerendering(root$jscomp$0,lanes),exitStatus=shouldTimeSlice?renderRootConcurrent(root$jscomp$0,lanes):renderRootSync(root$jscomp$0,lanes,true),renderWasConcurrent=shouldTimeSlice;do{if(0===exitStatus){workInProgressRootIsPrerendering&&!shouldTimeSlice&&markRootSuspended(root$jscomp$0,lanes,0,false);break;}else {forceSync=root$jscomp$0.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(forceSync)){exitStatus=renderRootSync(root$jscomp$0,lanes,false);renderWasConcurrent=false;continue;}if(2===exitStatus){renderWasConcurrent=lanes;if(root$jscomp$0.errorRecoveryDisabledLanes&renderWasConcurrent)var JSCompiler_inline_result=0;else JSCompiler_inline_result=root$jscomp$0.pendingLanes&-536870913,JSCompiler_inline_result=0!==JSCompiler_inline_result?JSCompiler_inline_result:JSCompiler_inline_result&536870912?536870912:0;if(0!==JSCompiler_inline_result){lanes=JSCompiler_inline_result;a:{var root=root$jscomp$0;exitStatus=workInProgressRootConcurrentErrors;var wasRootDehydrated=root.current.memoizedState.isDehydrated;wasRootDehydrated&&(prepareFreshStack(root,JSCompiler_inline_result).flags|=256);JSCompiler_inline_result=renderRootSync(root,JSCompiler_inline_result,false);if(2!==JSCompiler_inline_result){if(workInProgressRootDidAttachPingListener&&!wasRootDehydrated){root.errorRecoveryDisabledLanes|=renderWasConcurrent;workInProgressRootInterleavedUpdatedLanes|=renderWasConcurrent;exitStatus=4;break a;}renderWasConcurrent=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=exitStatus;null!==renderWasConcurrent&&(null===workInProgressRootRecoverableErrors?workInProgressRootRecoverableErrors=renderWasConcurrent:workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,renderWasConcurrent));}exitStatus=JSCompiler_inline_result;}renderWasConcurrent=false;if(2!==exitStatus)continue;}}if(1===exitStatus){prepareFreshStack(root$jscomp$0,0);markRootSuspended(root$jscomp$0,lanes,0,true);break;}a:{shouldTimeSlice=root$jscomp$0;renderWasConcurrent=exitStatus;switch(renderWasConcurrent){case 0:case 1:throw Error(formatProdErrorMessage(345));case 4:if((lanes&4194048)!==lanes)break;case 6:markRootSuspended(shouldTimeSlice,lanes,workInProgressDeferredLane,!workInProgressRootDidSkipSuspendedSiblings);break a;case 2:workInProgressRootRecoverableErrors=null;break;case 3:case 5:break;default:throw Error(formatProdErrorMessage(329));}if((lanes&62914560)===lanes&&(exitStatus=globalMostRecentFallbackTime+300-now(),10<exitStatus)){markRootSuspended(shouldTimeSlice,lanes,workInProgressDeferredLane,!workInProgressRootDidSkipSuspendedSiblings);if(0!==getNextLanes(shouldTimeSlice,0,true))break a;pendingEffectsLanes=lanes;shouldTimeSlice.timeoutHandle=scheduleTimeout(commitRootWhenReady.bind(null,shouldTimeSlice,forceSync,workInProgressRootRecoverableErrors,workInProgressTransitions,workInProgressRootDidIncludeRecursiveRenderUpdate,lanes,workInProgressDeferredLane,workInProgressRootInterleavedUpdatedLanes,workInProgressSuspendedRetryLanes,workInProgressRootDidSkipSuspendedSiblings,renderWasConcurrent,"Throttled",-0,0),exitStatus);break a;}commitRootWhenReady(shouldTimeSlice,forceSync,workInProgressRootRecoverableErrors,workInProgressTransitions,workInProgressRootDidIncludeRecursiveRenderUpdate,lanes,workInProgressDeferredLane,workInProgressRootInterleavedUpdatedLanes,workInProgressSuspendedRetryLanes,workInProgressRootDidSkipSuspendedSiblings,renderWasConcurrent,null,-0,0);}}break;}while(1);ensureRootIsScheduled(root$jscomp$0);}function commitRootWhenReady(root,finishedWork,recoverableErrors,transitions,didIncludeRenderPhaseUpdate,lanes,spawnedLane,updatedLanes,suspendedRetryLanes,didSkipSuspendedSiblings,exitStatus,suspendedCommitReason,completedRenderStartTime,completedRenderEndTime){root.timeoutHandle=-1;suspendedCommitReason=finishedWork.subtreeFlags;if(suspendedCommitReason&8192||16785408===(suspendedCommitReason&16785408)){suspendedCommitReason={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:true,waitingForViewTransition:false,unsuspend:noop$1};accumulateSuspenseyCommitOnFiber(finishedWork,lanes,suspendedCommitReason);var timeoutOffset=(lanes&62914560)===lanes?globalMostRecentFallbackTime-now():(lanes&4194048)===lanes?globalMostRecentTransitionTime-now():0;timeoutOffset=waitForCommitToBeReady(suspendedCommitReason,timeoutOffset);if(null!==timeoutOffset){pendingEffectsLanes=lanes;root.cancelPendingCommit=timeoutOffset(commitRoot.bind(null,root,finishedWork,lanes,recoverableErrors,transitions,didIncludeRenderPhaseUpdate,spawnedLane,updatedLanes,suspendedRetryLanes,exitStatus,suspendedCommitReason,null,completedRenderStartTime,completedRenderEndTime));markRootSuspended(root,lanes,spawnedLane,!didSkipSuspendedSiblings);return;}}commitRoot(root,finishedWork,lanes,recoverableErrors,transitions,didIncludeRenderPhaseUpdate,spawnedLane,updatedLanes,suspendedRetryLanes);}function isRenderConsistentWithExternalStores(finishedWork){for(var node=finishedWork;;){var tag=node.tag;if((0===tag||11===tag||15===tag)&&node.flags&16384&&(tag=node.updateQueue,null!==tag&&(tag=tag.stores,null!==tag)))for(var i=0;i<tag.length;i++){var check=tag[i],getSnapshot=check.getSnapshot;check=check.value;try{if(!objectIs(getSnapshot(),check))return !1;}catch(error){return  false;}}tag=node.child;if(node.subtreeFlags&16384&&null!==tag)tag.return=node,node=tag;else {if(node===finishedWork)break;for(;null===node.sibling;){if(null===node.return||node.return===finishedWork)return  true;node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return  true;}function markRootSuspended(root,suspendedLanes,spawnedLane,didAttemptEntireTree){suspendedLanes&=~workInProgressRootPingedLanes;suspendedLanes&=~workInProgressRootInterleavedUpdatedLanes;root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;didAttemptEntireTree&&(root.warmLanes|=suspendedLanes);didAttemptEntireTree=root.expirationTimes;for(var lanes=suspendedLanes;0<lanes;){var index$6=31-clz32(lanes),lane=1<<index$6;didAttemptEntireTree[index$6]=-1;lanes&=~lane;}0!==spawnedLane&&markSpawnedDeferredLane(root,spawnedLane,suspendedLanes);}function flushSyncWork$1(){return 0===(executionContext&6)?(flushSyncWorkAcrossRoots_impl(0),false):true;}function resetWorkInProgressStack(){if(null!==workInProgress){if(0===workInProgressSuspendedReason)var interruptedWork=workInProgress.return;else interruptedWork=workInProgress,lastContextDependency=currentlyRenderingFiber$1=null,resetHooksOnUnwind(interruptedWork),thenableState$1=null,thenableIndexCounter$1=0,interruptedWork=workInProgress;for(;null!==interruptedWork;)unwindInterruptedWork(interruptedWork.alternate,interruptedWork),interruptedWork=interruptedWork.return;workInProgress=null;}}function prepareFreshStack(root,lanes){var timeoutHandle=root.timeoutHandle;-1!==timeoutHandle&&(root.timeoutHandle=-1,cancelTimeout(timeoutHandle));timeoutHandle=root.cancelPendingCommit;null!==timeoutHandle&&(root.cancelPendingCommit=null,timeoutHandle());pendingEffectsLanes=0;resetWorkInProgressStack();workInProgressRoot=root;workInProgress=timeoutHandle=createWorkInProgress(root.current,null);workInProgressRootRenderLanes=lanes;workInProgressSuspendedReason=0;workInProgressThrownValue=null;workInProgressRootDidSkipSuspendedSiblings=false;workInProgressRootIsPrerendering=checkIfRootIsPrerendering(root,lanes);workInProgressRootDidAttachPingListener=false;workInProgressSuspendedRetryLanes=workInProgressDeferredLane=workInProgressRootPingedLanes=workInProgressRootInterleavedUpdatedLanes=workInProgressRootSkippedLanes=workInProgressRootExitStatus=0;workInProgressRootRecoverableErrors=workInProgressRootConcurrentErrors=null;workInProgressRootDidIncludeRecursiveRenderUpdate=false;0!==(lanes&8)&&(lanes|=lanes&32);var allEntangledLanes=root.entangledLanes;if(0!==allEntangledLanes)for(root=root.entanglements,allEntangledLanes&=lanes;0<allEntangledLanes;){var index$4=31-clz32(allEntangledLanes),lane=1<<index$4;lanes|=root[index$4];allEntangledLanes&=~lane;}entangledRenderLanes=lanes;finishQueueingConcurrentUpdates();return timeoutHandle;}function handleThrow(root,thrownValue){currentlyRenderingFiber=null;ReactSharedInternals.H=ContextOnlyDispatcher;thrownValue===SuspenseException||thrownValue===SuspenseActionException?(thrownValue=getSuspendedThenable(),workInProgressSuspendedReason=3):thrownValue===SuspenseyCommitException?(thrownValue=getSuspendedThenable(),workInProgressSuspendedReason=4):workInProgressSuspendedReason=thrownValue===SelectiveHydrationException?8:null!==thrownValue&&"object"===typeof thrownValue&&"function"===typeof thrownValue.then?6:1;workInProgressThrownValue=thrownValue;null===workInProgress&&(workInProgressRootExitStatus=1,logUncaughtError(root,createCapturedValueAtFiber(thrownValue,root.current)));}function shouldRemainOnPreviousScreen(){var handler=suspenseHandlerStackCursor.current;return null===handler?true:(workInProgressRootRenderLanes&4194048)===workInProgressRootRenderLanes?null===shellBoundary?true:false:(workInProgressRootRenderLanes&62914560)===workInProgressRootRenderLanes||0!==(workInProgressRootRenderLanes&536870912)?handler===shellBoundary:false;}function pushDispatcher(){var prevDispatcher=ReactSharedInternals.H;ReactSharedInternals.H=ContextOnlyDispatcher;return null===prevDispatcher?ContextOnlyDispatcher:prevDispatcher;}function pushAsyncDispatcher(){var prevAsyncDispatcher=ReactSharedInternals.A;ReactSharedInternals.A=DefaultAsyncDispatcher;return prevAsyncDispatcher;}function renderDidSuspendDelayIfPossible(){workInProgressRootExitStatus=4;workInProgressRootDidSkipSuspendedSiblings||(workInProgressRootRenderLanes&4194048)!==workInProgressRootRenderLanes&&null!==suspenseHandlerStackCursor.current||(workInProgressRootIsPrerendering=true);0===(workInProgressRootSkippedLanes&134217727)&&0===(workInProgressRootInterleavedUpdatedLanes&134217727)||null===workInProgressRoot||markRootSuspended(workInProgressRoot,workInProgressRootRenderLanes,workInProgressDeferredLane,false);}function renderRootSync(root,lanes,shouldYieldForPrerendering){var prevExecutionContext=executionContext;executionContext|=2;var prevDispatcher=pushDispatcher(),prevAsyncDispatcher=pushAsyncDispatcher();if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes)workInProgressTransitions=null,prepareFreshStack(root,lanes);lanes=false;var exitStatus=workInProgressRootExitStatus;a:do try{if(0!==workInProgressSuspendedReason&&null!==workInProgress){var unitOfWork=workInProgress,thrownValue=workInProgressThrownValue;switch(workInProgressSuspendedReason){case 8:resetWorkInProgressStack();exitStatus=6;break a;case 3:case 2:case 9:case 6:null===suspenseHandlerStackCursor.current&&(lanes=!0);var reason=workInProgressSuspendedReason;workInProgressSuspendedReason=0;workInProgressThrownValue=null;throwAndUnwindWorkLoop(root,unitOfWork,thrownValue,reason);if(shouldYieldForPrerendering&&workInProgressRootIsPrerendering){exitStatus=0;break a;}break;default:reason=workInProgressSuspendedReason,workInProgressSuspendedReason=0,workInProgressThrownValue=null,throwAndUnwindWorkLoop(root,unitOfWork,thrownValue,reason);}}workLoopSync();exitStatus=workInProgressRootExitStatus;break;}catch(thrownValue$165){handleThrow(root,thrownValue$165);}while(1);lanes&&root.shellSuspendCounter++;lastContextDependency=currentlyRenderingFiber$1=null;executionContext=prevExecutionContext;ReactSharedInternals.H=prevDispatcher;ReactSharedInternals.A=prevAsyncDispatcher;null===workInProgress&&(workInProgressRoot=null,workInProgressRootRenderLanes=0,finishQueueingConcurrentUpdates());return exitStatus;}function workLoopSync(){for(;null!==workInProgress;)performUnitOfWork(workInProgress);}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=2;var prevDispatcher=pushDispatcher(),prevAsyncDispatcher=pushAsyncDispatcher();workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes?(workInProgressTransitions=null,workInProgressRootRenderTargetTime=now()+500,prepareFreshStack(root,lanes)):workInProgressRootIsPrerendering=checkIfRootIsPrerendering(root,lanes);a:do try{if(0!==workInProgressSuspendedReason&&null!==workInProgress){lanes=workInProgress;var thrownValue=workInProgressThrownValue;b:switch(workInProgressSuspendedReason){case 1:workInProgressSuspendedReason=0;workInProgressThrownValue=null;throwAndUnwindWorkLoop(root,lanes,thrownValue,1);break;case 2:case 9:if(isThenableResolved(thrownValue)){workInProgressSuspendedReason=0;workInProgressThrownValue=null;replaySuspendedUnitOfWork(lanes);break;}lanes=function(){2!==workInProgressSuspendedReason&&9!==workInProgressSuspendedReason||workInProgressRoot!==root||(workInProgressSuspendedReason=7);ensureRootIsScheduled(root);};thrownValue.then(lanes,lanes);break a;case 3:workInProgressSuspendedReason=7;break a;case 4:workInProgressSuspendedReason=5;break a;case 7:isThenableResolved(thrownValue)?(workInProgressSuspendedReason=0,workInProgressThrownValue=null,replaySuspendedUnitOfWork(lanes)):(workInProgressSuspendedReason=0,workInProgressThrownValue=null,throwAndUnwindWorkLoop(root,lanes,thrownValue,7));break;case 5:var resource=null;switch(workInProgress.tag){case 26:resource=workInProgress.memoizedState;case 5:case 27:var hostFiber=workInProgress;if(resource?preloadResource(resource):hostFiber.stateNode.complete){workInProgressSuspendedReason=0;workInProgressThrownValue=null;var sibling=hostFiber.sibling;if(null!==sibling)workInProgress=sibling;else {var returnFiber=hostFiber.return;null!==returnFiber?(workInProgress=returnFiber,completeUnitOfWork(returnFiber)):workInProgress=null;}break b;}}workInProgressSuspendedReason=0;workInProgressThrownValue=null;throwAndUnwindWorkLoop(root,lanes,thrownValue,5);break;case 6:workInProgressSuspendedReason=0;workInProgressThrownValue=null;throwAndUnwindWorkLoop(root,lanes,thrownValue,6);break;case 8:resetWorkInProgressStack();workInProgressRootExitStatus=6;break a;default:throw Error(formatProdErrorMessage(462));}}workLoopConcurrentByScheduler();break;}catch(thrownValue$167){handleThrow(root,thrownValue$167);}while(1);lastContextDependency=currentlyRenderingFiber$1=null;ReactSharedInternals.H=prevDispatcher;ReactSharedInternals.A=prevAsyncDispatcher;executionContext=prevExecutionContext;if(null!==workInProgress)return 0;workInProgressRoot=null;workInProgressRootRenderLanes=0;finishQueueingConcurrentUpdates();return workInProgressRootExitStatus;}function workLoopConcurrentByScheduler(){for(;null!==workInProgress&&!shouldYield();)performUnitOfWork(workInProgress);}function performUnitOfWork(unitOfWork){var next=beginWork(unitOfWork.alternate,unitOfWork,entangledRenderLanes);unitOfWork.memoizedProps=unitOfWork.pendingProps;null===next?completeUnitOfWork(unitOfWork):workInProgress=next;}function replaySuspendedUnitOfWork(unitOfWork){var next=unitOfWork;var current=next.alternate;switch(next.tag){case 15:case 0:next=replayFunctionComponent(current,next,next.pendingProps,next.type,void 0,workInProgressRootRenderLanes);break;case 11:next=replayFunctionComponent(current,next,next.pendingProps,next.type.render,next.ref,workInProgressRootRenderLanes);break;case 5:resetHooksOnUnwind(next);default:unwindInterruptedWork(current,next),next=workInProgress=resetWorkInProgress(next,entangledRenderLanes),next=beginWork(current,next,entangledRenderLanes);}unitOfWork.memoizedProps=unitOfWork.pendingProps;null===next?completeUnitOfWork(unitOfWork):workInProgress=next;}function throwAndUnwindWorkLoop(root,unitOfWork,thrownValue,suspendedReason){lastContextDependency=currentlyRenderingFiber$1=null;resetHooksOnUnwind(unitOfWork);thenableState$1=null;thenableIndexCounter$1=0;var returnFiber=unitOfWork.return;try{if(throwException(root,returnFiber,unitOfWork,thrownValue,workInProgressRootRenderLanes)){workInProgressRootExitStatus=1;logUncaughtError(root,createCapturedValueAtFiber(thrownValue,root.current));workInProgress=null;return;}}catch(error){if(null!==returnFiber)throw workInProgress=returnFiber,error;workInProgressRootExitStatus=1;logUncaughtError(root,createCapturedValueAtFiber(thrownValue,root.current));workInProgress=null;return;}if(unitOfWork.flags&32768){if(isHydrating||1===suspendedReason)root=true;else if(workInProgressRootIsPrerendering||0!==(workInProgressRootRenderLanes&536870912))root=false;else if(workInProgressRootDidSkipSuspendedSiblings=root=true,2===suspendedReason||9===suspendedReason||3===suspendedReason||6===suspendedReason)suspendedReason=suspenseHandlerStackCursor.current,null!==suspendedReason&&13===suspendedReason.tag&&(suspendedReason.flags|=16384);unwindUnitOfWork(unitOfWork,root);}else completeUnitOfWork(unitOfWork);}function completeUnitOfWork(unitOfWork){var completedWork=unitOfWork;do{if(0!==(completedWork.flags&32768)){unwindUnitOfWork(completedWork,workInProgressRootDidSkipSuspendedSiblings);return;}unitOfWork=completedWork.return;var next=completeWork(completedWork.alternate,completedWork,entangledRenderLanes);if(null!==next){workInProgress=next;return;}completedWork=completedWork.sibling;if(null!==completedWork){workInProgress=completedWork;return;}workInProgress=completedWork=unitOfWork;}while(null!==completedWork);0===workInProgressRootExitStatus&&(workInProgressRootExitStatus=5);}function unwindUnitOfWork(unitOfWork,skipSiblings){do{var next=unwindWork(unitOfWork.alternate,unitOfWork);if(null!==next){next.flags&=32767;workInProgress=next;return;}next=unitOfWork.return;null!==next&&(next.flags|=32768,next.subtreeFlags=0,next.deletions=null);if(!skipSiblings&&(unitOfWork=unitOfWork.sibling,null!==unitOfWork)){workInProgress=unitOfWork;return;}workInProgress=unitOfWork=next;}while(null!==unitOfWork);workInProgressRootExitStatus=6;workInProgress=null;}function commitRoot(root,finishedWork,lanes,recoverableErrors,transitions,didIncludeRenderPhaseUpdate,spawnedLane,updatedLanes,suspendedRetryLanes){root.cancelPendingCommit=null;do flushPendingEffects();while(0!==pendingEffectsStatus);if(0!==(executionContext&6))throw Error(formatProdErrorMessage(327));if(null!==finishedWork){if(finishedWork===root.current)throw Error(formatProdErrorMessage(177));didIncludeRenderPhaseUpdate=finishedWork.lanes|finishedWork.childLanes;didIncludeRenderPhaseUpdate|=concurrentlyUpdatedLanes;markRootFinished(root,lanes,didIncludeRenderPhaseUpdate,spawnedLane,updatedLanes,suspendedRetryLanes);root===workInProgressRoot&&(workInProgress=workInProgressRoot=null,workInProgressRootRenderLanes=0);pendingFinishedWork=finishedWork;pendingEffectsRoot=root;pendingEffectsLanes=lanes;pendingEffectsRemainingLanes=didIncludeRenderPhaseUpdate;pendingPassiveTransitions=transitions;pendingRecoverableErrors=recoverableErrors;0!==(finishedWork.subtreeFlags&10256)||0!==(finishedWork.flags&10256)?(root.callbackNode=null,root.callbackPriority=0,scheduleCallback$1(NormalPriority$1,function(){flushPassiveEffects();return null;})):(root.callbackNode=null,root.callbackPriority=0);recoverableErrors=0!==(finishedWork.flags&13878);if(0!==(finishedWork.subtreeFlags&13878)||recoverableErrors){recoverableErrors=ReactSharedInternals.T;ReactSharedInternals.T=null;transitions=ReactDOMSharedInternals.p;ReactDOMSharedInternals.p=2;spawnedLane=executionContext;executionContext|=4;try{commitBeforeMutationEffects(root,finishedWork,lanes);}finally{executionContext=spawnedLane,ReactDOMSharedInternals.p=transitions,ReactSharedInternals.T=recoverableErrors;}}pendingEffectsStatus=1;flushMutationEffects();flushLayoutEffects();flushSpawnedWork();}}function flushMutationEffects(){if(1===pendingEffectsStatus){pendingEffectsStatus=0;var root=pendingEffectsRoot,finishedWork=pendingFinishedWork,rootMutationHasEffect=0!==(finishedWork.flags&13878);if(0!==(finishedWork.subtreeFlags&13878)||rootMutationHasEffect){rootMutationHasEffect=ReactSharedInternals.T;ReactSharedInternals.T=null;var previousPriority=ReactDOMSharedInternals.p;ReactDOMSharedInternals.p=2;var prevExecutionContext=executionContext;executionContext|=4;try{commitMutationEffectsOnFiber(finishedWork,root);var priorSelectionInformation=selectionInformation,curFocusedElem=getActiveElementDeep(root.containerInfo),priorFocusedElem=priorSelectionInformation.focusedElem,priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&priorFocusedElem&&priorFocusedElem.ownerDocument&&containsNode(priorFocusedElem.ownerDocument.documentElement,priorFocusedElem)){if(null!==priorSelectionRange&&hasSelectionCapabilities(priorFocusedElem)){var start=priorSelectionRange.start,end=priorSelectionRange.end;void 0===end&&(end=start);if("selectionStart"in priorFocusedElem)priorFocusedElem.selectionStart=start,priorFocusedElem.selectionEnd=Math.min(end,priorFocusedElem.value.length);else {var doc=priorFocusedElem.ownerDocument||document,win=doc&&doc.defaultView||window;if(win.getSelection){var selection=win.getSelection(),length=priorFocusedElem.textContent.length,start$jscomp$0=Math.min(priorSelectionRange.start,length),end$jscomp$0=void 0===priorSelectionRange.end?start$jscomp$0:Math.min(priorSelectionRange.end,length);!selection.extend&&start$jscomp$0>end$jscomp$0&&(curFocusedElem=end$jscomp$0,end$jscomp$0=start$jscomp$0,start$jscomp$0=curFocusedElem);var startMarker=getNodeForCharacterOffset(priorFocusedElem,start$jscomp$0),endMarker=getNodeForCharacterOffset(priorFocusedElem,end$jscomp$0);if(startMarker&&endMarker&&(1!==selection.rangeCount||selection.anchorNode!==startMarker.node||selection.anchorOffset!==startMarker.offset||selection.focusNode!==endMarker.node||selection.focusOffset!==endMarker.offset)){var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();start$jscomp$0>end$jscomp$0?(selection.addRange(range),selection.extend(endMarker.node,endMarker.offset)):(range.setEnd(endMarker.node,endMarker.offset),selection.addRange(range));}}}}doc=[];for(selection=priorFocusedElem;selection=selection.parentNode;)1===selection.nodeType&&doc.push({element:selection,left:selection.scrollLeft,top:selection.scrollTop});"function"===typeof priorFocusedElem.focus&&priorFocusedElem.focus();for(priorFocusedElem=0;priorFocusedElem<doc.length;priorFocusedElem++){var info=doc[priorFocusedElem];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}_enabled=!!eventsEnabled;selectionInformation=eventsEnabled=null;}finally{executionContext=prevExecutionContext,ReactDOMSharedInternals.p=previousPriority,ReactSharedInternals.T=rootMutationHasEffect;}}root.current=finishedWork;pendingEffectsStatus=2;}}function flushLayoutEffects(){if(2===pendingEffectsStatus){pendingEffectsStatus=0;var root=pendingEffectsRoot,finishedWork=pendingFinishedWork,rootHasLayoutEffect=0!==(finishedWork.flags&8772);if(0!==(finishedWork.subtreeFlags&8772)||rootHasLayoutEffect){rootHasLayoutEffect=ReactSharedInternals.T;ReactSharedInternals.T=null;var previousPriority=ReactDOMSharedInternals.p;ReactDOMSharedInternals.p=2;var prevExecutionContext=executionContext;executionContext|=4;try{commitLayoutEffectOnFiber(root,finishedWork.alternate,finishedWork);}finally{executionContext=prevExecutionContext,ReactDOMSharedInternals.p=previousPriority,ReactSharedInternals.T=rootHasLayoutEffect;}}pendingEffectsStatus=3;}}function flushSpawnedWork(){if(4===pendingEffectsStatus||3===pendingEffectsStatus){pendingEffectsStatus=0;requestPaint();var root=pendingEffectsRoot,finishedWork=pendingFinishedWork,lanes=pendingEffectsLanes,recoverableErrors=pendingRecoverableErrors;0!==(finishedWork.subtreeFlags&10256)||0!==(finishedWork.flags&10256)?pendingEffectsStatus=5:(pendingEffectsStatus=0,pendingFinishedWork=pendingEffectsRoot=null,releaseRootPooledCache(root,root.pendingLanes));var remainingLanes=root.pendingLanes;0===remainingLanes&&(legacyErrorBoundariesThatAlreadyFailed=null);lanesToEventPriority(lanes);finishedWork=finishedWork.stateNode;if(injectedHook&&"function"===typeof injectedHook.onCommitFiberRoot)try{injectedHook.onCommitFiberRoot(rendererID,finishedWork,void 0,128===(finishedWork.current.flags&128));}catch(err){}if(null!==recoverableErrors){finishedWork=ReactSharedInternals.T;remainingLanes=ReactDOMSharedInternals.p;ReactDOMSharedInternals.p=2;ReactSharedInternals.T=null;try{for(var onRecoverableError=root.onRecoverableError,i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];onRecoverableError(recoverableError.value,{componentStack:recoverableError.stack});}}finally{ReactSharedInternals.T=finishedWork,ReactDOMSharedInternals.p=remainingLanes;}}0!==(pendingEffectsLanes&3)&&flushPendingEffects();ensureRootIsScheduled(root);remainingLanes=root.pendingLanes;0!==(lanes&261930)&&0!==(remainingLanes&42)?root===rootWithNestedUpdates?nestedUpdateCount++:(nestedUpdateCount=0,rootWithNestedUpdates=root):nestedUpdateCount=0;flushSyncWorkAcrossRoots_impl(0);}}function releaseRootPooledCache(root,remainingLanes){0===(root.pooledCacheLanes&=remainingLanes)&&(remainingLanes=root.pooledCache,null!=remainingLanes&&(root.pooledCache=null,releaseCache(remainingLanes)));}function flushPendingEffects(){flushMutationEffects();flushLayoutEffects();flushSpawnedWork();return flushPassiveEffects();}function flushPassiveEffects(){if(5!==pendingEffectsStatus)return  false;var root=pendingEffectsRoot,remainingLanes=pendingEffectsRemainingLanes;pendingEffectsRemainingLanes=0;var renderPriority=lanesToEventPriority(pendingEffectsLanes),prevTransition=ReactSharedInternals.T,previousPriority=ReactDOMSharedInternals.p;try{ReactDOMSharedInternals.p=32>renderPriority?32:renderPriority;ReactSharedInternals.T=null;renderPriority=pendingPassiveTransitions;pendingPassiveTransitions=null;var root$jscomp$0=pendingEffectsRoot,lanes=pendingEffectsLanes;pendingEffectsStatus=0;pendingFinishedWork=pendingEffectsRoot=null;pendingEffectsLanes=0;if(0!==(executionContext&6))throw Error(formatProdErrorMessage(331));var prevExecutionContext=executionContext;executionContext|=4;commitPassiveUnmountOnFiber(root$jscomp$0.current);commitPassiveMountOnFiber(root$jscomp$0,root$jscomp$0.current,lanes,renderPriority);executionContext=prevExecutionContext;flushSyncWorkAcrossRoots_impl(0,!1);if(injectedHook&&"function"===typeof injectedHook.onPostCommitFiberRoot)try{injectedHook.onPostCommitFiberRoot(rendererID,root$jscomp$0);}catch(err){}return !0;}finally{ReactDOMSharedInternals.p=previousPriority,ReactSharedInternals.T=prevTransition,releaseRootPooledCache(root,remainingLanes);}}function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){sourceFiber=createCapturedValueAtFiber(error,sourceFiber);sourceFiber=createRootErrorUpdate(rootFiber.stateNode,sourceFiber,2);rootFiber=enqueueUpdate(rootFiber,sourceFiber,2);null!==rootFiber&&(markRootUpdated$1(rootFiber,2),ensureRootIsScheduled(rootFiber));}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error){if(3===sourceFiber.tag)captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error);else for(;null!==nearestMountedAncestor;){if(3===nearestMountedAncestor.tag){captureCommitPhaseErrorOnRoot(nearestMountedAncestor,sourceFiber,error);break;}else if(1===nearestMountedAncestor.tag){var instance=nearestMountedAncestor.stateNode;if("function"===typeof nearestMountedAncestor.type.getDerivedStateFromError||"function"===typeof instance.componentDidCatch&&(null===legacyErrorBoundariesThatAlreadyFailed||!legacyErrorBoundariesThatAlreadyFailed.has(instance))){sourceFiber=createCapturedValueAtFiber(error,sourceFiber);error=createClassErrorUpdate(2);instance=enqueueUpdate(nearestMountedAncestor,error,2);null!==instance&&(initializeClassErrorUpdate(error,instance,nearestMountedAncestor,sourceFiber),markRootUpdated$1(instance,2),ensureRootIsScheduled(instance));break;}}nearestMountedAncestor=nearestMountedAncestor.return;}}function attachPingListener(root,wakeable,lanes){var pingCache=root.pingCache;if(null===pingCache){pingCache=root.pingCache=new PossiblyWeakMap();var threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else threadIDs=pingCache.get(wakeable),void 0===threadIDs&&(threadIDs=new Set(),pingCache.set(wakeable,threadIDs));threadIDs.has(lanes)||(workInProgressRootDidAttachPingListener=true,threadIDs.add(lanes),root=pingSuspendedRoot.bind(null,root,wakeable,lanes),wakeable.then(root,root));}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;null!==pingCache&&pingCache.delete(wakeable);root.pingedLanes|=root.suspendedLanes&pingedLanes;root.warmLanes&=~pingedLanes;workInProgressRoot===root&&(workInProgressRootRenderLanes&pingedLanes)===pingedLanes&&(4===workInProgressRootExitStatus||3===workInProgressRootExitStatus&&(workInProgressRootRenderLanes&62914560)===workInProgressRootRenderLanes&&300>now()-globalMostRecentFallbackTime?0===(executionContext&2)&&prepareFreshStack(root,0):workInProgressRootPingedLanes|=pingedLanes,workInProgressSuspendedRetryLanes===workInProgressRootRenderLanes&&(workInProgressSuspendedRetryLanes=0));ensureRootIsScheduled(root);}function retryTimedOutBoundary(boundaryFiber,retryLane){0===retryLane&&(retryLane=claimNextRetryLane());boundaryFiber=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);null!==boundaryFiber&&(markRootUpdated$1(boundaryFiber,retryLane),ensureRootIsScheduled(boundaryFiber));}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState,retryLane=0;null!==suspenseState&&(retryLane=suspenseState.retryLane);retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=0;switch(boundaryFiber.tag){case 31:case 13:var retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;null!==suspenseState&&(retryLane=suspenseState.retryLane);break;case 19:retryCache=boundaryFiber.stateNode;break;case 22:retryCache=boundaryFiber.stateNode._retryCache;break;default:throw Error(formatProdErrorMessage(314));}null!==retryCache&&retryCache.delete(wakeable);retryTimedOutBoundary(boundaryFiber,retryLane);}function scheduleCallback$1(priorityLevel,callback){return scheduleCallback$3(priorityLevel,callback);}var firstScheduledRoot=null,lastScheduledRoot=null,didScheduleMicrotask=false,mightHavePendingSyncWork=false,isFlushingWork=false,currentEventTransitionLane=0;function ensureRootIsScheduled(root){root!==lastScheduledRoot&&null===root.next&&(null===lastScheduledRoot?firstScheduledRoot=lastScheduledRoot=root:lastScheduledRoot=lastScheduledRoot.next=root);mightHavePendingSyncWork=true;didScheduleMicrotask||(didScheduleMicrotask=true,scheduleImmediateRootScheduleTask());}function flushSyncWorkAcrossRoots_impl(syncTransitionLanes,onlyLegacy){if(!isFlushingWork&&mightHavePendingSyncWork){isFlushingWork=true;do{var didPerformSomeWork=false;for(var root$170=firstScheduledRoot;null!==root$170;){if(0!==syncTransitionLanes){var pendingLanes=root$170.pendingLanes;if(0===pendingLanes)var JSCompiler_inline_result=0;else {var suspendedLanes=root$170.suspendedLanes,pingedLanes=root$170.pingedLanes;JSCompiler_inline_result=(1<<31-clz32(42|syncTransitionLanes)+1)-1;JSCompiler_inline_result&=pendingLanes&~(suspendedLanes&~pingedLanes);JSCompiler_inline_result=JSCompiler_inline_result&201326741?JSCompiler_inline_result&201326741|1:JSCompiler_inline_result?JSCompiler_inline_result|2:0;}0!==JSCompiler_inline_result&&(didPerformSomeWork=true,performSyncWorkOnRoot(root$170,JSCompiler_inline_result));}else JSCompiler_inline_result=workInProgressRootRenderLanes,JSCompiler_inline_result=getNextLanes(root$170,root$170===workInProgressRoot?JSCompiler_inline_result:0,null!==root$170.cancelPendingCommit||-1!==root$170.timeoutHandle),0===(JSCompiler_inline_result&3)||checkIfRootIsPrerendering(root$170,JSCompiler_inline_result)||(didPerformSomeWork=true,performSyncWorkOnRoot(root$170,JSCompiler_inline_result));root$170=root$170.next;}}while(didPerformSomeWork);isFlushingWork=false;}}function processRootScheduleInImmediateTask(){processRootScheduleInMicrotask();}function processRootScheduleInMicrotask(){mightHavePendingSyncWork=didScheduleMicrotask=false;var syncTransitionLanes=0;0!==currentEventTransitionLane&&shouldAttemptEagerTransition()&&(syncTransitionLanes=currentEventTransitionLane);for(var currentTime=now(),prev=null,root=firstScheduledRoot;null!==root;){var next=root.next,nextLanes=scheduleTaskForRootDuringMicrotask(root,currentTime);if(0===nextLanes)root.next=null,null===prev?firstScheduledRoot=next:prev.next=next,null===next&&(lastScheduledRoot=prev);else if(prev=root,0!==syncTransitionLanes||0!==(nextLanes&3))mightHavePendingSyncWork=true;root=next;}0!==pendingEffectsStatus&&5!==pendingEffectsStatus||flushSyncWorkAcrossRoots_impl(syncTransitionLanes);0!==currentEventTransitionLane&&(currentEventTransitionLane=0);}function scheduleTaskForRootDuringMicrotask(root,currentTime){for(var suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes,expirationTimes=root.expirationTimes,lanes=root.pendingLanes&-62914561;0<lanes;){var index$5=31-clz32(lanes),lane=1<<index$5,expirationTime=expirationTimes[index$5];if(-1===expirationTime){if(0===(lane&suspendedLanes)||0!==(lane&pingedLanes))expirationTimes[index$5]=computeExpirationTime(lane,currentTime);}else expirationTime<=currentTime&&(root.expiredLanes|=lane);lanes&=~lane;}currentTime=workInProgressRoot;suspendedLanes=workInProgressRootRenderLanes;suspendedLanes=getNextLanes(root,root===currentTime?suspendedLanes:0,null!==root.cancelPendingCommit||-1!==root.timeoutHandle);pingedLanes=root.callbackNode;if(0===suspendedLanes||root===currentTime&&(2===workInProgressSuspendedReason||9===workInProgressSuspendedReason)||null!==root.cancelPendingCommit)return null!==pingedLanes&&null!==pingedLanes&&cancelCallback$1(pingedLanes),root.callbackNode=null,root.callbackPriority=0;if(0===(suspendedLanes&3)||checkIfRootIsPrerendering(root,suspendedLanes)){currentTime=suspendedLanes&-suspendedLanes;if(currentTime===root.callbackPriority)return currentTime;null!==pingedLanes&&cancelCallback$1(pingedLanes);switch(lanesToEventPriority(suspendedLanes)){case 2:case 8:suspendedLanes=UserBlockingPriority;break;case 32:suspendedLanes=NormalPriority$1;break;case 268435456:suspendedLanes=IdlePriority;break;default:suspendedLanes=NormalPriority$1;}pingedLanes=performWorkOnRootViaSchedulerTask.bind(null,root);suspendedLanes=scheduleCallback$3(suspendedLanes,pingedLanes);root.callbackPriority=currentTime;root.callbackNode=suspendedLanes;return currentTime;}null!==pingedLanes&&null!==pingedLanes&&cancelCallback$1(pingedLanes);root.callbackPriority=2;root.callbackNode=null;return 2;}function performWorkOnRootViaSchedulerTask(root,didTimeout){if(0!==pendingEffectsStatus&&5!==pendingEffectsStatus)return root.callbackNode=null,root.callbackPriority=0,null;var originalCallbackNode=root.callbackNode;if(flushPendingEffects()&&root.callbackNode!==originalCallbackNode)return null;var workInProgressRootRenderLanes$jscomp$0=workInProgressRootRenderLanes;workInProgressRootRenderLanes$jscomp$0=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes$jscomp$0:0,null!==root.cancelPendingCommit||-1!==root.timeoutHandle);if(0===workInProgressRootRenderLanes$jscomp$0)return null;performWorkOnRoot(root,workInProgressRootRenderLanes$jscomp$0,didTimeout);scheduleTaskForRootDuringMicrotask(root,now());return null!=root.callbackNode&&root.callbackNode===originalCallbackNode?performWorkOnRootViaSchedulerTask.bind(null,root):null;}function performSyncWorkOnRoot(root,lanes){if(flushPendingEffects())return null;performWorkOnRoot(root,lanes,true);}function scheduleImmediateRootScheduleTask(){scheduleMicrotask(function(){0!==(executionContext&6)?scheduleCallback$3(ImmediatePriority,processRootScheduleInImmediateTask):processRootScheduleInMicrotask();});}function requestTransitionLane(){if(0===currentEventTransitionLane){var actionScopeLane=currentEntangledLane;0===actionScopeLane&&(actionScopeLane=nextTransitionUpdateLane,nextTransitionUpdateLane<<=1,0===(nextTransitionUpdateLane&261888)&&(nextTransitionUpdateLane=256));currentEventTransitionLane=actionScopeLane;}return currentEventTransitionLane;}function coerceFormActionProp(actionProp){return null==actionProp||"symbol"===typeof actionProp||"boolean"===typeof actionProp?null:"function"===typeof actionProp?actionProp:sanitizeURL(""+actionProp);}function createFormDataWithSubmitter(form,submitter){var temp=submitter.ownerDocument.createElement("input");temp.name=submitter.name;temp.value=submitter.value;form.id&&temp.setAttribute("form",form.id);submitter.parentNode.insertBefore(temp,submitter);form=new FormData(form);temp.parentNode.removeChild(temp);return form;}function extractEvents$1(dispatchQueue,domEventName,maybeTargetInst,nativeEvent,nativeEventTarget){if("submit"===domEventName&&maybeTargetInst&&maybeTargetInst.stateNode===nativeEventTarget){var action=coerceFormActionProp((nativeEventTarget[internalPropsKey]||null).action),submitter=nativeEvent.submitter;submitter&&(domEventName=(domEventName=submitter[internalPropsKey]||null)?coerceFormActionProp(domEventName.formAction):submitter.getAttribute("formAction"),null!==domEventName&&(action=domEventName,submitter=null));var event=new SyntheticEvent("action","action",null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:[{instance:null,listener:function(){if(nativeEvent.defaultPrevented){if(0!==currentEventTransitionLane){var formData=submitter?createFormDataWithSubmitter(nativeEventTarget,submitter):new FormData(nativeEventTarget);startHostTransition(maybeTargetInst,{pending:true,data:formData,method:nativeEventTarget.method,action:action},null,formData);}}else "function"===typeof action&&(event.preventDefault(),formData=submitter?createFormDataWithSubmitter(nativeEventTarget,submitter):new FormData(nativeEventTarget),startHostTransition(maybeTargetInst,{pending:true,data:formData,method:nativeEventTarget.method,action:action},action,formData));},currentTarget:nativeEventTarget}]});}}for(var i$jscomp$inline_1577=0;i$jscomp$inline_1577<simpleEventPluginEvents.length;i$jscomp$inline_1577++){var eventName$jscomp$inline_1578=simpleEventPluginEvents[i$jscomp$inline_1577],domEventName$jscomp$inline_1579=eventName$jscomp$inline_1578.toLowerCase(),capitalizedEvent$jscomp$inline_1580=eventName$jscomp$inline_1578[0].toUpperCase()+eventName$jscomp$inline_1578.slice(1);registerSimpleEvent(domEventName$jscomp$inline_1579,"on"+capitalizedEvent$jscomp$inline_1580);}registerSimpleEvent(ANIMATION_END,"onAnimationEnd");registerSimpleEvent(ANIMATION_ITERATION,"onAnimationIteration");registerSimpleEvent(ANIMATION_START,"onAnimationStart");registerSimpleEvent("dblclick","onDoubleClick");registerSimpleEvent("focusin","onFocus");registerSimpleEvent("focusout","onBlur");registerSimpleEvent(TRANSITION_RUN,"onTransitionRun");registerSimpleEvent(TRANSITION_START,"onTransitionStart");registerSimpleEvent(TRANSITION_CANCEL,"onTransitionCancel");registerSimpleEvent(TRANSITION_END,"onTransitionEnd");registerDirectEvent("onMouseEnter",["mouseout","mouseover"]);registerDirectEvent("onMouseLeave",["mouseout","mouseover"]);registerDirectEvent("onPointerEnter",["pointerout","pointerover"]);registerDirectEvent("onPointerLeave",["pointerout","pointerover"]);registerTwoPhaseEvent("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));registerTwoPhaseEvent("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));registerTwoPhaseEvent("onBeforeInput",["compositionend","keypress","textInput","paste"]);registerTwoPhaseEvent("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));registerTwoPhaseEvent("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));registerTwoPhaseEvent("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var mediaEventTypes="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),nonDelegatedEvents=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));function processDispatchQueue(dispatchQueue,eventSystemFlags){eventSystemFlags=0!==(eventSystemFlags&4);for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event;_dispatchQueue$i=_dispatchQueue$i.listeners;a:{var previousInstance=void 0;if(eventSystemFlags)for(var i$jscomp$0=_dispatchQueue$i.length-1;0<=i$jscomp$0;i$jscomp$0--){var _dispatchListeners$i=_dispatchQueue$i[i$jscomp$0],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget;_dispatchListeners$i=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped())break a;previousInstance=_dispatchListeners$i;event.currentTarget=currentTarget;try{previousInstance(event);}catch(error){reportGlobalError(error);}event.currentTarget=null;previousInstance=instance;}else for(i$jscomp$0=0;i$jscomp$0<_dispatchQueue$i.length;i$jscomp$0++){_dispatchListeners$i=_dispatchQueue$i[i$jscomp$0];instance=_dispatchListeners$i.instance;currentTarget=_dispatchListeners$i.currentTarget;_dispatchListeners$i=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped())break a;previousInstance=_dispatchListeners$i;event.currentTarget=currentTarget;try{previousInstance(event);}catch(error){reportGlobalError(error);}event.currentTarget=null;previousInstance=instance;}}}}function listenToNonDelegatedEvent(domEventName,targetElement){var JSCompiler_inline_result=targetElement[internalEventHandlersKey];void 0===JSCompiler_inline_result&&(JSCompiler_inline_result=targetElement[internalEventHandlersKey]=new Set());var listenerSetKey=domEventName+"__bubble";JSCompiler_inline_result.has(listenerSetKey)||(addTrappedEventListener(targetElement,domEventName,2,false),JSCompiler_inline_result.add(listenerSetKey));}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){var eventSystemFlags=0;isCapturePhaseListener&&(eventSystemFlags|=4);addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}var listeningMarker="_reactListening"+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){"selectionchange"!==domEventName&&(nonDelegatedEvents.has(domEventName)||listenToNativeEvent(domEventName,false,rootContainerElement),listenToNativeEvent(domEventName,true,rootContainerElement));});var ownerDocument=9===rootContainerElement.nodeType?rootContainerElement:rootContainerElement.ownerDocument;null===ownerDocument||ownerDocument[listeningMarker]||(ownerDocument[listeningMarker]=true,listenToNativeEvent("selectionchange",false,ownerDocument));}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener){switch(getEventPriority(domEventName)){case 2:var listenerWrapper=dispatchDiscreteEvent;break;case 8:listenerWrapper=dispatchContinuousEvent;break;default:listenerWrapper=dispatchEvent;}eventSystemFlags=listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);listenerWrapper=void 0;!passiveBrowserEventsSupported||"touchstart"!==domEventName&&"touchmove"!==domEventName&&"wheel"!==domEventName||(listenerWrapper=true);isCapturePhaseListener?void 0!==listenerWrapper?targetContainer.addEventListener(domEventName,eventSystemFlags,{capture:true,passive:listenerWrapper}):targetContainer.addEventListener(domEventName,eventSystemFlags,true):void 0!==listenerWrapper?targetContainer.addEventListener(domEventName,eventSystemFlags,{passive:listenerWrapper}):targetContainer.addEventListener(domEventName,eventSystemFlags,false);}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst$jscomp$0,targetContainer){var ancestorInst=targetInst$jscomp$0;if(0===(eventSystemFlags&1)&&0===(eventSystemFlags&2)&&null!==targetInst$jscomp$0)a:for(;;){if(null===targetInst$jscomp$0)return;var nodeTag=targetInst$jscomp$0.tag;if(3===nodeTag||4===nodeTag){var container=targetInst$jscomp$0.stateNode.containerInfo;if(container===targetContainer)break;if(4===nodeTag)for(nodeTag=targetInst$jscomp$0.return;null!==nodeTag;){var grandTag=nodeTag.tag;if((3===grandTag||4===grandTag)&&nodeTag.stateNode.containerInfo===targetContainer)return;nodeTag=nodeTag.return;}for(;null!==container;){nodeTag=getClosestInstanceFromNode(container);if(null===nodeTag)return;grandTag=nodeTag.tag;if(5===grandTag||6===grandTag||26===grandTag||27===grandTag){targetInst$jscomp$0=ancestorInst=nodeTag;continue a;}container=container.parentNode;}}targetInst$jscomp$0=targetInst$jscomp$0.return;}batchedUpdates$1(function(){var targetInst=ancestorInst,nativeEventTarget=getEventTarget(nativeEvent),dispatchQueue=[];a:{var reactName=topLevelEventsToReactNames.get(domEventName);if(void 0!==reactName){var SyntheticEventCtor=SyntheticEvent,reactEventType=domEventName;switch(domEventName){case "keypress":if(0===getEventCharCode(nativeEvent))break a;case "keydown":case "keyup":SyntheticEventCtor=SyntheticKeyboardEvent;break;case "focusin":reactEventType="focus";SyntheticEventCtor=SyntheticFocusEvent;break;case "focusout":reactEventType="blur";SyntheticEventCtor=SyntheticFocusEvent;break;case "beforeblur":case "afterblur":SyntheticEventCtor=SyntheticFocusEvent;break;case "click":if(2===nativeEvent.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":SyntheticEventCtor=SyntheticMouseEvent;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":SyntheticEventCtor=SyntheticDragEvent;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case "scroll":case "scrollend":SyntheticEventCtor=SyntheticUIEvent;break;case "wheel":SyntheticEventCtor=SyntheticWheelEvent;break;case "copy":case "cut":case "paste":SyntheticEventCtor=SyntheticClipboardEvent;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":SyntheticEventCtor=SyntheticPointerEvent;break;case "toggle":case "beforetoggle":SyntheticEventCtor=SyntheticToggleEvent;}var inCapturePhase=0!==(eventSystemFlags&4),accumulateTargetOnly=!inCapturePhase&&("scroll"===domEventName||"scrollend"===domEventName),reactEventName=inCapturePhase?null!==reactName?reactName+"Capture":null:reactName;inCapturePhase=[];for(var instance=targetInst,lastHostComponent;null!==instance;){var _instance=instance;lastHostComponent=_instance.stateNode;_instance=_instance.tag;5!==_instance&&26!==_instance&&27!==_instance||null===lastHostComponent||null===reactEventName||(_instance=getListener(instance,reactEventName),null!=_instance&&inCapturePhase.push(createDispatchListener(instance,_instance,lastHostComponent)));if(accumulateTargetOnly)break;instance=instance.return;}0<inCapturePhase.length&&(reactName=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget),dispatchQueue.push({event:reactName,listeners:inCapturePhase}));}}if(0===(eventSystemFlags&7)){a:{reactName="mouseover"===domEventName||"pointerover"===domEventName;SyntheticEventCtor="mouseout"===domEventName||"pointerout"===domEventName;if(reactName&&nativeEvent!==currentReplayingEvent&&(reactEventType=nativeEvent.relatedTarget||nativeEvent.fromElement)&&(getClosestInstanceFromNode(reactEventType)||reactEventType[internalContainerInstanceKey]))break a;if(SyntheticEventCtor||reactName){reactName=nativeEventTarget.window===nativeEventTarget?nativeEventTarget:(reactName=nativeEventTarget.ownerDocument)?reactName.defaultView||reactName.parentWindow:window;if(SyntheticEventCtor){if(reactEventType=nativeEvent.relatedTarget||nativeEvent.toElement,SyntheticEventCtor=targetInst,reactEventType=reactEventType?getClosestInstanceFromNode(reactEventType):null,null!==reactEventType&&(accumulateTargetOnly=getNearestMountedFiber(reactEventType),inCapturePhase=reactEventType.tag,reactEventType!==accumulateTargetOnly||5!==inCapturePhase&&27!==inCapturePhase&&6!==inCapturePhase))reactEventType=null;}else SyntheticEventCtor=null,reactEventType=targetInst;if(SyntheticEventCtor!==reactEventType){inCapturePhase=SyntheticMouseEvent;_instance="onMouseLeave";reactEventName="onMouseEnter";instance="mouse";if("pointerout"===domEventName||"pointerover"===domEventName)inCapturePhase=SyntheticPointerEvent,_instance="onPointerLeave",reactEventName="onPointerEnter",instance="pointer";accumulateTargetOnly=null==SyntheticEventCtor?reactName:getNodeFromInstance(SyntheticEventCtor);lastHostComponent=null==reactEventType?reactName:getNodeFromInstance(reactEventType);reactName=new inCapturePhase(_instance,instance+"leave",SyntheticEventCtor,nativeEvent,nativeEventTarget);reactName.target=accumulateTargetOnly;reactName.relatedTarget=lastHostComponent;_instance=null;getClosestInstanceFromNode(nativeEventTarget)===targetInst&&(inCapturePhase=new inCapturePhase(reactEventName,instance+"enter",reactEventType,nativeEvent,nativeEventTarget),inCapturePhase.target=lastHostComponent,inCapturePhase.relatedTarget=accumulateTargetOnly,_instance=inCapturePhase);accumulateTargetOnly=_instance;if(SyntheticEventCtor&&reactEventType)b:{inCapturePhase=getParent;reactEventName=SyntheticEventCtor;instance=reactEventType;lastHostComponent=0;for(_instance=reactEventName;_instance;_instance=inCapturePhase(_instance))lastHostComponent++;_instance=0;for(var tempB=instance;tempB;tempB=inCapturePhase(tempB))_instance++;for(;0<lastHostComponent-_instance;)reactEventName=inCapturePhase(reactEventName),lastHostComponent--;for(;0<_instance-lastHostComponent;)instance=inCapturePhase(instance),_instance--;for(;lastHostComponent--;){if(reactEventName===instance||null!==instance&&reactEventName===instance.alternate){inCapturePhase=reactEventName;break b;}reactEventName=inCapturePhase(reactEventName);instance=inCapturePhase(instance);}inCapturePhase=null;}else inCapturePhase=null;null!==SyntheticEventCtor&&accumulateEnterLeaveListenersForEvent(dispatchQueue,reactName,SyntheticEventCtor,inCapturePhase,!1);null!==reactEventType&&null!==accumulateTargetOnly&&accumulateEnterLeaveListenersForEvent(dispatchQueue,accumulateTargetOnly,reactEventType,inCapturePhase,!0);}}}a:{reactName=targetInst?getNodeFromInstance(targetInst):window;SyntheticEventCtor=reactName.nodeName&&reactName.nodeName.toLowerCase();if("select"===SyntheticEventCtor||"input"===SyntheticEventCtor&&"file"===reactName.type)var getTargetInstFunc=getTargetInstForChangeEvent;else if(isTextInputElement(reactName)){if(isInputEventSupported)getTargetInstFunc=getTargetInstForInputOrChangeEvent;else {getTargetInstFunc=getTargetInstForInputEventPolyfill;var handleEventFunc=handleEventsForInputEventPolyfill;}}else SyntheticEventCtor=reactName.nodeName,!SyntheticEventCtor||"input"!==SyntheticEventCtor.toLowerCase()||"checkbox"!==reactName.type&&"radio"!==reactName.type?targetInst&&isCustomElement(targetInst.elementType)&&(getTargetInstFunc=getTargetInstForChangeEvent):getTargetInstFunc=getTargetInstForClickEvent;if(getTargetInstFunc&&(getTargetInstFunc=getTargetInstFunc(domEventName,targetInst))){createAndAccumulateChangeEvent(dispatchQueue,getTargetInstFunc,nativeEvent,nativeEventTarget);break a;}handleEventFunc&&handleEventFunc(domEventName,reactName,targetInst);"focusout"===domEventName&&targetInst&&"number"===reactName.type&&null!=targetInst.memoizedProps.value&&setDefaultValue(reactName,"number",reactName.value);}handleEventFunc=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){case "focusin":if(isTextInputElement(handleEventFunc)||"true"===handleEventFunc.contentEditable)activeElement=handleEventFunc,activeElementInst=targetInst,lastSelection=null;break;case "focusout":lastSelection=activeElementInst=activeElement=null;break;case "mousedown":mouseDown=!0;break;case "contextmenu":case "mouseup":case "dragend":mouseDown=!1;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;case "selectionchange":if(skipSelectionChangeEvent)break;case "keydown":case "keyup":constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}var fallbackData;if(canUseCompositionEvent)b:{switch(domEventName){case "compositionstart":var eventType="onCompositionStart";break b;case "compositionend":eventType="onCompositionEnd";break b;case "compositionupdate":eventType="onCompositionUpdate";break b;}eventType=void 0;}else isComposing?isFallbackCompositionEnd(domEventName,nativeEvent)&&(eventType="onCompositionEnd"):"keydown"===domEventName&&229===nativeEvent.keyCode&&(eventType="onCompositionStart");eventType&&(useFallbackCompositionData&&"ko"!==nativeEvent.locale&&(isComposing||"onCompositionStart"!==eventType?"onCompositionEnd"===eventType&&isComposing&&(fallbackData=getData()):(root=nativeEventTarget,startText="value"in root?root.value:root.textContent,isComposing=!0)),handleEventFunc=accumulateTwoPhaseListeners(targetInst,eventType),0<handleEventFunc.length&&(eventType=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget),dispatchQueue.push({event:eventType,listeners:handleEventFunc}),fallbackData?eventType.data=fallbackData:(fallbackData=getDataFromCustomEvent(nativeEvent),null!==fallbackData&&(eventType.data=fallbackData))));if(fallbackData=canUseTextInputEvent?getNativeBeforeInputChars(domEventName,nativeEvent):getFallbackBeforeInputChars(domEventName,nativeEvent))eventType=accumulateTwoPhaseListeners(targetInst,"onBeforeInput"),0<eventType.length&&(handleEventFunc=new SyntheticCompositionEvent("onBeforeInput","beforeinput",null,nativeEvent,nativeEventTarget),dispatchQueue.push({event:handleEventFunc,listeners:eventType}),handleEventFunc.data=fallbackData);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}processDispatchQueue(dispatchQueue,eventSystemFlags);});}function createDispatchListener(instance,listener,currentTarget){return {instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateTwoPhaseListeners(targetFiber,reactName){for(var captureName=reactName+"Capture",listeners=[];null!==targetFiber;){var _instance2=targetFiber,stateNode=_instance2.stateNode;_instance2=_instance2.tag;5!==_instance2&&26!==_instance2&&27!==_instance2||null===stateNode||(_instance2=getListener(targetFiber,captureName),null!=_instance2&&listeners.unshift(createDispatchListener(targetFiber,_instance2,stateNode)),_instance2=getListener(targetFiber,reactName),null!=_instance2&&listeners.push(createDispatchListener(targetFiber,_instance2,stateNode)));if(3===targetFiber.tag)return listeners;targetFiber=targetFiber.return;}return [];}function getParent(inst){if(null===inst)return null;do inst=inst.return;while(inst&&5!==inst.tag&&27!==inst.tag);return inst?inst:null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){for(var registrationName=event._reactName,listeners=[];null!==target&&target!==common;){var _instance3=target,alternate=_instance3.alternate,stateNode=_instance3.stateNode;_instance3=_instance3.tag;if(null!==alternate&&alternate===common)break;5!==_instance3&&26!==_instance3&&27!==_instance3||null===stateNode||(alternate=stateNode,inCapturePhase?(stateNode=getListener(target,registrationName),null!=stateNode&&listeners.unshift(createDispatchListener(target,stateNode,alternate))):inCapturePhase||(stateNode=getListener(target,registrationName),null!=stateNode&&listeners.push(createDispatchListener(target,stateNode,alternate))));target=target.return;}0!==listeners.length&&dispatchQueue.push({event:event,listeners:listeners});}var NORMALIZE_NEWLINES_REGEX=/\r\n?/g,NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){return ("string"===typeof markup?markup:""+markup).replace(NORMALIZE_NEWLINES_REGEX,"\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,"");}function checkForUnmatchedText(serverText,clientText){clientText=normalizeMarkupForTextOrAttribute(clientText);return normalizeMarkupForTextOrAttribute(serverText)===clientText?true:false;}function setProp(domElement,tag,key,value,props,prevValue){switch(key){case "children":"string"===typeof value?"body"===tag||"textarea"===tag&&""===value||setTextContent(domElement,value):("number"===typeof value||"bigint"===typeof value)&&"body"!==tag&&setTextContent(domElement,""+value);break;case "className":setValueForKnownAttribute(domElement,"class",value);break;case "tabIndex":setValueForKnownAttribute(domElement,"tabindex",value);break;case "dir":case "role":case "viewBox":case "width":case "height":setValueForKnownAttribute(domElement,key,value);break;case "style":setValueForStyles(domElement,value,prevValue);break;case "data":if("object"!==tag){setValueForKnownAttribute(domElement,"data",value);break;}case "src":case "href":if(""===value&&("a"!==tag||"href"!==key)){domElement.removeAttribute(key);break;}if(null==value||"function"===typeof value||"symbol"===typeof value||"boolean"===typeof value){domElement.removeAttribute(key);break;}value=sanitizeURL(""+value);domElement.setAttribute(key,value);break;case "action":case "formAction":if("function"===typeof value){domElement.setAttribute(key,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break;}else "function"===typeof prevValue&&("formAction"===key?("input"!==tag&&setProp(domElement,tag,"name",props.name,props,null),setProp(domElement,tag,"formEncType",props.formEncType,props,null),setProp(domElement,tag,"formMethod",props.formMethod,props,null),setProp(domElement,tag,"formTarget",props.formTarget,props,null)):(setProp(domElement,tag,"encType",props.encType,props,null),setProp(domElement,tag,"method",props.method,props,null),setProp(domElement,tag,"target",props.target,props,null)));if(null==value||"symbol"===typeof value||"boolean"===typeof value){domElement.removeAttribute(key);break;}value=sanitizeURL(""+value);domElement.setAttribute(key,value);break;case "onClick":null!=value&&(domElement.onclick=noop$1);break;case "onScroll":null!=value&&listenToNonDelegatedEvent("scroll",domElement);break;case "onScrollEnd":null!=value&&listenToNonDelegatedEvent("scrollend",domElement);break;case "dangerouslySetInnerHTML":if(null!=value){if("object"!==typeof value||!("__html"in value))throw Error(formatProdErrorMessage(61));key=value.__html;if(null!=key){if(null!=props.children)throw Error(formatProdErrorMessage(60));domElement.innerHTML=key;}}break;case "multiple":domElement.multiple=value&&"function"!==typeof value&&"symbol"!==typeof value;break;case "muted":domElement.muted=value&&"function"!==typeof value&&"symbol"!==typeof value;break;case "suppressContentEditableWarning":case "suppressHydrationWarning":case "defaultValue":case "defaultChecked":case "innerHTML":case "ref":break;case "autoFocus":break;case "xlinkHref":if(null==value||"function"===typeof value||"boolean"===typeof value||"symbol"===typeof value){domElement.removeAttribute("xlink:href");break;}key=sanitizeURL(""+value);domElement.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",key);break;case "contentEditable":case "spellCheck":case "draggable":case "value":case "autoReverse":case "externalResourcesRequired":case "focusable":case "preserveAlpha":null!=value&&"function"!==typeof value&&"symbol"!==typeof value?domElement.setAttribute(key,""+value):domElement.removeAttribute(key);break;case "inert":case "allowFullScreen":case "async":case "autoPlay":case "controls":case "default":case "defer":case "disabled":case "disablePictureInPicture":case "disableRemotePlayback":case "formNoValidate":case "hidden":case "loop":case "noModule":case "noValidate":case "open":case "playsInline":case "readOnly":case "required":case "reversed":case "scoped":case "seamless":case "itemScope":value&&"function"!==typeof value&&"symbol"!==typeof value?domElement.setAttribute(key,""):domElement.removeAttribute(key);break;case "capture":case "download":true===value?domElement.setAttribute(key,""):false!==value&&null!=value&&"function"!==typeof value&&"symbol"!==typeof value?domElement.setAttribute(key,value):domElement.removeAttribute(key);break;case "cols":case "rows":case "size":case "span":null!=value&&"function"!==typeof value&&"symbol"!==typeof value&&!isNaN(value)&&1<=value?domElement.setAttribute(key,value):domElement.removeAttribute(key);break;case "rowSpan":case "start":null==value||"function"===typeof value||"symbol"===typeof value||isNaN(value)?domElement.removeAttribute(key):domElement.setAttribute(key,value);break;case "popover":listenToNonDelegatedEvent("beforetoggle",domElement);listenToNonDelegatedEvent("toggle",domElement);setValueForAttribute(domElement,"popover",value);break;case "xlinkActuate":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:actuate",value);break;case "xlinkArcrole":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:arcrole",value);break;case "xlinkRole":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:role",value);break;case "xlinkShow":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:show",value);break;case "xlinkTitle":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:title",value);break;case "xlinkType":setValueForNamespacedAttribute(domElement,"http://www.w3.org/1999/xlink","xlink:type",value);break;case "xmlBase":setValueForNamespacedAttribute(domElement,"http://www.w3.org/XML/1998/namespace","xml:base",value);break;case "xmlLang":setValueForNamespacedAttribute(domElement,"http://www.w3.org/XML/1998/namespace","xml:lang",value);break;case "xmlSpace":setValueForNamespacedAttribute(domElement,"http://www.w3.org/XML/1998/namespace","xml:space",value);break;case "is":setValueForAttribute(domElement,"is",value);break;case "innerText":case "textContent":break;default:if(!(2<key.length)||"o"!==key[0]&&"O"!==key[0]||"n"!==key[1]&&"N"!==key[1])key=aliases.get(key)||key,setValueForAttribute(domElement,key,value);}}function setPropOnCustomElement(domElement,tag,key,value,props,prevValue){switch(key){case "style":setValueForStyles(domElement,value,prevValue);break;case "dangerouslySetInnerHTML":if(null!=value){if("object"!==typeof value||!("__html"in value))throw Error(formatProdErrorMessage(61));key=value.__html;if(null!=key){if(null!=props.children)throw Error(formatProdErrorMessage(60));domElement.innerHTML=key;}}break;case "children":"string"===typeof value?setTextContent(domElement,value):("number"===typeof value||"bigint"===typeof value)&&setTextContent(domElement,""+value);break;case "onScroll":null!=value&&listenToNonDelegatedEvent("scroll",domElement);break;case "onScrollEnd":null!=value&&listenToNonDelegatedEvent("scrollend",domElement);break;case "onClick":null!=value&&(domElement.onclick=noop$1);break;case "suppressContentEditableWarning":case "suppressHydrationWarning":case "innerHTML":case "ref":break;case "innerText":case "textContent":break;default:if(!registrationNameDependencies.hasOwnProperty(key))a:{if("o"===key[0]&&"n"===key[1]&&(props=key.endsWith("Capture"),tag=key.slice(2,props?key.length-7:void 0),prevValue=domElement[internalPropsKey]||null,prevValue=null!=prevValue?prevValue[key]:null,"function"===typeof prevValue&&domElement.removeEventListener(tag,prevValue,props),"function"===typeof value)){"function"!==typeof prevValue&&null!==prevValue&&(key in domElement?domElement[key]=null:domElement.hasAttribute(key)&&domElement.removeAttribute(key));domElement.addEventListener(tag,value,props);break a;}key in domElement?domElement[key]=value:true===value?domElement.setAttribute(key,""):setValueForAttribute(domElement,key,value);}}}function setInitialProperties(domElement,tag,props){switch(tag){case "div":case "span":case "svg":case "path":case "a":case "g":case "p":case "li":break;case "img":listenToNonDelegatedEvent("error",domElement);listenToNonDelegatedEvent("load",domElement);var hasSrc=false,hasSrcSet=false,propKey;for(propKey in props)if(props.hasOwnProperty(propKey)){var propValue=props[propKey];if(null!=propValue)switch(propKey){case "src":hasSrc=true;break;case "srcSet":hasSrcSet=true;break;case "children":case "dangerouslySetInnerHTML":throw Error(formatProdErrorMessage(137,tag));default:setProp(domElement,tag,propKey,propValue,props,null);}}hasSrcSet&&setProp(domElement,tag,"srcSet",props.srcSet,props,null);hasSrc&&setProp(domElement,tag,"src",props.src,props,null);return;case "input":listenToNonDelegatedEvent("invalid",domElement);var defaultValue=propKey=propValue=hasSrcSet=null,checked=null,defaultChecked=null;for(hasSrc in props)if(props.hasOwnProperty(hasSrc)){var propValue$184=props[hasSrc];if(null!=propValue$184)switch(hasSrc){case "name":hasSrcSet=propValue$184;break;case "type":propValue=propValue$184;break;case "checked":checked=propValue$184;break;case "defaultChecked":defaultChecked=propValue$184;break;case "value":propKey=propValue$184;break;case "defaultValue":defaultValue=propValue$184;break;case "children":case "dangerouslySetInnerHTML":if(null!=propValue$184)throw Error(formatProdErrorMessage(137,tag));break;default:setProp(domElement,tag,hasSrc,propValue$184,props,null);}}initInput(domElement,propKey,defaultValue,checked,defaultChecked,propValue,hasSrcSet,false);return;case "select":listenToNonDelegatedEvent("invalid",domElement);hasSrc=propValue=propKey=null;for(hasSrcSet in props)if(props.hasOwnProperty(hasSrcSet)&&(defaultValue=props[hasSrcSet],null!=defaultValue))switch(hasSrcSet){case "value":propKey=defaultValue;break;case "defaultValue":propValue=defaultValue;break;case "multiple":hasSrc=defaultValue;default:setProp(domElement,tag,hasSrcSet,defaultValue,props,null);}tag=propKey;props=propValue;domElement.multiple=!!hasSrc;null!=tag?updateOptions(domElement,!!hasSrc,tag,false):null!=props&&updateOptions(domElement,!!hasSrc,props,true);return;case "textarea":listenToNonDelegatedEvent("invalid",domElement);propKey=hasSrcSet=hasSrc=null;for(propValue in props)if(props.hasOwnProperty(propValue)&&(defaultValue=props[propValue],null!=defaultValue))switch(propValue){case "value":hasSrc=defaultValue;break;case "defaultValue":hasSrcSet=defaultValue;break;case "children":propKey=defaultValue;break;case "dangerouslySetInnerHTML":if(null!=defaultValue)throw Error(formatProdErrorMessage(91));break;default:setProp(domElement,tag,propValue,defaultValue,props,null);}initTextarea(domElement,hasSrc,hasSrcSet,propKey);return;case "option":for(checked in props)if(props.hasOwnProperty(checked)&&(hasSrc=props[checked],null!=hasSrc))switch(checked){case "selected":domElement.selected=hasSrc&&"function"!==typeof hasSrc&&"symbol"!==typeof hasSrc;break;default:setProp(domElement,tag,checked,hasSrc,props,null);}return;case "dialog":listenToNonDelegatedEvent("beforetoggle",domElement);listenToNonDelegatedEvent("toggle",domElement);listenToNonDelegatedEvent("cancel",domElement);listenToNonDelegatedEvent("close",domElement);break;case "iframe":case "object":listenToNonDelegatedEvent("load",domElement);break;case "video":case "audio":for(hasSrc=0;hasSrc<mediaEventTypes.length;hasSrc++)listenToNonDelegatedEvent(mediaEventTypes[hasSrc],domElement);break;case "image":listenToNonDelegatedEvent("error",domElement);listenToNonDelegatedEvent("load",domElement);break;case "details":listenToNonDelegatedEvent("toggle",domElement);break;case "embed":case "source":case "link":listenToNonDelegatedEvent("error",domElement),listenToNonDelegatedEvent("load",domElement);case "area":case "base":case "br":case "col":case "hr":case "keygen":case "meta":case "param":case "track":case "wbr":case "menuitem":for(defaultChecked in props)if(props.hasOwnProperty(defaultChecked)&&(hasSrc=props[defaultChecked],null!=hasSrc))switch(defaultChecked){case "children":case "dangerouslySetInnerHTML":throw Error(formatProdErrorMessage(137,tag));default:setProp(domElement,tag,defaultChecked,hasSrc,props,null);}return;default:if(isCustomElement(tag)){for(propValue$184 in props)props.hasOwnProperty(propValue$184)&&(hasSrc=props[propValue$184],void 0!==hasSrc&&setPropOnCustomElement(domElement,tag,propValue$184,hasSrc,props,void 0));return;}}for(defaultValue in props)props.hasOwnProperty(defaultValue)&&(hasSrc=props[defaultValue],null!=hasSrc&&setProp(domElement,tag,defaultValue,hasSrc,props,null));}function updateProperties(domElement,tag,lastProps,nextProps){switch(tag){case "div":case "span":case "svg":case "path":case "a":case "g":case "p":case "li":break;case "input":var name=null,type=null,value=null,defaultValue=null,lastDefaultValue=null,checked=null,defaultChecked=null;for(propKey in lastProps){var lastProp=lastProps[propKey];if(lastProps.hasOwnProperty(propKey)&&null!=lastProp)switch(propKey){case "checked":break;case "value":break;case "defaultValue":lastDefaultValue=lastProp;default:nextProps.hasOwnProperty(propKey)||setProp(domElement,tag,propKey,null,nextProps,lastProp);}}for(var propKey$201 in nextProps){var propKey=nextProps[propKey$201];lastProp=lastProps[propKey$201];if(nextProps.hasOwnProperty(propKey$201)&&(null!=propKey||null!=lastProp))switch(propKey$201){case "type":type=propKey;break;case "name":name=propKey;break;case "checked":checked=propKey;break;case "defaultChecked":defaultChecked=propKey;break;case "value":value=propKey;break;case "defaultValue":defaultValue=propKey;break;case "children":case "dangerouslySetInnerHTML":if(null!=propKey)throw Error(formatProdErrorMessage(137,tag));break;default:propKey!==lastProp&&setProp(domElement,tag,propKey$201,propKey,nextProps,lastProp);}}updateInput(domElement,value,defaultValue,lastDefaultValue,checked,defaultChecked,type,name);return;case "select":propKey=value=defaultValue=propKey$201=null;for(type in lastProps)if(lastDefaultValue=lastProps[type],lastProps.hasOwnProperty(type)&&null!=lastDefaultValue)switch(type){case "value":break;case "multiple":propKey=lastDefaultValue;default:nextProps.hasOwnProperty(type)||setProp(domElement,tag,type,null,nextProps,lastDefaultValue);}for(name in nextProps)if(type=nextProps[name],lastDefaultValue=lastProps[name],nextProps.hasOwnProperty(name)&&(null!=type||null!=lastDefaultValue))switch(name){case "value":propKey$201=type;break;case "defaultValue":defaultValue=type;break;case "multiple":value=type;default:type!==lastDefaultValue&&setProp(domElement,tag,name,type,nextProps,lastDefaultValue);}tag=defaultValue;lastProps=value;nextProps=propKey;null!=propKey$201?updateOptions(domElement,!!lastProps,propKey$201,false):!!nextProps!==!!lastProps&&(null!=tag?updateOptions(domElement,!!lastProps,tag,true):updateOptions(domElement,!!lastProps,lastProps?[]:"",false));return;case "textarea":propKey=propKey$201=null;for(defaultValue in lastProps)if(name=lastProps[defaultValue],lastProps.hasOwnProperty(defaultValue)&&null!=name&&!nextProps.hasOwnProperty(defaultValue))switch(defaultValue){case "value":break;case "children":break;default:setProp(domElement,tag,defaultValue,null,nextProps,name);}for(value in nextProps)if(name=nextProps[value],type=lastProps[value],nextProps.hasOwnProperty(value)&&(null!=name||null!=type))switch(value){case "value":propKey$201=name;break;case "defaultValue":propKey=name;break;case "children":break;case "dangerouslySetInnerHTML":if(null!=name)throw Error(formatProdErrorMessage(91));break;default:name!==type&&setProp(domElement,tag,value,name,nextProps,type);}updateTextarea(domElement,propKey$201,propKey);return;case "option":for(var propKey$217 in lastProps)if(propKey$201=lastProps[propKey$217],lastProps.hasOwnProperty(propKey$217)&&null!=propKey$201&&!nextProps.hasOwnProperty(propKey$217))switch(propKey$217){case "selected":domElement.selected=false;break;default:setProp(domElement,tag,propKey$217,null,nextProps,propKey$201);}for(lastDefaultValue in nextProps)if(propKey$201=nextProps[lastDefaultValue],propKey=lastProps[lastDefaultValue],nextProps.hasOwnProperty(lastDefaultValue)&&propKey$201!==propKey&&(null!=propKey$201||null!=propKey))switch(lastDefaultValue){case "selected":domElement.selected=propKey$201&&"function"!==typeof propKey$201&&"symbol"!==typeof propKey$201;break;default:setProp(domElement,tag,lastDefaultValue,propKey$201,nextProps,propKey);}return;case "img":case "link":case "area":case "base":case "br":case "col":case "embed":case "hr":case "keygen":case "meta":case "param":case "source":case "track":case "wbr":case "menuitem":for(var propKey$222 in lastProps)propKey$201=lastProps[propKey$222],lastProps.hasOwnProperty(propKey$222)&&null!=propKey$201&&!nextProps.hasOwnProperty(propKey$222)&&setProp(domElement,tag,propKey$222,null,nextProps,propKey$201);for(checked in nextProps)if(propKey$201=nextProps[checked],propKey=lastProps[checked],nextProps.hasOwnProperty(checked)&&propKey$201!==propKey&&(null!=propKey$201||null!=propKey))switch(checked){case "children":case "dangerouslySetInnerHTML":if(null!=propKey$201)throw Error(formatProdErrorMessage(137,tag));break;default:setProp(domElement,tag,checked,propKey$201,nextProps,propKey);}return;default:if(isCustomElement(tag)){for(var propKey$227 in lastProps)propKey$201=lastProps[propKey$227],lastProps.hasOwnProperty(propKey$227)&&void 0!==propKey$201&&!nextProps.hasOwnProperty(propKey$227)&&setPropOnCustomElement(domElement,tag,propKey$227,void 0,nextProps,propKey$201);for(defaultChecked in nextProps)propKey$201=nextProps[defaultChecked],propKey=lastProps[defaultChecked],!nextProps.hasOwnProperty(defaultChecked)||propKey$201===propKey||void 0===propKey$201&&void 0===propKey||setPropOnCustomElement(domElement,tag,defaultChecked,propKey$201,nextProps,propKey);return;}}for(var propKey$232 in lastProps)propKey$201=lastProps[propKey$232],lastProps.hasOwnProperty(propKey$232)&&null!=propKey$201&&!nextProps.hasOwnProperty(propKey$232)&&setProp(domElement,tag,propKey$232,null,nextProps,propKey$201);for(lastProp in nextProps)propKey$201=nextProps[lastProp],propKey=lastProps[lastProp],!nextProps.hasOwnProperty(lastProp)||propKey$201===propKey||null==propKey$201&&null==propKey||setProp(domElement,tag,lastProp,propKey$201,nextProps,propKey);}function isLikelyStaticResource(initiatorType){switch(initiatorType){case "css":case "script":case "font":case "img":case "image":case "input":case "link":return  true;default:return  false;}}function estimateBandwidth(){if("function"===typeof performance.getEntriesByType){for(var count=0,bits=0,resourceEntries=performance.getEntriesByType("resource"),i=0;i<resourceEntries.length;i++){var entry=resourceEntries[i],transferSize=entry.transferSize,initiatorType=entry.initiatorType,duration=entry.duration;if(transferSize&&duration&&isLikelyStaticResource(initiatorType)){initiatorType=0;duration=entry.responseEnd;for(i+=1;i<resourceEntries.length;i++){var overlapEntry=resourceEntries[i],overlapStartTime=overlapEntry.startTime;if(overlapStartTime>duration)break;var overlapTransferSize=overlapEntry.transferSize,overlapInitiatorType=overlapEntry.initiatorType;overlapTransferSize&&isLikelyStaticResource(overlapInitiatorType)&&(overlapEntry=overlapEntry.responseEnd,initiatorType+=overlapTransferSize*(overlapEntry<duration?1:(duration-overlapStartTime)/(overlapEntry-overlapStartTime)));}--i;bits+=8*(transferSize+initiatorType)/(entry.duration/1e3);count++;if(10<count)break;}}if(0<count)return bits/count/1e6;}return navigator.connection&&(count=navigator.connection.downlink,"number"===typeof count)?count:5;}var eventsEnabled=null,selectionInformation=null;function getOwnerDocumentFromRootContainer(rootContainerElement){return 9===rootContainerElement.nodeType?rootContainerElement:rootContainerElement.ownerDocument;}function getOwnHostContext(namespaceURI){switch(namespaceURI){case "http://www.w3.org/2000/svg":return 1;case "http://www.w3.org/1998/Math/MathML":return 2;default:return 0;}}function getChildHostContextProd(parentNamespace,type){if(0===parentNamespace)switch(type){case "svg":return 1;case "math":return 2;default:return 0;}return 1===parentNamespace&&"foreignObject"===type?0:parentNamespace;}function shouldSetTextContent(type,props){return "textarea"===type||"noscript"===type||"string"===typeof props.children||"number"===typeof props.children||"bigint"===typeof props.children||"object"===typeof props.dangerouslySetInnerHTML&&null!==props.dangerouslySetInnerHTML&&null!=props.dangerouslySetInnerHTML.__html;}var currentPopstateTransitionEvent=null;function shouldAttemptEagerTransition(){var event=window.event;if(event&&"popstate"===event.type){if(event===currentPopstateTransitionEvent)return  false;currentPopstateTransitionEvent=event;return  true;}currentPopstateTransitionEvent=null;return  false;}var scheduleTimeout="function"===typeof setTimeout?setTimeout:void 0,cancelTimeout="function"===typeof clearTimeout?clearTimeout:void 0,localPromise="function"===typeof Promise?Promise:void 0,scheduleMicrotask="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof localPromise?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;function handleErrorInNextTick(error){setTimeout(function(){throw error;});}function isSingletonScope(type){return "head"===type;}function clearHydrationBoundary(parentInstance,hydrationInstance){var node=hydrationInstance,depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&8===nextNode.nodeType)if(node=nextNode.data,"/$"===node||"/&"===node){if(0===depth){parentInstance.removeChild(nextNode);retryIfBlockedOn(hydrationInstance);return;}depth--;}else if("$"===node||"$?"===node||"$~"===node||"$!"===node||"&"===node)depth++;else if("html"===node)releaseSingletonInstance(parentInstance.ownerDocument.documentElement);else if("head"===node){node=parentInstance.ownerDocument.head;releaseSingletonInstance(node);for(var node$jscomp$0=node.firstChild;node$jscomp$0;){var nextNode$jscomp$0=node$jscomp$0.nextSibling,nodeName=node$jscomp$0.nodeName;node$jscomp$0[internalHoistableMarker]||"SCRIPT"===nodeName||"STYLE"===nodeName||"LINK"===nodeName&&"stylesheet"===node$jscomp$0.rel.toLowerCase()||node.removeChild(node$jscomp$0);node$jscomp$0=nextNode$jscomp$0;}}else "body"===node&&releaseSingletonInstance(parentInstance.ownerDocument.body);node=nextNode;}while(node);retryIfBlockedOn(hydrationInstance);}function hideOrUnhideDehydratedBoundary(suspenseInstance,isHidden){var node=suspenseInstance;suspenseInstance=0;do{var nextNode=node.nextSibling;1===node.nodeType?isHidden?(node._stashedDisplay=node.style.display,node.style.display="none"):(node.style.display=node._stashedDisplay||"",""===node.getAttribute("style")&&node.removeAttribute("style")):3===node.nodeType&&(isHidden?(node._stashedText=node.nodeValue,node.nodeValue=""):node.nodeValue=node._stashedText||"");if(nextNode&&8===nextNode.nodeType)if(node=nextNode.data,"/$"===node){if(0===suspenseInstance)break;else suspenseInstance--;}else "$"!==node&&"$?"!==node&&"$~"!==node&&"$!"!==node||suspenseInstance++;node=nextNode;}while(node);}function clearContainerSparingly(container){var nextNode=container.firstChild;nextNode&&10===nextNode.nodeType&&(nextNode=nextNode.nextSibling);for(;nextNode;){var node=nextNode;nextNode=nextNode.nextSibling;switch(node.nodeName){case "HTML":case "HEAD":case "BODY":clearContainerSparingly(node);detachDeletedInstance(node);continue;case "SCRIPT":case "STYLE":continue;case "LINK":if("stylesheet"===node.rel.toLowerCase())continue;}container.removeChild(node);}}function canHydrateInstance(instance,type,props,inRootOrSingleton){for(;1===instance.nodeType;){var anyProps=props;if(instance.nodeName.toLowerCase()!==type.toLowerCase()){if(!inRootOrSingleton&&("INPUT"!==instance.nodeName||"hidden"!==instance.type))break;}else if(!inRootOrSingleton){if("input"===type&&"hidden"===instance.type){var name=null==anyProps.name?null:""+anyProps.name;if("hidden"===anyProps.type&&instance.getAttribute("name")===name)return instance;}else return instance;}else if(!instance[internalHoistableMarker])switch(type){case "meta":if(!instance.hasAttribute("itemprop"))break;return instance;case "link":name=instance.getAttribute("rel");if("stylesheet"===name&&instance.hasAttribute("data-precedence"))break;else if(name!==anyProps.rel||instance.getAttribute("href")!==(null==anyProps.href||""===anyProps.href?null:anyProps.href)||instance.getAttribute("crossorigin")!==(null==anyProps.crossOrigin?null:anyProps.crossOrigin)||instance.getAttribute("title")!==(null==anyProps.title?null:anyProps.title))break;return instance;case "style":if(instance.hasAttribute("data-precedence"))break;return instance;case "script":name=instance.getAttribute("src");if((name!==(null==anyProps.src?null:anyProps.src)||instance.getAttribute("type")!==(null==anyProps.type?null:anyProps.type)||instance.getAttribute("crossorigin")!==(null==anyProps.crossOrigin?null:anyProps.crossOrigin))&&name&&instance.hasAttribute("async")&&!instance.hasAttribute("itemprop"))break;return instance;default:return instance;}instance=getNextHydratable(instance.nextSibling);if(null===instance)break;}return null;}function canHydrateTextInstance(instance,text,inRootOrSingleton){if(""===text)return null;for(;3!==instance.nodeType;){if((1!==instance.nodeType||"INPUT"!==instance.nodeName||"hidden"!==instance.type)&&!inRootOrSingleton)return null;instance=getNextHydratable(instance.nextSibling);if(null===instance)return null;}return instance;}function canHydrateHydrationBoundary(instance,inRootOrSingleton){for(;8!==instance.nodeType;){if((1!==instance.nodeType||"INPUT"!==instance.nodeName||"hidden"!==instance.type)&&!inRootOrSingleton)return null;instance=getNextHydratable(instance.nextSibling);if(null===instance)return null;}return instance;}function isSuspenseInstancePending(instance){return "$?"===instance.data||"$~"===instance.data;}function isSuspenseInstanceFallback(instance){return "$!"===instance.data||"$?"===instance.data&&"loading"!==instance.ownerDocument.readyState;}function registerSuspenseInstanceRetry(instance,callback){var ownerDocument=instance.ownerDocument;if("$~"===instance.data)instance._reactRetry=callback;else if("$?"!==instance.data||"loading"!==ownerDocument.readyState)callback();else {var listener=function(){callback();ownerDocument.removeEventListener("DOMContentLoaded",listener);};ownerDocument.addEventListener("DOMContentLoaded",listener);instance._reactRetry=listener;}}function getNextHydratable(node){for(;null!=node;node=node.nextSibling){var nodeType=node.nodeType;if(1===nodeType||3===nodeType)break;if(8===nodeType){nodeType=node.data;if("$"===nodeType||"$!"===nodeType||"$?"===nodeType||"$~"===nodeType||"&"===nodeType||"F!"===nodeType||"F"===nodeType)break;if("/$"===nodeType||"/&"===nodeType)return null;}}return node;}var previousHydratableOnEnteringScopedSingleton=null;function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance){hydrationInstance=hydrationInstance.nextSibling;for(var depth=0;hydrationInstance;){if(8===hydrationInstance.nodeType){var data=hydrationInstance.data;if("/$"===data||"/&"===data){if(0===depth)return getNextHydratable(hydrationInstance.nextSibling);depth--;}else "$"!==data&&"$!"!==data&&"$?"!==data&&"$~"!==data&&"&"!==data||depth++;}hydrationInstance=hydrationInstance.nextSibling;}return null;}function getParentHydrationBoundary(targetInstance){targetInstance=targetInstance.previousSibling;for(var depth=0;targetInstance;){if(8===targetInstance.nodeType){var data=targetInstance.data;if("$"===data||"$!"===data||"$?"===data||"$~"===data||"&"===data){if(0===depth)return targetInstance;depth--;}else "/$"!==data&&"/&"!==data||depth++;}targetInstance=targetInstance.previousSibling;}return null;}function resolveSingletonInstance(type,props,rootContainerInstance){props=getOwnerDocumentFromRootContainer(rootContainerInstance);switch(type){case "html":type=props.documentElement;if(!type)throw Error(formatProdErrorMessage(452));return type;case "head":type=props.head;if(!type)throw Error(formatProdErrorMessage(453));return type;case "body":type=props.body;if(!type)throw Error(formatProdErrorMessage(454));return type;default:throw Error(formatProdErrorMessage(451));}}function releaseSingletonInstance(instance){for(var attributes=instance.attributes;attributes.length;)instance.removeAttributeNode(attributes[0]);detachDeletedInstance(instance);}var preloadPropsMap=new Map(),preconnectsSet=new Set();function getHoistableRoot(container){return "function"===typeof container.getRootNode?container.getRootNode():9===container.nodeType?container:container.ownerDocument;}var previousDispatcher=ReactDOMSharedInternals.d;ReactDOMSharedInternals.d={f:flushSyncWork,r:requestFormReset,D:prefetchDNS,C:preconnect,L:preload,m:preloadModule,X:preinitScript,S:preinitStyle,M:preinitModuleScript};function flushSyncWork(){var previousWasRendering=previousDispatcher.f(),wasRendering=flushSyncWork$1();return previousWasRendering||wasRendering;}function requestFormReset(form){var formInst=getInstanceFromNode(form);null!==formInst&&5===formInst.tag&&"form"===formInst.type?requestFormReset$1(formInst):previousDispatcher.r(form);}var globalDocument="undefined"===typeof document?null:document;function preconnectAs(rel,href,crossOrigin){var ownerDocument=globalDocument;if(ownerDocument&&"string"===typeof href&&href){var limitedEscapedHref=escapeSelectorAttributeValueInsideDoubleQuotes(href);limitedEscapedHref='link[rel="'+rel+'"][href="'+limitedEscapedHref+'"]';"string"===typeof crossOrigin&&(limitedEscapedHref+='[crossorigin="'+crossOrigin+'"]');preconnectsSet.has(limitedEscapedHref)||(preconnectsSet.add(limitedEscapedHref),rel={rel:rel,crossOrigin:crossOrigin,href:href},null===ownerDocument.querySelector(limitedEscapedHref)&&(href=ownerDocument.createElement("link"),setInitialProperties(href,"link",rel),markNodeAsHoistable(href),ownerDocument.head.appendChild(href)));}}function prefetchDNS(href){previousDispatcher.D(href);preconnectAs("dns-prefetch",href,null);}function preconnect(href,crossOrigin){previousDispatcher.C(href,crossOrigin);preconnectAs("preconnect",href,crossOrigin);}function preload(href,as,options){previousDispatcher.L(href,as,options);var ownerDocument=globalDocument;if(ownerDocument&&href&&as){var preloadSelector='link[rel="preload"][as="'+escapeSelectorAttributeValueInsideDoubleQuotes(as)+'"]';"image"===as?options&&options.imageSrcSet?(preloadSelector+='[imagesrcset="'+escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet)+'"]',"string"===typeof options.imageSizes&&(preloadSelector+='[imagesizes="'+escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes)+'"]')):preloadSelector+='[href="'+escapeSelectorAttributeValueInsideDoubleQuotes(href)+'"]':preloadSelector+='[href="'+escapeSelectorAttributeValueInsideDoubleQuotes(href)+'"]';var key=preloadSelector;switch(as){case "style":key=getStyleKey(href);break;case "script":key=getScriptKey(href);}preloadPropsMap.has(key)||(href=assign({rel:"preload",href:"image"===as&&options&&options.imageSrcSet?void 0:href,as:as},options),preloadPropsMap.set(key,href),null!==ownerDocument.querySelector(preloadSelector)||"style"===as&&ownerDocument.querySelector(getStylesheetSelectorFromKey(key))||"script"===as&&ownerDocument.querySelector(getScriptSelectorFromKey(key))||(as=ownerDocument.createElement("link"),setInitialProperties(as,"link",href),markNodeAsHoistable(as),ownerDocument.head.appendChild(as)));}}function preloadModule(href,options){previousDispatcher.m(href,options);var ownerDocument=globalDocument;if(ownerDocument&&href){var as=options&&"string"===typeof options.as?options.as:"script",preloadSelector='link[rel="modulepreload"][as="'+escapeSelectorAttributeValueInsideDoubleQuotes(as)+'"][href="'+escapeSelectorAttributeValueInsideDoubleQuotes(href)+'"]',key=preloadSelector;switch(as){case "audioworklet":case "paintworklet":case "serviceworker":case "sharedworker":case "worker":case "script":key=getScriptKey(href);}if(!preloadPropsMap.has(key)&&(href=assign({rel:"modulepreload",href:href},options),preloadPropsMap.set(key,href),null===ownerDocument.querySelector(preloadSelector))){switch(as){case "audioworklet":case "paintworklet":case "serviceworker":case "sharedworker":case "worker":case "script":if(ownerDocument.querySelector(getScriptSelectorFromKey(key)))return;}as=ownerDocument.createElement("link");setInitialProperties(as,"link",href);markNodeAsHoistable(as);ownerDocument.head.appendChild(as);}}}function preinitStyle(href,precedence,options){previousDispatcher.S(href,precedence,options);var ownerDocument=globalDocument;if(ownerDocument&&href){var styles=getResourcesFromRoot(ownerDocument).hoistableStyles,key=getStyleKey(href);precedence=precedence||"default";var resource=styles.get(key);if(!resource){var state={loading:0,preload:null};if(resource=ownerDocument.querySelector(getStylesheetSelectorFromKey(key)))state.loading=5;else {href=assign({rel:"stylesheet",href:href,"data-precedence":precedence},options);(options=preloadPropsMap.get(key))&&adoptPreloadPropsForStylesheet(href,options);var link=resource=ownerDocument.createElement("link");markNodeAsHoistable(link);setInitialProperties(link,"link",href);link._p=new Promise(function(resolve,reject){link.onload=resolve;link.onerror=reject;});link.addEventListener("load",function(){state.loading|=1;});link.addEventListener("error",function(){state.loading|=2;});state.loading|=4;insertStylesheet(resource,precedence,ownerDocument);}resource={type:"stylesheet",instance:resource,count:1,state:state};styles.set(key,resource);}}}function preinitScript(src,options){previousDispatcher.X(src,options);var ownerDocument=globalDocument;if(ownerDocument&&src){var scripts=getResourcesFromRoot(ownerDocument).hoistableScripts,key=getScriptKey(src),resource=scripts.get(key);resource||(resource=ownerDocument.querySelector(getScriptSelectorFromKey(key)),resource||(src=assign({src:src,async:true},options),(options=preloadPropsMap.get(key))&&adoptPreloadPropsForScript(src,options),resource=ownerDocument.createElement("script"),markNodeAsHoistable(resource),setInitialProperties(resource,"link",src),ownerDocument.head.appendChild(resource)),resource={type:"script",instance:resource,count:1,state:null},scripts.set(key,resource));}}function preinitModuleScript(src,options){previousDispatcher.M(src,options);var ownerDocument=globalDocument;if(ownerDocument&&src){var scripts=getResourcesFromRoot(ownerDocument).hoistableScripts,key=getScriptKey(src),resource=scripts.get(key);resource||(resource=ownerDocument.querySelector(getScriptSelectorFromKey(key)),resource||(src=assign({src:src,async:true,type:"module"},options),(options=preloadPropsMap.get(key))&&adoptPreloadPropsForScript(src,options),resource=ownerDocument.createElement("script"),markNodeAsHoistable(resource),setInitialProperties(resource,"link",src),ownerDocument.head.appendChild(resource)),resource={type:"script",instance:resource,count:1,state:null},scripts.set(key,resource));}}function getResource(type,currentProps,pendingProps,currentResource){var JSCompiler_inline_result=(JSCompiler_inline_result=rootInstanceStackCursor.current)?getHoistableRoot(JSCompiler_inline_result):null;if(!JSCompiler_inline_result)throw Error(formatProdErrorMessage(446));switch(type){case "meta":case "title":return null;case "style":return "string"===typeof pendingProps.precedence&&"string"===typeof pendingProps.href?(currentProps=getStyleKey(pendingProps.href),pendingProps=getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,currentResource=pendingProps.get(currentProps),currentResource||(currentResource={type:"style",instance:null,count:0,state:null},pendingProps.set(currentProps,currentResource)),currentResource):{type:"void",instance:null,count:0,state:null};case "link":if("stylesheet"===pendingProps.rel&&"string"===typeof pendingProps.href&&"string"===typeof pendingProps.precedence){type=getStyleKey(pendingProps.href);var styles$243=getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,resource$244=styles$243.get(type);resource$244||(JSCompiler_inline_result=JSCompiler_inline_result.ownerDocument||JSCompiler_inline_result,resource$244={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},styles$243.set(type,resource$244),(styles$243=JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type)))&&!styles$243._p&&(resource$244.instance=styles$243,resource$244.state.loading=5),preloadPropsMap.has(type)||(pendingProps={rel:"preload",as:"style",href:pendingProps.href,crossOrigin:pendingProps.crossOrigin,integrity:pendingProps.integrity,media:pendingProps.media,hrefLang:pendingProps.hrefLang,referrerPolicy:pendingProps.referrerPolicy},preloadPropsMap.set(type,pendingProps),styles$243||preloadStylesheet(JSCompiler_inline_result,type,pendingProps,resource$244.state)));if(currentProps&&null===currentResource)throw Error(formatProdErrorMessage(528,""));return resource$244;}if(currentProps&&null!==currentResource)throw Error(formatProdErrorMessage(529,""));return null;case "script":return currentProps=pendingProps.async,pendingProps=pendingProps.src,"string"===typeof pendingProps&&currentProps&&"function"!==typeof currentProps&&"symbol"!==typeof currentProps?(currentProps=getScriptKey(pendingProps),pendingProps=getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts,currentResource=pendingProps.get(currentProps),currentResource||(currentResource={type:"script",instance:null,count:0,state:null},pendingProps.set(currentProps,currentResource)),currentResource):{type:"void",instance:null,count:0,state:null};default:throw Error(formatProdErrorMessage(444,type));}}function getStyleKey(href){return 'href="'+escapeSelectorAttributeValueInsideDoubleQuotes(href)+'"';}function getStylesheetSelectorFromKey(key){return 'link[rel="stylesheet"]['+key+"]";}function stylesheetPropsFromRawProps(rawProps){return assign({},rawProps,{"data-precedence":rawProps.precedence,precedence:null});}function preloadStylesheet(ownerDocument,key,preloadProps,state){ownerDocument.querySelector('link[rel="preload"][as="style"]['+key+"]")?state.loading=1:(key=ownerDocument.createElement("link"),state.preload=key,key.addEventListener("load",function(){return state.loading|=1;}),key.addEventListener("error",function(){return state.loading|=2;}),setInitialProperties(key,"link",preloadProps),markNodeAsHoistable(key),ownerDocument.head.appendChild(key));}function getScriptKey(src){return '[src="'+escapeSelectorAttributeValueInsideDoubleQuotes(src)+'"]';}function getScriptSelectorFromKey(key){return "script[async]"+key;}function acquireResource(hoistableRoot,resource,props){resource.count++;if(null===resource.instance)switch(resource.type){case "style":var instance=hoistableRoot.querySelector('style[data-href~="'+escapeSelectorAttributeValueInsideDoubleQuotes(props.href)+'"]');if(instance)return resource.instance=instance,markNodeAsHoistable(instance),instance;var styleProps=assign({},props,{"data-href":props.href,"data-precedence":props.precedence,href:null,precedence:null});instance=(hoistableRoot.ownerDocument||hoistableRoot).createElement("style");markNodeAsHoistable(instance);setInitialProperties(instance,"style",styleProps);insertStylesheet(instance,props.precedence,hoistableRoot);return resource.instance=instance;case "stylesheet":styleProps=getStyleKey(props.href);var instance$249=hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));if(instance$249)return resource.state.loading|=4,resource.instance=instance$249,markNodeAsHoistable(instance$249),instance$249;instance=stylesheetPropsFromRawProps(props);(styleProps=preloadPropsMap.get(styleProps))&&adoptPreloadPropsForStylesheet(instance,styleProps);instance$249=(hoistableRoot.ownerDocument||hoistableRoot).createElement("link");markNodeAsHoistable(instance$249);var linkInstance=instance$249;linkInstance._p=new Promise(function(resolve,reject){linkInstance.onload=resolve;linkInstance.onerror=reject;});setInitialProperties(instance$249,"link",instance);resource.state.loading|=4;insertStylesheet(instance$249,props.precedence,hoistableRoot);return resource.instance=instance$249;case "script":instance$249=getScriptKey(props.src);if(styleProps=hoistableRoot.querySelector(getScriptSelectorFromKey(instance$249)))return resource.instance=styleProps,markNodeAsHoistable(styleProps),styleProps;instance=props;if(styleProps=preloadPropsMap.get(instance$249))instance=assign({},props),adoptPreloadPropsForScript(instance,styleProps);hoistableRoot=hoistableRoot.ownerDocument||hoistableRoot;styleProps=hoistableRoot.createElement("script");markNodeAsHoistable(styleProps);setInitialProperties(styleProps,"link",instance);hoistableRoot.head.appendChild(styleProps);return resource.instance=styleProps;case "void":return null;default:throw Error(formatProdErrorMessage(443,resource.type));}else "stylesheet"===resource.type&&0===(resource.state.loading&4)&&(instance=resource.instance,resource.state.loading|=4,insertStylesheet(instance,props.precedence,hoistableRoot));return resource.instance;}function insertStylesheet(instance,precedence,root){for(var nodes=root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),last=nodes.length?nodes[nodes.length-1]:null,prior=last,i=0;i<nodes.length;i++){var node=nodes[i];if(node.dataset.precedence===precedence)prior=node;else if(prior!==last)break;}prior?prior.parentNode.insertBefore(instance,prior.nextSibling):(precedence=9===root.nodeType?root.head:root,precedence.insertBefore(instance,precedence.firstChild));}function adoptPreloadPropsForStylesheet(stylesheetProps,preloadProps){null==stylesheetProps.crossOrigin&&(stylesheetProps.crossOrigin=preloadProps.crossOrigin);null==stylesheetProps.referrerPolicy&&(stylesheetProps.referrerPolicy=preloadProps.referrerPolicy);null==stylesheetProps.title&&(stylesheetProps.title=preloadProps.title);}function adoptPreloadPropsForScript(scriptProps,preloadProps){null==scriptProps.crossOrigin&&(scriptProps.crossOrigin=preloadProps.crossOrigin);null==scriptProps.referrerPolicy&&(scriptProps.referrerPolicy=preloadProps.referrerPolicy);null==scriptProps.integrity&&(scriptProps.integrity=preloadProps.integrity);}var tagCaches=null;function getHydratableHoistableCache(type,keyAttribute,ownerDocument){if(null===tagCaches){var cache=new Map();var caches=tagCaches=new Map();caches.set(ownerDocument,cache);}else caches=tagCaches,cache=caches.get(ownerDocument),cache||(cache=new Map(),caches.set(ownerDocument,cache));if(cache.has(type))return cache;cache.set(type,null);ownerDocument=ownerDocument.getElementsByTagName(type);for(caches=0;caches<ownerDocument.length;caches++){var node=ownerDocument[caches];if(!(node[internalHoistableMarker]||node[internalInstanceKey]||"link"===type&&"stylesheet"===node.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==node.namespaceURI){var nodeKey=node.getAttribute(keyAttribute)||"";nodeKey=type+nodeKey;var existing=cache.get(nodeKey);existing?existing.push(node):cache.set(nodeKey,[node]);}}return cache;}function mountHoistable(hoistableRoot,type,instance){hoistableRoot=hoistableRoot.ownerDocument||hoistableRoot;hoistableRoot.head.insertBefore(instance,"title"===type?hoistableRoot.querySelector("head > title"):null);}function isHostHoistableType(type,props,hostContext){if(1===hostContext||null!=props.itemProp)return  false;switch(type){case "meta":case "title":return  true;case "style":if("string"!==typeof props.precedence||"string"!==typeof props.href||""===props.href)break;return  true;case "link":if("string"!==typeof props.rel||"string"!==typeof props.href||""===props.href||props.onLoad||props.onError)break;switch(props.rel){case "stylesheet":return type=props.disabled,"string"===typeof props.precedence&&null==type;default:return  true;}case "script":if(props.async&&"function"!==typeof props.async&&"symbol"!==typeof props.async&&!props.onLoad&&!props.onError&&props.src&&"string"===typeof props.src)return  true;}return  false;}function preloadResource(resource){return "stylesheet"===resource.type&&0===(resource.state.loading&3)?false:true;}function suspendResource(state,hoistableRoot,resource,props){if("stylesheet"===resource.type&&("string"!==typeof props.media||false!==matchMedia(props.media).matches)&&0===(resource.state.loading&4)){if(null===resource.instance){var key=getStyleKey(props.href),instance=hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));if(instance){hoistableRoot=instance._p;null!==hoistableRoot&&"object"===typeof hoistableRoot&&"function"===typeof hoistableRoot.then&&(state.count++,state=onUnsuspend.bind(state),hoistableRoot.then(state,state));resource.state.loading|=4;resource.instance=instance;markNodeAsHoistable(instance);return;}instance=hoistableRoot.ownerDocument||hoistableRoot;props=stylesheetPropsFromRawProps(props);(key=preloadPropsMap.get(key))&&adoptPreloadPropsForStylesheet(props,key);instance=instance.createElement("link");markNodeAsHoistable(instance);var linkInstance=instance;linkInstance._p=new Promise(function(resolve,reject){linkInstance.onload=resolve;linkInstance.onerror=reject;});setInitialProperties(instance,"link",props);resource.instance=instance;}null===state.stylesheets&&(state.stylesheets=new Map());state.stylesheets.set(resource,hoistableRoot);(hoistableRoot=resource.state.preload)&&0===(resource.state.loading&3)&&(state.count++,resource=onUnsuspend.bind(state),hoistableRoot.addEventListener("load",resource),hoistableRoot.addEventListener("error",resource));}}var estimatedBytesWithinLimit=0;function waitForCommitToBeReady(state,timeoutOffset){state.stylesheets&&0===state.count&&insertSuspendedStylesheets(state,state.stylesheets);return 0<state.count||0<state.imgCount?function(commit){var stylesheetTimer=setTimeout(function(){state.stylesheets&&insertSuspendedStylesheets(state,state.stylesheets);if(state.unsuspend){var unsuspend=state.unsuspend;state.unsuspend=null;unsuspend();}},6e4+timeoutOffset);0<state.imgBytes&&0===estimatedBytesWithinLimit&&(estimatedBytesWithinLimit=62500*estimateBandwidth());var imgTimer=setTimeout(function(){state.waitingForImages=false;if(0===state.count&&(state.stylesheets&&insertSuspendedStylesheets(state,state.stylesheets),state.unsuspend)){var unsuspend=state.unsuspend;state.unsuspend=null;unsuspend();}},(state.imgBytes>estimatedBytesWithinLimit?50:800)+timeoutOffset);state.unsuspend=commit;return function(){state.unsuspend=null;clearTimeout(stylesheetTimer);clearTimeout(imgTimer);};}:null;}function onUnsuspend(){this.count--;if(0===this.count&&(0===this.imgCount||!this.waitingForImages))if(this.stylesheets)insertSuspendedStylesheets(this,this.stylesheets);else if(this.unsuspend){var unsuspend=this.unsuspend;this.unsuspend=null;unsuspend();}}var precedencesByRoot=null;function insertSuspendedStylesheets(state,resources){state.stylesheets=null;null!==state.unsuspend&&(state.count++,precedencesByRoot=new Map(),resources.forEach(insertStylesheetIntoRoot,state),precedencesByRoot=null,onUnsuspend.call(state));}function insertStylesheetIntoRoot(root,resource){if(!(resource.state.loading&4)){var precedences=precedencesByRoot.get(root);if(precedences)var last=precedences.get(null);else {precedences=new Map();precedencesByRoot.set(root,precedences);for(var nodes=root.querySelectorAll("link[data-precedence],style[data-precedence]"),i=0;i<nodes.length;i++){var node=nodes[i];if("LINK"===node.nodeName||"not all"!==node.getAttribute("media"))precedences.set(node.dataset.precedence,node),last=node;}last&&precedences.set(null,last);}nodes=resource.instance;node=nodes.getAttribute("data-precedence");i=precedences.get(node)||last;i===last&&precedences.set(null,nodes);precedences.set(node,nodes);this.count++;last=onUnsuspend.bind(this);nodes.addEventListener("load",last);nodes.addEventListener("error",last);i?i.parentNode.insertBefore(nodes,i.nextSibling):(root=9===root.nodeType?root.head:root,root.insertBefore(nodes,root.firstChild));resource.state.loading|=4;}}var HostTransitionContext={$$typeof:REACT_CONTEXT_TYPE,Provider:null,Consumer:null,_currentValue:sharedNotPendingObject,_currentValue2:sharedNotPendingObject,_threadCount:0};function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onUncaughtError,onCaughtError,onRecoverableError,onDefaultTransitionIndicator,formState){this.tag=1;this.containerInfo=containerInfo;this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null;this.callbackPriority=0;this.expirationTimes=createLaneMap(-1);this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=createLaneMap(0);this.hiddenUpdates=createLaneMap(null);this.identifierPrefix=identifierPrefix;this.onUncaughtError=onUncaughtError;this.onCaughtError=onCaughtError;this.onRecoverableError=onRecoverableError;this.pooledCache=null;this.pooledCacheLanes=0;this.formState=formState;this.incompleteTransitions=new Map();}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,identifierPrefix,formState,onUncaughtError,onCaughtError,onRecoverableError,onDefaultTransitionIndicator){containerInfo=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onUncaughtError,onCaughtError,onRecoverableError,onDefaultTransitionIndicator,formState);tag=1;true===isStrictMode&&(tag|=24);isStrictMode=createFiberImplClass(3,null,null,tag);containerInfo.current=isStrictMode;isStrictMode.stateNode=containerInfo;tag=createCache();tag.refCount++;containerInfo.pooledCache=tag;tag.refCount++;isStrictMode.memoizedState={element:initialChildren,isDehydrated:hydrate,cache:tag};initializeUpdateQueue(isStrictMode);return containerInfo;}function getContextForSubtree(parentComponent){if(!parentComponent)return emptyContextObject;parentComponent=emptyContextObject;return parentComponent;}function updateContainerImpl(rootFiber,lane,element,container,parentComponent,callback){parentComponent=getContextForSubtree(parentComponent);null===container.context?container.context=parentComponent:container.pendingContext=parentComponent;container=createUpdate(lane);container.payload={element:element};callback=void 0===callback?null:callback;null!==callback&&(container.callback=callback);element=enqueueUpdate(rootFiber,container,lane);null!==element&&(scheduleUpdateOnFiber(element,rootFiber,lane),entangleTransitions(element,rootFiber,lane));}function markRetryLaneImpl(fiber,retryLane){fiber=fiber.memoizedState;if(null!==fiber&&null!==fiber.dehydrated){var a=fiber.retryLane;fiber.retryLane=0!==a&&a<retryLane?a:retryLane;}}function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);(fiber=fiber.alternate)&&markRetryLaneImpl(fiber,retryLane);}function attemptContinuousHydration(fiber){if(13===fiber.tag||31===fiber.tag){var root=enqueueConcurrentRenderForLane(fiber,67108864);null!==root&&scheduleUpdateOnFiber(root,fiber,67108864);markRetryLaneIfNotHydrated(fiber,67108864);}}function attemptHydrationAtCurrentPriority(fiber){if(13===fiber.tag||31===fiber.tag){var lane=requestUpdateLane();lane=getBumpedLaneForHydrationByLane(lane);var root=enqueueConcurrentRenderForLane(fiber,lane);null!==root&&scheduleUpdateOnFiber(root,fiber,lane);markRetryLaneIfNotHydrated(fiber,lane);}}var _enabled=true;function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var prevTransition=ReactSharedInternals.T;ReactSharedInternals.T=null;var previousPriority=ReactDOMSharedInternals.p;try{ReactDOMSharedInternals.p=2,dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{ReactDOMSharedInternals.p=previousPriority,ReactSharedInternals.T=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var prevTransition=ReactSharedInternals.T;ReactSharedInternals.T=null;var previousPriority=ReactDOMSharedInternals.p;try{ReactDOMSharedInternals.p=8,dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{ReactDOMSharedInternals.p=previousPriority,ReactSharedInternals.T=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(_enabled){var blockedOn=findInstanceBlockingEvent(nativeEvent);if(null===blockedOn)dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer),clearIfContinuousEvent(domEventName,nativeEvent);else if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent))nativeEvent.stopPropagation();else if(clearIfContinuousEvent(domEventName,nativeEvent),eventSystemFlags&4&&-1<discreteReplayableEvents.indexOf(domEventName)){for(;null!==blockedOn;){var fiber=getInstanceFromNode(blockedOn);if(null!==fiber)switch(fiber.tag){case 3:fiber=fiber.stateNode;if(fiber.current.memoizedState.isDehydrated){var lanes=getHighestPriorityLanes(fiber.pendingLanes);if(0!==lanes){var root=fiber;root.pendingLanes|=2;for(root.entangledLanes|=2;lanes;){var lane=1<<31-clz32(lanes);root.entanglements[1]|=lane;lanes&=~lane;}ensureRootIsScheduled(fiber);0===(executionContext&6)&&(workInProgressRootRenderTargetTime=now()+500,flushSyncWorkAcrossRoots_impl(0));}}break;case 31:case 13:root=enqueueConcurrentRenderForLane(fiber,2),null!==root&&scheduleUpdateOnFiber(root,fiber,2),flushSyncWork$1(),markRetryLaneIfNotHydrated(fiber,2);}fiber=findInstanceBlockingEvent(nativeEvent);null===fiber&&dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);if(fiber===blockedOn)break;blockedOn=fiber;}null!==blockedOn&&nativeEvent.stopPropagation();}else dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}}function findInstanceBlockingEvent(nativeEvent){nativeEvent=getEventTarget(nativeEvent);return findInstanceBlockingTarget(nativeEvent);}var return_targetInst=null;function findInstanceBlockingTarget(targetNode){return_targetInst=null;targetNode=getClosestInstanceFromNode(targetNode);if(null!==targetNode){var nearestMounted=getNearestMountedFiber(targetNode);if(null===nearestMounted)targetNode=null;else {var tag=nearestMounted.tag;if(13===tag){targetNode=getSuspenseInstanceFromFiber(nearestMounted);if(null!==targetNode)return targetNode;targetNode=null;}else if(31===tag){targetNode=getActivityInstanceFromFiber(nearestMounted);if(null!==targetNode)return targetNode;targetNode=null;}else if(3===tag){if(nearestMounted.stateNode.current.memoizedState.isDehydrated)return 3===nearestMounted.tag?nearestMounted.stateNode.containerInfo:null;targetNode=null;}else nearestMounted!==targetNode&&(targetNode=null);}}return_targetInst=targetNode;return null;}function getEventPriority(domEventName){switch(domEventName){case "beforetoggle":case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "toggle":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 2;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 8;case "message":switch(getCurrentPriorityLevel()){case ImmediatePriority:return 2;case UserBlockingPriority:return 8;case NormalPriority$1:case LowPriority:return 32;case IdlePriority:return 268435456;default:return 32;}default:return 32;}}var hasScheduledReplayAttempt=false,queuedFocus=null,queuedDrag=null,queuedMouse=null,queuedPointers=new Map(),queuedPointerCaptures=new Map(),queuedExplicitHydrationTargets=[],discreteReplayableEvents="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case "focusin":case "focusout":queuedFocus=null;break;case "dragenter":case "dragleave":queuedDrag=null;break;case "mouseover":case "mouseout":queuedMouse=null;break;case "pointerover":case "pointerout":queuedPointers.delete(nativeEvent.pointerId);break;case "gotpointercapture":case "lostpointercapture":queuedPointerCaptures.delete(nativeEvent.pointerId);}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(null===existingQueuedEvent||existingQueuedEvent.nativeEvent!==nativeEvent)return existingQueuedEvent={blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]},null!==blockedOn&&(blockedOn=getInstanceFromNode(blockedOn),null!==blockedOn&&attemptContinuousHydration(blockedOn)),existingQueuedEvent;existingQueuedEvent.eventSystemFlags|=eventSystemFlags;blockedOn=existingQueuedEvent.targetContainers;null!==targetContainer&&-1===blockedOn.indexOf(targetContainer)&&blockedOn.push(targetContainer);return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){switch(domEventName){case "focusin":return queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent),true;case "dragenter":return queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent),true;case "mouseover":return queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent),true;case "pointerover":var pointerId=nativeEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent));return  true;case "gotpointercapture":return pointerId=nativeEvent.pointerId,queuedPointerCaptures.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)),true;}return  false;}function attemptExplicitHydrationTarget(queuedTarget){var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(null!==targetInst){var nearestMounted=getNearestMountedFiber(targetInst);if(null!==nearestMounted)if(targetInst=nearestMounted.tag,13===targetInst){if(targetInst=getSuspenseInstanceFromFiber(nearestMounted),null!==targetInst){queuedTarget.blockedOn=targetInst;runWithPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(31===targetInst){if(targetInst=getActivityInstanceFromFiber(nearestMounted),null!==targetInst){queuedTarget.blockedOn=targetInst;runWithPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(3===targetInst&&nearestMounted.stateNode.current.memoizedState.isDehydrated){queuedTarget.blockedOn=3===nearestMounted.tag?nearestMounted.stateNode.containerInfo:null;return;}}queuedTarget.blockedOn=null;}function attemptReplayContinuousQueuedEvent(queuedEvent){if(null!==queuedEvent.blockedOn)return  false;for(var targetContainers=queuedEvent.targetContainers;0<targetContainers.length;){var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.nativeEvent);if(null===nextBlockedOn){nextBlockedOn=queuedEvent.nativeEvent;var nativeEventClone=new nextBlockedOn.constructor(nextBlockedOn.type,nextBlockedOn);currentReplayingEvent=nativeEventClone;nextBlockedOn.target.dispatchEvent(nativeEventClone);currentReplayingEvent=null;}else return targetContainers=getInstanceFromNode(nextBlockedOn),null!==targetContainers&&attemptContinuousHydration(targetContainers),queuedEvent.blockedOn=nextBlockedOn,false;targetContainers.shift();}return  true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){attemptReplayContinuousQueuedEvent(queuedEvent)&&map.delete(key);}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;null!==queuedFocus&&attemptReplayContinuousQueuedEvent(queuedFocus)&&(queuedFocus=null);null!==queuedDrag&&attemptReplayContinuousQueuedEvent(queuedDrag)&&(queuedDrag=null);null!==queuedMouse&&attemptReplayContinuousQueuedEvent(queuedMouse)&&(queuedMouse=null);queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){queuedEvent.blockedOn===unblocked&&(queuedEvent.blockedOn=null,hasScheduledReplayAttempt||(hasScheduledReplayAttempt=true,Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents)));}var lastScheduledReplayQueue=null;function scheduleReplayQueueIfNeeded(formReplayingQueue){lastScheduledReplayQueue!==formReplayingQueue&&(lastScheduledReplayQueue=formReplayingQueue,Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,function(){lastScheduledReplayQueue===formReplayingQueue&&(lastScheduledReplayQueue=null);for(var i=0;i<formReplayingQueue.length;i+=3){var form=formReplayingQueue[i],submitterOrAction=formReplayingQueue[i+1],formData=formReplayingQueue[i+2];if("function"!==typeof submitterOrAction)if(null===findInstanceBlockingTarget(submitterOrAction||form))continue;else break;var formInst=getInstanceFromNode(form);null!==formInst&&(formReplayingQueue.splice(i,3),i-=3,startHostTransition(formInst,{pending:true,data:formData,method:form.method,action:submitterOrAction},submitterOrAction,formData));}}));}function retryIfBlockedOn(unblocked){function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);}null!==queuedFocus&&scheduleCallbackIfUnblocked(queuedFocus,unblocked);null!==queuedDrag&&scheduleCallbackIfUnblocked(queuedDrag,unblocked);null!==queuedMouse&&scheduleCallbackIfUnblocked(queuedMouse,unblocked);queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var i=0;i<queuedExplicitHydrationTargets.length;i++){var queuedTarget=queuedExplicitHydrationTargets[i];queuedTarget.blockedOn===unblocked&&(queuedTarget.blockedOn=null);}for(;0<queuedExplicitHydrationTargets.length&&(i=queuedExplicitHydrationTargets[0],null===i.blockedOn);)attemptExplicitHydrationTarget(i),null===i.blockedOn&&queuedExplicitHydrationTargets.shift();i=(unblocked.ownerDocument||unblocked).$$reactFormReplay;if(null!=i)for(queuedTarget=0;queuedTarget<i.length;queuedTarget+=3){var form=i[queuedTarget],submitterOrAction=i[queuedTarget+1],formProps=form[internalPropsKey]||null;if("function"===typeof submitterOrAction)formProps||scheduleReplayQueueIfNeeded(i);else if(formProps){var action=null;if(submitterOrAction&&submitterOrAction.hasAttribute("formAction")){if(form=submitterOrAction,formProps=submitterOrAction[internalPropsKey]||null)action=formProps.formAction;else {if(null!==findInstanceBlockingTarget(form))continue;}}else action=formProps.action;"function"===typeof action?i[queuedTarget+1]=action:(i.splice(queuedTarget,3),queuedTarget-=3);scheduleReplayQueueIfNeeded(i);}}}function defaultOnDefaultTransitionIndicator(){function handleNavigate(event){event.canIntercept&&"react-transition"===event.info&&event.intercept({handler:function(){return new Promise(function(resolve){return pendingResolve=resolve;});},focusReset:"manual",scroll:"manual"});}function handleNavigateComplete(){null!==pendingResolve&&(pendingResolve(),pendingResolve=null);isCancelled||setTimeout(startFakeNavigation,20);}function startFakeNavigation(){if(!isCancelled&&!navigation.transition){var currentEntry=navigation.currentEntry;currentEntry&&null!=currentEntry.url&&navigation.navigate(currentEntry.url,{state:currentEntry.getState(),info:"react-transition",history:"replace"});}}if("object"===typeof navigation){var isCancelled=false,pendingResolve=null;navigation.addEventListener("navigate",handleNavigate);navigation.addEventListener("navigatesuccess",handleNavigateComplete);navigation.addEventListener("navigateerror",handleNavigateComplete);setTimeout(startFakeNavigation,100);return function(){isCancelled=true;navigation.removeEventListener("navigate",handleNavigate);navigation.removeEventListener("navigatesuccess",handleNavigateComplete);navigation.removeEventListener("navigateerror",handleNavigateComplete);null!==pendingResolve&&(pendingResolve(),pendingResolve=null);};}}function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(null===root)throw Error(formatProdErrorMessage(409));var current=root.current,lane=requestUpdateLane();updateContainerImpl(current,lane,children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){var root=this._internalRoot;if(null!==root){this._internalRoot=null;var container=root.containerInfo;updateContainerImpl(root.current,2,null,root,null,null);flushSyncWork$1();container[internalContainerInstanceKey]=null;}};function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=function(target){if(target){var updatePriority=resolveUpdatePriority();target={blockedOn:null,target:target,priority:updatePriority};for(var i=0;i<queuedExplicitHydrationTargets.length&&0!==updatePriority&&updatePriority<queuedExplicitHydrationTargets[i].priority;i++);queuedExplicitHydrationTargets.splice(i,0,target);0===i&&attemptExplicitHydrationTarget(target);}};var isomorphicReactPackageVersion$jscomp$inline_1840=React.version;if("19.2.1"!==isomorphicReactPackageVersion$jscomp$inline_1840)throw Error(formatProdErrorMessage(527,isomorphicReactPackageVersion$jscomp$inline_1840,"19.2.1"));ReactDOMSharedInternals.findDOMNode=function(componentOrElement){var fiber=componentOrElement._reactInternals;if(void 0===fiber){if("function"===typeof componentOrElement.render)throw Error(formatProdErrorMessage(188));componentOrElement=Object.keys(componentOrElement).join(",");throw Error(formatProdErrorMessage(268,componentOrElement));}componentOrElement=findCurrentFiberUsingSlowPath(fiber);componentOrElement=null!==componentOrElement?findCurrentHostFiberImpl(componentOrElement):null;componentOrElement=null===componentOrElement?null:componentOrElement.stateNode;return componentOrElement;};var internals$jscomp$inline_2347={bundleType:0,version:"19.2.1",rendererPackageName:"react-dom",currentDispatcherRef:ReactSharedInternals,reconcilerVersion:"19.2.1"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var hook$jscomp$inline_2348=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!hook$jscomp$inline_2348.isDisabled&&hook$jscomp$inline_2348.supportsFiber)try{rendererID=hook$jscomp$inline_2348.inject(internals$jscomp$inline_2347),injectedHook=hook$jscomp$inline_2348;}catch(err){}}reactDomClient_production.createRoot=function(container,options){if(!isValidContainer(container))throw Error(formatProdErrorMessage(299));var isStrictMode=false,identifierPrefix="",onUncaughtError=defaultOnUncaughtError,onCaughtError=defaultOnCaughtError,onRecoverableError=defaultOnRecoverableError;null!==options&&void 0!==options&&(true===options.unstable_strictMode&&(isStrictMode=true),void 0!==options.identifierPrefix&&(identifierPrefix=options.identifierPrefix),void 0!==options.onUncaughtError&&(onUncaughtError=options.onUncaughtError),void 0!==options.onCaughtError&&(onCaughtError=options.onCaughtError),void 0!==options.onRecoverableError&&(onRecoverableError=options.onRecoverableError));options=createFiberRoot(container,1,false,null,null,isStrictMode,identifierPrefix,null,onUncaughtError,onCaughtError,onRecoverableError,defaultOnDefaultTransitionIndicator);container[internalContainerInstanceKey]=options.current;listenToAllSupportedEvents(container);return new ReactDOMRoot(options);};reactDomClient_production.hydrateRoot=function(container,initialChildren,options){if(!isValidContainer(container))throw Error(formatProdErrorMessage(299));var isStrictMode=false,identifierPrefix="",onUncaughtError=defaultOnUncaughtError,onCaughtError=defaultOnCaughtError,onRecoverableError=defaultOnRecoverableError,formState=null;null!==options&&void 0!==options&&(true===options.unstable_strictMode&&(isStrictMode=true),void 0!==options.identifierPrefix&&(identifierPrefix=options.identifierPrefix),void 0!==options.onUncaughtError&&(onUncaughtError=options.onUncaughtError),void 0!==options.onCaughtError&&(onCaughtError=options.onCaughtError),void 0!==options.onRecoverableError&&(onRecoverableError=options.onRecoverableError),void 0!==options.formState&&(formState=options.formState));initialChildren=createFiberRoot(container,1,true,initialChildren,null!=options?options:null,isStrictMode,identifierPrefix,formState,onUncaughtError,onCaughtError,onRecoverableError,defaultOnDefaultTransitionIndicator);initialChildren.context=getContextForSubtree(null);options=initialChildren.current;isStrictMode=requestUpdateLane();isStrictMode=getBumpedLaneForHydrationByLane(isStrictMode);identifierPrefix=createUpdate(isStrictMode);identifierPrefix.callback=null;enqueueUpdate(options,identifierPrefix,isStrictMode);options=isStrictMode;initialChildren.current.lanes=options;markRootUpdated$1(initialChildren,options);ensureRootIsScheduled(initialChildren);container[internalContainerInstanceKey]=initialChildren.current;listenToAllSupportedEvents(container);return new ReactDOMHydrationRoot(initialChildren);};reactDomClient_production.version="19.2.1";
	return reactDomClient_production;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client.exports;
	hasRequiredClient = 1;

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}
	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  client.exports = requireReactDomClient_production();
	}
	return client.exports;
}

var clientExports = requireClient();
var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(clientExports);

function TabNavigation({
  children
}) {
  const location = useLocation();
  return /*#__PURE__*/React.createElement(tab_group_default, null, /*#__PURE__*/React.createElement(tab_default, {
    active: location.pathname === "/",
    slot: "nav",
    panel: "home"
  }, /*#__PURE__*/React.createElement(Link, {
    className: "no-underline",
    to: "/"
  }, "Home")), /*#__PURE__*/React.createElement(tab_default, {
    active: location.pathname === "/about",
    slot: "nav",
    panel: "about"
  }, /*#__PURE__*/React.createElement(Link, {
    className: "no-underline",
    to: "/about"
  }, "About")), /*#__PURE__*/React.createElement(tab_panel_default, {
    name: "home"
  }, children), /*#__PURE__*/React.createElement(tab_panel_default, {
    name: "about"
  }, children));
}

function Root() {
  return /*#__PURE__*/React.createElement(Routes, null, /*#__PURE__*/React.createElement(Route, {
    element: /*#__PURE__*/React.createElement(TabNavigation, null, /*#__PURE__*/React.createElement(Outlet, null))
  }, /*#__PURE__*/React.createElement(Route, {
    index: true,
    path: "/",
    element: /*#__PURE__*/React.createElement(Home, null)
  }), /*#__PURE__*/React.createElement(Route, {
    path: "/about",
    element: /*#__PURE__*/React.createElement(About, null)
  })));
}
function App() {
  const {
    falcon,
    navigation,
    isInitialized
  } = useFalconApiContext();
  if (!isInitialized) {
    return null;
  }
  return /*#__PURE__*/React.createElement(React.StrictMode, null, /*#__PURE__*/React.createElement(FalconApiContext.Provider, {
    value: {
      falcon,
      navigation,
      isInitialized
    }
  }, /*#__PURE__*/React.createElement(HashRouter, null, /*#__PURE__*/React.createElement(Root, null))));
}
const domContainer = document.querySelector("#app");
const root = ReactDOM.createRoot(domContainer);
root.render(/*#__PURE__*/React.createElement(App, null));
